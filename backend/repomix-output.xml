This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
__tests__/__factories__/conversationFactory.js
__tests__/__factories__/messageFactory.js
__tests__/__factories__/userFactory.js
__tests__/__helpers__/testSetup.js
__tests__/__helpers__/testUtils.js
__tests__/integration/api/conversations.test.js
__tests__/integration/api/messages.test.js
__tests__/integration/api/participants.test.js
__tests__/unit/middleware/validators/conversationValidator.test.js
__tests__/unit/middleware/validators/messageValidator.test.js
__tests__/unit/middleware/validators/participantValidator.test.js
__tests__/unit/services/conversationService.test.js
__tests__/unit/services/messageService.test.js
__tests__/unit/services/participantService.test.js
.env.example
.sequelizerc
config/config.js
config/config.json
config/passport.js
controllers/authController.js
controllers/chatController.js
controllers/conversationController.js
controllers/messageController.js
controllers/participantController.js
controllers/userController.js
docs/api-specification.yml
middleware/auth.js
middleware/authMiddleware.js
middleware/authValidators.js
middleware/errorHandler.js
middleware/validation.js
middleware/validators/conversationValidator.js
middleware/validators/messageValidator.js
middleware/validators/participantValidator.js
middleware/websocket/auth.js
middleware/websocket/errorHandler.js
migrations/20250516003134-create-users.js
migrations/20250516003411-create-conversations.js
migrations/20250516003459-create-messages.js
migrations/20250516003709-create-user-conversations-join-table.js
migrations/20250516003800-create-user-conversation.js
migrations/20250516052212-add-auth-fields-to-user.js
migrations/20250516090000-add-missing-user-columns.js
migrations/20250516090001-update-conversations-table.js
migrations/20250516234001-add-parent-message-id-to-messages.js
migrations/20250516234933-add-metadata-to-messages.js
models/Conversation.js
models/index.js
models/Message.js
models/User.js
models/UserConversation.js
package.json
README.md
routes/api/conversations.js
routes/api/messages.js
routes/api/participants.js
routes/auth.js
routes/authRoutes.js
routes/conversations.js
routes/messages.js
routes/participants.js
routes/users.js
scripts/checkDbStructure.js
scripts/createSpecificUser.js
scripts/debugConversationModel.js
scripts/update-test-user-email.js
seeders/20250516164510-add-test-user.js
seeders/20250516164600-add-test-user-seed.js
seeders/createTestUser.js
server.js
services/authService.js
services/chatService.js
services/conversationService.js
services/messageService.js
services/participantService.js
services/socketService.js
socket/events.js
socket/events/index.js
socket/events/messageHandlers.js
socket/events/readReceiptHandlers.js
socket/events/userHandlers.js
socket/index.js
src/api/chat/messages.js
src/api/chat/rooms.js
src/api/controllers/conversationController.js
src/api/controllers/taskController.js
src/api/controllers/userController.js
src/api/middlewares/auth.js
src/api/middlewares/errorHandler.js
src/api/routes/conversationRoutes.js
src/api/routes/taskRoutes.js
src/api/routes/userRoutes.js
src/api/socket/socket.js
src/config/database.js
src/config/sequelize.js
src/models/ChatRoom.js
src/models/Conversation.js
src/models/EmotionalState.js
src/models/index.js
src/models/Message.js
src/models/Task.js
src/models/User.js
src/services/ai/adaptiveCoaching.js
src/services/ai/chatService.js
src/services/ai/emotionDetection.js
src/services/ai/languageModel.js
src/services/chat/messageService.js
src/services/chat/roomService.js
src/services/socket/socketService.js
src/services/task/reminderService.js
src/services/task/taskBreakdown.js
src/services/user/preferencesService.js
src/services/user/profileService.js
src/utils/chatUtils.js
src/utils/logger.js
utils/errorHandler.js
utils/errors.js
utils/logger.js
utils/socketUtils.js
utils/validators.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/__factories__/conversationFactory.js">
/**
 * Factory for creating test conversation instances.
 * Provides methods to generate mock conversation data with various states for testing.
 */
</file>

<file path="__tests__/__factories__/messageFactory.js">
/**
 * Factory for creating test message instances.
 * Provides methods to generate mock message data with various content types and states.
 */
</file>

<file path="__tests__/__factories__/userFactory.js">
/**
 * Factory for creating test user instances.
 * Provides methods to generate mock user data for testing purposes.
 */
</file>

<file path="__tests__/__helpers__/testSetup.js">
/**
 * Test setup and teardown utilities.
 * Handles database connection, test environment configuration, and cleanup routines.
 */
</file>

<file path="__tests__/__helpers__/testUtils.js">
/**
 * Common test utilities and helper functions.
 * Contains shared test assertions, mocks, and utility functions used across test suites.
 */
</file>

<file path="__tests__/integration/api/conversations.test.js">
/**
 * Integration tests for /api/conversations endpoints
 * Tests the complete flow of conversation-related API endpoints including request/response cycles.
 */
</file>

<file path="__tests__/integration/api/messages.test.js">
/**
 * Integration tests for /api/conversations/:conversationId/messages endpoints
 * Tests the complete flow of message-related API endpoints and their interactions with the database.
 */
</file>

<file path="__tests__/integration/api/participants.test.js">
/**
 * Integration tests for /api/conversations/:conversationId/participants endpoints
 * Tests the complete flow of participant management API endpoints and their database interactions.
 */
</file>

<file path="__tests__/unit/middleware/validators/conversationValidator.test.js">
/**
 * Unit tests for conversationValidator.js
 * Tests request validation for conversation-related endpoints including request body and parameter validation.
 */
</file>

<file path="__tests__/unit/middleware/validators/messageValidator.test.js">
/**
 * Unit tests for messageValidator.js
 * Tests request validation for message-related endpoints including message content and query parameters.
 */
</file>

<file path="__tests__/unit/middleware/validators/participantValidator.test.js">
/**
 * Unit tests for participantValidator.js
 * Tests request validation for participant management endpoints including add/remove operations.
 */
</file>

<file path="__tests__/unit/services/conversationService.test.js">
/**
 * Unit tests for conversationService.js
 * Tests core conversation business logic including creation, retrieval, and management of conversations.
 */
</file>

<file path="__tests__/unit/services/messageService.test.js">
/**
 * Unit tests for messageService.js
 * Tests core message handling logic including sending, retrieving, and managing message statuses.
 */
</file>

<file path="__tests__/unit/services/participantService.test.js">
/**
 * Unit tests for participantService.js
 * Tests participant management logic including adding and removing participants from conversations.
 */
</file>

<file path=".env.example">
# Server Configuration
PORT=5000
NODE_ENV=development

# Database Configuration
DB_USERNAME=your_db_username
DB_PASSWORD=your_db_password
DB_DATABASE=your_database_name
DB_HOST=localhost
DB_DIALECT=mysql

# JWT Configuration
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRATION=86400 # 24 hours in seconds

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000 # 15 minutes
RATE_LIMIT_MAX=100 # requests per window

# Client URL for CORS
CLIENT_URL=http://localhost:3000

# AI Coach Configuration
AI_COACH_USER_ID=bffc93b4-f1d1-4395-bd7e-aef35648ed4e

# OpenAI API Configuration
OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=gpt-3.5-turbo
</file>

<file path=".sequelizerc">
const path = require('path');

module.exports = {
  'config': path.resolve('config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('seeders'),
  'migrations-path': path.resolve('migrations')
};
</file>

<file path="config/config.js">
/**
 * Database configuration for different environments.
 * Loads environment variables from the project root .env file.
 * 
 * @module config/database
 * @requires dotenv
 * @requires path
 */

require('dotenv').config({ path: require('path').resolve(__dirname, '../.env') });

module.exports = {
  jwt: {
    secret: process.env.JWT_SECRET || 'your_default_jwt_secret_key',
    refreshSecret: process.env.JWT_REFRESH_SECRET || 'your_default_jwt_refresh_secret_key',
    accessExpirationMinutes: process.env.JWT_ACCESS_EXPIRATION_MINUTES || 60, // 1 hour
    refreshExpirationDays: process.env.JWT_REFRESH_EXPIRATION_DAYS || 7, // 7 days
    passwordResetExpirationMinutes: parseInt(process.env.JWT_PASSWORD_RESET_EXPIRATION_MINUTES || '60', 10), // 1 hour
    emailVerificationExpirationMinutes: parseInt(process.env.JWT_EMAIL_VERIFICATION_EXPIRATION_MINUTES || '1440', 10), // 24 hours (1 day)
    cookieOptions: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    },
  },
  development: {
    username: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || 'Loloreno1',
    database: process.env.DB_NAME || 'coach_ally',
    host: process.env.DB_HOST || '127.0.0.1',
    port: parseInt(process.env.DB_PORT, 10) || 3306,
    dialect: 'mysql',
    logging: (msg) => {
      console.log(msg); // Log to console
      const fs = require('fs');
      const path = require('path');
      const logDir = path.join(__dirname, '../logs');
      const logFile = path.join(logDir, 'sql.log');
      
      // Ensure logs directory exists
      if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
      }
      
      // Write to log file
      fs.appendFileSync(logFile, `${new Date().toISOString()} - ${msg}\n`);
    }, // Log SQL queries for debugging
    dialectOptions: {
      //charset: 'utf8mb4_general_ci', // Example: if you need specific charset
      // ssl: process.env.DB_SSL === 'true' ? { require: true, rejectUnauthorized: false } : false,
    }
  },
  test: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: `${process.env.DB_NAME}_test`,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: false,  // Disable logging during tests
    ssl: false
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: false,  // Disable logging in production
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false  // For self-signed certificates
      }
    }
  }
};
</file>

<file path="config/config.json">
{
  "development": {
    "username": "root",
    "password": "Loloreno1",
    "database": "coach_ally",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "test": {
    "username": "root",
    "password": "Loloreno1",
    "database": "coach_ally",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "production": {
    "username": "root",
    "password": "Loloreno1",
    "database": "coach_ally",
    "host": "127.0.0.1",
    "dialect": "mysql"
  }
}
</file>

<file path="config/passport.js">
/**
 * Passport.js configuration for authentication strategies.
 * 
 * This module sets up JWT and Local authentication strategies using Passport.js.
 * It handles user authentication, token verification, and session management.
 * 
 * @module config/passport
 * @requires passport
 * @requires passport-jwt
 * @requires passport-local
 * @requires jsonwebtoken
 * @requires ../models/User
 * @requires ./config
 */

// File will be implemented with:
// 1. JWT Strategy for token-based authentication
// 2. Local Strategy for username/password login
// 3. Helper functions for token generation and verification
// 4. Serialization/deserialization of users

// Implementation details will be added when developing the authentication system
</file>

<file path="controllers/authController.js">
/**
 * Authentication Controller
 * 
 * Handles user authentication including registration, login, token refresh, and logout.
 * Manages JWT token generation and refresh token rotation.
 * 
 * @module controllers/authController
 * @requires jsonwebtoken
 * @requires bcryptjs
 * @requires ../models/User
 * @requires ../utils/logger
 * @requires ../utils/validators
 * @requires ../config/config
 * 
 * @example
 * // Example routes that use this controller:
 * POST /api/auth/register - Register a new user
 * POST /api/auth/login - User login
 * POST /api/auth/refresh-token - Refresh access token
 * POST /api/auth/logout - Invalidate refresh token
 */

const authService = require('../services/authService');
const logger = require('../utils/logger');
const httpStatusCodes = require('http-status-codes');
const config = require('../config/config'); // For cookie options

// Helper to set refresh token cookie
const setRefreshTokenCookie = (res, refreshToken) => {
  res.cookie('refreshToken', refreshToken, {
    ...config.jwt.cookieOptions,
    maxAge: config.jwt.refreshExpirationDays * 24 * 60 * 60 * 1000, // in milliseconds
  });
};

/**
 * @desc    Register a new user
 * @route   POST /api/auth/register
 * @access  Public
 */
const register = async (req, res, next) => {
  try {
    const { username, email, password, first_name, last_name } = req.body; // Using snake_case to match request body
    // Basic validation - more robust validation should be in middleware
    if (!username || !email || !password) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Username, email, and password are required.' });
    }

    const user = await authService.registerUser({ 
      username, 
      email, 
      password, 
      first_name, 
      last_name 
    });
    
    // Optionally, log the user in immediately and send tokens
    // For now, just return the created user, client can then proceed to login
    logger.info(`User registered: ${user.email}`);
    res.status(httpStatusCodes.CREATED).json(user); // User object is sanitized by toJSON in model
  } catch (error) {
    // Errors from authService (like BadRequestError for existing user) will be caught here
    // The global errorHandler middleware should handle ApiError instances
    next(error); 
  }
};

/**
 * @desc    Authenticate user & get token
 * @route   POST /api/auth/login
 * @access  Public
 */
const login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Email and password are required.' });
    }

    const { user, tokens } = await authService.loginUser(email, password);

    setRefreshTokenCookie(res, tokens.refreshToken);

    logger.info(`User logged in: ${user.email}`);
    res.status(httpStatusCodes.OK).json({
      accessToken: tokens.accessToken,
      user: user, // User object is sanitized by toJSON in model
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Refresh access token
 * @route   POST /api/auth/refresh-token
 * @access  Public (requires valid refresh token cookie)
 */
const refreshToken = async (req, res, next) => {
  try {
    const oldRefreshToken = req.cookies?.refreshToken;
    if (!oldRefreshToken) {
      return res.status(httpStatusCodes.UNAUTHORIZED).json({ message: 'Refresh token not found.' });
    }

    const newTokens = await authService.refreshAuthTokens(oldRefreshToken);

    setRefreshTokenCookie(res, newTokens.refreshToken);

    logger.info('Access token refreshed successfully.');
    res.status(httpStatusCodes.OK).json({
      accessToken: newTokens.accessToken,
    });
  } catch (error) {
    // If refresh token is invalid/expired, authService throws UnauthorizedError
    // Clear the cookie if the refresh token is bad
    if (error.statusCode === httpStatusCodes.UNAUTHORIZED || error.statusCode === httpStatusCodes.BAD_REQUEST) {
      res.clearCookie('refreshToken', config.jwt.cookieOptions);
    }
    next(error);
  }
};

/**
 * @desc    Logout user (invalidate refresh token)
 * @route   POST /api/auth/logout
 * @access  Private (requires authentication)
 */
const logout = async (req, res, next) => {
  try {
    // req.user.id should be available if a protect middleware has run
    const userId = req.user?.id; 
    if (!userId) {
      // This case should ideally not be hit if route is protected properly
      logger.warn('Logout attempt without authenticated user ID.');
      return res.status(httpStatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated for logout.' });
    }

    await authService.logoutUser(userId);

    res.clearCookie('refreshToken', config.jwt.cookieOptions);
    
    logger.info(`User logged out: ${userId}`);
    res.status(httpStatusCodes.OK).json({ message: 'Logged out successfully.' });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Request password reset (generates token and sends email - simulated)
 * @route   POST /api/auth/request-password-reset
 * @access  Public
 */
const requestPasswordReset = async (req, res, next) => {
  try {
    const { email } = req.body;
    if (!email) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Email is required.' });
    }

    const resetToken = await authService.requestPasswordReset(email);

    // In a real app, an email would be sent here with the resetToken.
    // For now, we'll just log it and send a success response.
    // The actual token is not sent back to the client for security reasons (it's in the email link).
    logger.info(`Password reset requested for email: ${email}. Token (for email link): ${resetToken}`);
    res.status(httpStatusCodes.OK).json({ message: 'If your email is registered, you will receive a password reset link shortly.' });
  } catch (error) {
    // To prevent email enumeration, we might want to always return a generic success message
    // even if the email is not found. The service throws NotFoundError if email doesn't exist.
    // For this implementation, if a NotFoundError is specifically for the user, we return the generic message.
    if (error.name === 'NotFoundError' && error.message.includes('User with this email not found')) {
        logger.warn(`Password reset attempt for non-existent email: ${req.body.email} - returning generic success`);
        return res.status(httpStatusCodes.OK).json({ message: 'If your email is registered, you will receive a password reset link shortly.' });
    }
    next(error);
  }
};

/**
 * @desc    Reset password using token
 * @route   POST /api/auth/reset-password/:token
 * @access  Public
 */
const resetPassword = async (req, res, next) => {
  try {
    const { token } = req.params;
    const { newPassword } = req.body;

    if (!token || !newPassword) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Token and new password are required.' });
    }

    await authService.resetPassword(token, newPassword);

    logger.info('Password has been reset successfully.');
    res.status(httpStatusCodes.OK).json({ message: 'Password has been reset successfully. You can now login with your new password.' });
  } catch (error) {
    // Handles invalid/expired token errors from the service
    next(error);
  }
};

/**
 * @desc    Request email verification link (simulated email sending)
 * @route   POST /api/auth/request-email-verification
 * @access  Private (requires authentication)
 */
const requestEmailVerification = async (req, res, next) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      // Should be caught by protect middleware, but as a safeguard:
      return res.status(httpStatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated.' });
    }

    const verificationToken = await authService.requestEmailVerification(userId);

    // In a real app, an email would be sent here with the verificationToken.
    logger.info(`Email verification requested for user: ${userId}. Token (for email link): ${verificationToken}`);
    res.status(httpStatusCodes.OK).json({ message: 'A new verification link has been sent to your email address (simulated).' });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Verify email using token
 * @route   GET /api/auth/verify-email/:token  (GET is common for clicking a link)
 * @access  Public
 */
const verifyEmail = async (req, res, next) => {
  try {
    const { token } = req.params;
    if (!token) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Verification token is required.' });
    }

    await authService.verifyEmail(token);

    logger.info('Email verified successfully.');
    // In a real app, you might redirect to a 'verified successfully' page or login.
    res.status(httpStatusCodes.OK).json({ message: 'Email has been verified successfully. You can now login.' });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  register,
  login,
  refreshToken,
  logout,
  requestPasswordReset,
  resetPassword,
  requestEmailVerification,
  verifyEmail,
};
</file>

<file path="controllers/chatController.js">
/**
 * Chat Controller
 * 
 * Manages chat conversations including creating, listing, and updating conversations.
 * Handles both direct messages and group chats.
 * 
 * @module controllers/chatController
 * @requires ../models/Conversation
 * @requires ../models/User
 * @requires ../models/Message
 * @requires ../services/chatService
 * @requires ../utils/logger
 * @requires ../models - Sequelize models
 * 
 * @example
 * // Example routes that use this controller:
 * GET    /api/conversations - List user's conversations
 * POST   /api/conversations - Create new conversation
 * GET    /api/conversations/:id - Get conversation details
 * PUT    /api/conversations/:id - Update conversation
 * DELETE /api/conversations/:id - Delete conversation
 */
const { sequelize, User, UserConversation, Conversation, Message } = require('../models');
const { Op } = require('sequelize'); // <--- ADD THIS LINE
const logger = require('../utils/logger');
// File will be implemented with:
// 1. Create new conversations (direct or group)
// 2. List user's conversations with pagination
// 3. Get conversation details and participants
// 4. Update conversation (add/remove participants, change title, etc.)
// 5. Delete or archive conversations

// Implementation will include proper authorization and validation

/**
 * Get or create a direct conversation between two users
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 */
const getOrCreateConversation = async (req, res) => {
  logger.info('=== START getOrCreateConversation ===');
  logger.info('Request body:', JSON.stringify(req.body, null, 2));
  logger.info('Authenticated user:', JSON.stringify(req.user, null, 2));
  
  let { participantUserIds } = req.body;
  const currentUserId = req.user?.id;
  let participantId;
  
  if (!currentUserId) {
    const errorMsg = 'Current user ID is missing';
    logger.error(errorMsg);
    return res.status(401).json({ status: 'error', message: 'Authentication required' });
  }
  
  // Extract participantId from participantUserIds array if provided
  if (participantUserIds && Array.isArray(participantUserIds) && participantUserIds.length > 0) {
    participantId = participantUserIds[0]; // Take the first one for a direct chat
    logger.info(`Extracted participantId from participantUserIds array: ${participantId}`);
  }
  
  logger.info(`Current User ID: ${currentUserId}, Requested Participant ID: ${participantId}`);
  
  // If no participant ID is provided or it's invalid, find another valid user
  if (!participantId || participantId === currentUserId) {
    logger.info('Finding a valid participant as none was provided or invalid one was supplied');
    try {
      const otherUser = await User.findOne({
        where: {
          id: { [Op.ne]: currentUserId } // Using Op from sequelize import
        },
        attributes: ['id', 'username', 'email']
      })
      if (otherUser) {
        participantId = otherUser.id;
        logger.info(`Using alternate participant: ${otherUser.username} (${otherUser.id})`);
      } else {
        // Create a chatbot user if no other users exist
        logger.info('No other users found, creating a chatbot user');
        const chatbot = await User.findOrCreate({
          where: { email: 'chatbot@example.com' },
          defaults: {
            id: sequelize.literal('UUID()'),
            username: 'chatbot',
            email: 'chatbot@example.com',
            password: 'chatbotpassword123',
            first_name: 'Chat',
            last_name: 'Bot',
            role: 'system',
            is_email_verified: true
          }
        });
        participantId = chatbot[0].id;
        logger.info(`Created and using chatbot as participant: ${participantId}`);
      }
    } catch (error) {
      logger.error('Error finding alternative participant:', error);
      return res.status(500).json({ 
        status: 'error', 
        message: 'Failed to find a valid conversation participant' 
      });
    }
  }
  
  logger.info(`Using participant ID: ${participantId}`);
  
  if (participantId === currentUserId) {
    const errorMsg = 'Cannot create a conversation with yourself';
    logger.error(errorMsg);
    return res.status(400).json({ status: 'error', message: errorMsg });
  }

  let transaction;
  
  try {
    // Start a transaction
    transaction = await sequelize.transaction();
    
    logger.info('Transaction started');
    
    try {
      // Log the users table for debugging
      const allUsers = await User.findAll({ transaction });
      logger.info('All users in database:', JSON.stringify(allUsers.map(u => ({
        id: u.id,
        email: u.email,
        username: u.username
      })), null, 2));
      
      // Debug the transaction condition
      logger.info('Transaction exists:', !!transaction);
      logger.info('Transaction finished type:', typeof transaction.finished);
      logger.info('Transaction finished value:', transaction.finished);
      logger.info('ðŸ” DEBUG - Point 1: After user debug logs');
    } catch (debugError) {
      logger.error('âŒ Error in debug logging section:', debugError);
      throw debugError;
    }
    
    // Simplified condition - we only need to check if transaction exists
    logger.info('ðŸ” DEBUG - Point 2: About to enter main transaction block');
    if (transaction) { 
      logger.info('âœ… Inside transaction block!');
      logger.info(`Looking for participant with ID: ${participantId}`);
      // Declare participant variable outside the try block so it's available in the outer scope
      let participant;
      try {
        participant = await User.findByPk(participantId, { transaction });
        logger.info('ðŸ” DEBUG - Point 3: After findByPk');
        if (!participant) {
          const errorMsg = `Participant with ID ${participantId} not found`;
          logger.error(errorMsg);
          await transaction.rollback();
          return res.status(404).json({ status: 'error', message: errorMsg });
        }
        // Successfully found participant
        logger.info(`Found participant: ${participant.username} (${participant.email})`);
      } catch (participantError) {
        logger.error('âŒ Error finding participant:', participantError);
        throw participantError;
      }
      

      logger.info('ðŸ” DEBUG - Point 4: About to create conversation');
      // Create a new conversation with explicit timestamps
      logger.info('Creating new conversation...');
      const now = new Date();
      let conversationId;
      try {
        // Generate UUID on the JavaScript side for better control
        conversationId = require('uuid').v4();
        logger.info('ðŸ” DEBUG - Point 5: Generated UUID');
      } catch (uuidError) {
        logger.error('âŒ Error generating UUID:', uuidError);
        throw uuidError;
      }
      logger.info(`Generated conversation ID: ${conversationId}`);
      
      // Create conversation with pre-generated ID
      const newConversation = await Conversation.create({
        id: conversationId,
        type: 'direct',
        name: null, // Can be null for direct conversations
        createdBy: currentUserId, // This matches the exact column name in the database (camelCase)
        created_at: now,
        updated_at: now
      }, { 
        transaction,
        // Specify exact field names with correct case sensitivity
        fields: ['id', 'type', 'name', 'createdBy', 'created_at', 'updated_at']
      });
      
      logger.info(`Created conversation with ID: ${newConversation.id}`);
      
      logger.info(`Created conversation with ID: ${newConversation.id}`);

      // Add participants to the conversation using the association method
      logger.info(`Adding participants: [${currentUserId}, ${participantId}]`);
      
      try {
        // Create UserConversation records manually with the correct structure
        // Ensure we're using the actual conversation ID string, not an object
        const conversationIdString = newConversation.id.toString();
        logger.info(`Adding user ${currentUserId} to conversation ${conversationIdString}`);
        await UserConversation.create({
          user_id: currentUserId,
          conversation_id: conversationIdString,
          created_at: new Date(),
          updated_at: new Date()
        }, { transaction });
        
        logger.info(`Adding user ${participantId} to conversation ${conversationIdString}`);
        await UserConversation.create({
          user_id: participantId,
          conversation_id: conversationIdString,
          created_at: new Date(),
          updated_at: new Date()
        }, { transaction });
        
        logger.info('Participants added successfully');
      } catch (error) {
        logger.error('Error adding participants:', error.message);
        logger.error('Error details:', JSON.stringify({
          name: error.name,
          stack: error.stack.split('\n').slice(0, 3).join('\n'),
          code: error.code,
          sql: error.sql
        }, null, 2));
        throw error; // This will be caught by the outer try-catch
      }

      try {
        // Fetch conversation with participants using proper associations
        logger.info(`Fetching conversation with ID: ${conversationId}`);
        const conversation = await Conversation.findByPk(conversationId, {
          include: [
            {
              model: User,
              as: 'participants',
              through: { attributes: [] }, // Exclude join table attributes
              attributes: ['id', 'username', 'email', 'first_name', 'last_name']
            },
            {
              model: User,
              as: 'creator',
              attributes: ['id', 'username', 'email', 'first_name', 'last_name']
            }
          ],
          transaction
        });
        
        if (!conversation) {
          logger.error(`Failed to fetch conversation with ID: ${conversationId}`);
          throw new Error('Failed to fetch the created conversation');
        }
        
        // Convert to plain object and format the response
        const conversationData = conversation.get({ plain: true });
        logger.info('Conversation fetched successfully');
        
        // Log participants for debugging
        const participants = conversationData.participants || [];
        logger.info(`Found ${participants.length} participants for conversation: ${participants.map(p => p.id).join(', ')}`);
        
        logger.info('Preparing conversationDetails for response...');
        const participantDetails = conversation.participants.map(p => ({
          id: p.id,
          username: p.username,
        }));
        logger.info('Participant details mapped.');

        const creatorDetails = conversation.creator ? {
          id: conversation.creator.id,
          username: conversation.creator.username,
        } : null;
        logger.info('Creator details mapped.');

        const conversationDetails = {
          id: conversation.id,
          type: conversation.type,
          name: conversation.name,
          createdBy: conversation.createdBy,
          createdAt: conversation.createdAt,
          updatedAt: conversation.updatedAt,
          participants: participantDetails,
          creator: creatorDetails,
        };
        logger.info('Conversation details object created:', conversationDetails);

        logger.info('Successfully prepared conversationDetails. Preparing to add welcome message and commit transaction...');
        
        // Create a welcome message from the system or participant
        logger.info('Creating welcome message for the conversation...');
        try {
          // Get message sender - using the participant or system user
          const welcomeMessageSender = participantId;
          const welcomeContent = `Hello Test, How are you feeling today?`;
          
          // Create welcome message using the Message model
          logger.info('Creating welcome message with Message model...');
          try {
            // Generate UUID for the message
            const messageId = require('uuid').v4();
            logger.info(`Generated message ID: ${messageId}`);
            
            // Create message with minimal required fields and let Sequelize handle the rest
            const welcomeMessage = await Message.create({
              id: messageId,
              content: welcomeContent,
              type: 'text',
              status: 'sent',
              senderId: welcomeMessageSender,
              conversationId: conversationId
              // Let Sequelize handle timestamps automatically
              // Let parentMessageId and metadata default to null
            }, { transaction });
            
            logger.info(`Welcome message created with ID: ${welcomeMessage.id}`);
          } catch (messageDetailedError) {
            // Log detailed error information to diagnose exactly what's wrong
            logger.error('Detailed message creation error:', messageDetailedError);
            logger.error('Error name:', messageDetailedError.name);
            logger.error('Error message:', messageDetailedError.message);
            if (messageDetailedError.parent) {
              logger.error('Parent error:', messageDetailedError.parent);
              logger.error('SQL error:', messageDetailedError.parent.sqlMessage);
              logger.error('SQL code:', messageDetailedError.parent.code);
            }
            throw messageDetailedError; // Re-throw to be caught by the outer catch
          }
        } catch (messageError) {
          // Log error but don't fail the conversation creation if message fails
          logger.error('Error creating welcome message:', messageError);
          logger.error('Continuing with conversation creation despite welcome message failure');
        }
        
        // Now commit the transaction with all changes (conversation, participants, welcome message)
        logger.info('Attempting to commit transaction...');
        await transaction.commit();
        logger.info('Transaction committed successfully');
        
        logger.info('Conversation created successfully:');
        
        // Format the response following best practices with consistent naming
        logger.info('Sending success response to client.');
        res.status(201).json({
          status: 'success',
          message: 'Conversation created successfully',
          data: {
            id: conversationDetails.id,
            type: conversationDetails.type,
            name: conversationDetails.name,
            createdBy: conversationDetails.createdBy,
            participants: conversationDetails.participants,
            creator: conversationDetails.creator,
            participantCount: conversationDetails.participants.length,
            createdAt: conversationDetails.createdAt,
            updatedAt: conversationDetails.updatedAt,
            isNew: true
          }
        });
      } catch (fetchError) {
        logger.error('--- INNER CATCH BLOCK ---');
        logger.error('Type of fetchError:', typeof fetchError);
        logger.error('fetchError raw value:', fetchError);
        try {
          logger.error('fetchError JSON.stringify (simple):', JSON.stringify(fetchError, null, 2));
          logger.error('fetchError JSON.stringify (w/ props):', JSON.stringify(fetchError, Object.getOwnPropertyNames(fetchError), 2));
        } catch (stringifyError) {
          logger.error('Failed to stringify fetchError:', stringifyError);
        }

        if (fetchError instanceof Error) {
          logger.error('fetchError is an instance of Error.');
          logger.error('Error message:', fetchError.message);
          logger.error('Error stack:', fetchError.stack);
          if (fetchError.original) {
            logger.error('Original Sequelize error:', fetchError.original);
          }
        } else {
          logger.error('fetchError is NOT a standard Error instance.');
        }
        throw fetchError; // Re-throw to be caught by the outer catch block
      }
    }
  } catch (error) {
    logger.error('--- OUTER CATCH BLOCK ---');
    logger.error('Type of error in getOrCreateConversation:', typeof error);
    logger.error('Error in getOrCreateConversation (raw):', error);
    try {
        logger.error('Error in getOrCreateConversation (JSON.stringify simple):', JSON.stringify(error, null, 2));
        logger.error('Error in getOrCreateConversation (JSON.stringify w/ props):', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
    } catch (stringifyError) {
        logger.error('Failed to stringify error in outer catch:', stringifyError);
    }

    if (error instanceof Error) {
        logger.error('Error message:', error.message);
        logger.error('Error stack:', error.stack);
        if (error.original) { // For Sequelize errors
            logger.error('Original Sequelize error:', error.original);
        }
    } else {
        logger.error('Error is not an instance of Error object.');
    }

    // Attempt to rollback transaction if it exists and hasn't been finished
    if (transaction && typeof transaction.finished === 'boolean' && !transaction.finished) {
        try {
            logger.info('Attempting to rollback transaction due to error in outer catch block...');
            await transaction.rollback();
            logger.info('Transaction rolled back successfully from outer catch.');
        } catch (rollbackError) {
            logger.error('Failed to rollback transaction from outer catch:', rollbackError);
        }
    }

    if (res.headersSent) {
        logger.error('Headers already sent, cannot send error response from outer catch.');
        return; // Exit if headers are already sent
    }

    // Handle specific Sequelize error types
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
        const errors = error.errors?.map(err => ({ field: err.path, message: err.message }));
        return res.status(400).json({
            status: 'error',
            message: 'Validation error.',
            errors: errors,
            ...(process.env.NODE_ENV === 'development' && {
                errorDetails: { name: error.name, message: error.message, stack: error.stack, original: error.original }
            })
        });
    }
    
    if (error.name === 'SequelizeForeignKeyConstraintError') {
        return res.status(400).json({
            status: 'error',
            message: 'Invalid reference. One or more users may not exist or related data is missing.',
            ...(process.env.NODE_ENV === 'development' && {
                errorDetails: { name: error.name, message: error.message, stack: error.stack, original: error.original }
            })
        });
    }

    // Default error response for other errors
    const errorMessageString = (error instanceof Error ? error.message : String(error)) || 'Failed to create or retrieve conversation due to an unexpected server error.';
    const errorResponse = {
        message: errorMessageString,
        status: 'error',
    };
    if (process.env.NODE_ENV === 'development') {
        errorResponse.errorDetails = {
            name: error instanceof Error ? error.name : typeof error,
            message: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
            original: error instanceof Error ? error.original : undefined
        };
    }
    res.status(500).json(errorResponse);
  } finally {
    logger.info('=== END getOrCreateConversation ===');
  }
};

/**
 * Get a conversation by ID
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 */
const getConversation = async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;

  try {
    const conversation = await Conversation.findOne({
      where: { id },
      include: [
        {
          model: User,
          as: 'participants',
          attributes: ['id', 'username', 'email', 'firstName', 'lastName', 'profilePicture'],
          through: { attributes: [] }
        },
        {
          model: Message,
          as: 'messages',
          limit: 50, // Limit to 50 most recent messages
          order: [['createdAt', 'DESC']],
          include: [
            {
              model: User,
              as: 'sender',
              attributes: ['id', 'username', 'profilePicture']
            }
          ]
        }
      ]
    });

    if (!conversation) {
      return res.status(404).json({ status: 'error', message: 'Conversation not found' });
    }

    // Check if the user is a participant in this conversation
    const isParticipant = conversation.participants.some(p => p.id === userId);
    if (!isParticipant) {
      return res.status(403).json({ status: 'error', message: 'Not authorized to view this conversation' });
    }

    res.status(200).json({
      status: 'success',
      data: { conversation }
    });
  } catch (error) {
    logger.error('Error in getConversation:', error);
    res.status(500).json({ status: 'error', message: 'Failed to get conversation' });
  }
};

module.exports = {
  getOrCreateConversation,
  getConversation
};
</file>

<file path="controllers/conversationController.js">
// Handles HTTP requests related to conversations and delegates to conversationService
const conversationService = require('../services/conversationService');
const logger = require('../utils/logger'); // Assuming a logger utility

/**
 * @description Create a new conversation or return an existing direct conversation.
 * @route POST /api/conversations
 * @access Private
 */
const createConversationHandler = async (req, res) => {
    // Assuming auth middleware adds user object to request, containing id
    const creatorId = req.user.id;
    const { participantUserIds, type = 'direct', name = null } = req.body;

    if (!participantUserIds || !Array.isArray(participantUserIds) || (type === 'direct' && participantUserIds.length !== 1)) {
        // For direct, participantUserIds should contain the *other* user's ID.
        // The service layer will combine creatorId and this single participantId for a direct chat.
        // Or, if participantUserIds is meant to be an array of all participants *excluding* creator, adjust accordingly.
        // For this implementation, let's assume participantUserIds = [otherUserId] for direct chat.
        let message = 'ParticipantUserIds array is required.';
        if (type === 'direct' && (!participantUserIds || participantUserIds.length !== 1)) {
            message = 'For direct conversations, participantUserIds must be an array containing exactly one other user ID.';
        }
        return res.status(400).json({ message });
    }
    
    // The service expects a list of *all* participants for a direct chat (creator + other)
    // So, if client sends only the other user, we add the creatorId here.
    // If client sends all participants already, ensure creator is one of them (service also does this).
    let allParticipantIdsForService = [];
    if (type === 'direct') {
        allParticipantIdsForService = [creatorId, participantUserIds[0]];
    } else {
        allParticipantIdsForService = Array.from(new Set([creatorId, ...participantUserIds]));
    }

    try {
        const conversation = await conversationService.createConversation(creatorId, allParticipantIdsForService, type, name);
        // Check if it's a newly created conversation or an existing one returned
        // Sequelize's isNewRecord is true only if it was just created. If an existing direct chat was found, it's false.
        const statusCode = conversation.isNewRecord === false ? 200 : 201; 
        res.status(statusCode).json(conversation);
    } catch (error) {
        logger.error('Error in createConversationHandler:', error);
        if (error.message.includes('must have exactly two participants') || error.message.includes('must have a name')) {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to create conversation', error: error.message });
    }
};

/**
 * @description Get all conversations for the logged-in user.
 * @route GET /api/conversations
 * @access Private
 */
const getUserConversationsHandler = async (req, res) => {
    const userId = req.user.id;
    const { page = 1, limit = 20 } = req.query;

    try {
        const result = await conversationService.getUserConversations(userId, { 
            page: parseInt(page, 10),
            limit: parseInt(limit, 10) 
        });
        res.status(200).json(result);
    } catch (error) {
        logger.error('Error in getUserConversationsHandler:', error);
        res.status(500).json({ message: 'Failed to retrieve conversations', error: error.message });
    }
};

/**
 * @description Get a specific conversation by ID.
 * @route GET /api/conversations/:id
 * @access Private (User must be a participant)
 */
const getConversationByIdHandler = async (req, res) => {
    const userId = req.user.id;
    const { id: conversationId } = req.params;

    try {
        const conversation = await conversationService.getConversationById(conversationId, userId);
        if (!conversation) {
            return res.status(404).json({ message: 'Conversation not found.' });
        }
        res.status(200).json(conversation);
    } catch (error) {
        logger.error(`Error in getConversationByIdHandler for conversation ${conversationId}:`, error);
        if (error.status === 403) {
            return res.status(403).json({ message: error.message }); // Access denied message from service
        }
        if (error.message.includes('not found')) { // Catch generic not found if not handled by service's null return
             return res.status(404).json({ message: 'Conversation not found.' });
        }
        res.status(500).json({ message: 'Failed to retrieve conversation', error: error.message });
    }
};

module.exports = {
    createConversationHandler,
    getUserConversationsHandler,
    getConversationByIdHandler,
};
</file>

<file path="controllers/messageController.js">
const messageService = require('../services/messageService');
const logger = require('../utils/logger');
const httpStatusCodes = require('http-status-codes');

/**
 * @description Send a new message in a conversation and generate AI response.
 * @route POST /api/conversations/:conversationId/messages
 * @access Private
 */
const sendMessageHandler = async (req, res, next) => {
    try {
        const senderId = req.user.id;
        const { conversationId } = req.params;
        const { content, type, metadata } = req.body;

        if (!content) {
            return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Message content is required.' });
        }

        logger.info(`MESSAGE CONTROLLER: Processing message from user ${senderId} in conversation ${conversationId}`);
        
        // Get both user message and AI response
        const { userMessage, aiMessage } = await messageService.sendMessage(
            senderId,
            conversationId,
            content,
            type,
            metadata
        );

        // Get Socket.IO instance
        const io = req.app.get('io');
        
        // Emit user message via WebSocket
        if (io && userMessage) {
            logger.info(`MESSAGE CONTROLLER: Emitting user message ${userMessage.id} via WebSocket`);
            io.to(conversationId.toString()).emit('newMessage', userMessage);
        }

        // Emit AI message via WebSocket (with slight delay to simulate thinking)
        if (io && aiMessage) {
            logger.info(`MESSAGE CONTROLLER: Emitting AI message ${aiMessage.id} via WebSocket`);
            // Optional delay to simulate AI thinking
            setTimeout(() => {
                io.to(conversationId.toString()).emit('newMessage', aiMessage);
            }, 500); // 500ms delay
        }

        // Respond to HTTP request with the user's message
        res.status(httpStatusCodes.CREATED).json(userMessage);
    } catch (error) {
        logger.error('Error in sendMessageHandler:', error);
        // Pass to global error handler or handle specific errors
        if (error.status) { // If error has a status (like from service layer)
             return res.status(error.status).json({ message: error.message });
        }
        next(error); // For generic error handling middleware
    }
};

/**
 * @description Get message history for a conversation.
 * @route GET /api/conversations/:conversationId/messages
 * @access Private
 */
const getMessagesHandler = async (req, res, next) => {
    logger.info(`MESSAGE CONTROLLER: Entered getMessagesHandler for convId: ${req.params.conversationId}`); // Added logging
    try {
        const userId = req.user.id;
        const { conversationId } = req.params;
        const { page, limit, beforeMessageId, afterMessageId } = req.query;

        const messagesResult = await messageService.getMessages(
            conversationId,
            userId,
            {
                page: page ? parseInt(page, 10) : undefined,
                limit: limit ? parseInt(limit, 10) : undefined,
                beforeMessageId,
                afterMessageId
            }
        );
        res.status(httpStatusCodes.OK).json(messagesResult);
    } catch (error) {
        logger.error('Error in getMessagesHandler:', error);
        if (error.status) {
             return res.status(error.status).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * @description Mark messages in a conversation as read.
 * @route POST /api/conversations/:conversationId/messages/read
 * @access Private
 */
const markMessagesAsReadHandler = async (req, res, next) => {
    try {
        const userId = req.user.id;
        const { conversationId } = req.params;
        const { lastReadMessageId } = req.body; // Or however you identify what's been read

        // This service function is a placeholder in your code, you'll need to implement its logic
        const result = await messageService.markMessagesAsRead(conversationId, userId, lastReadMessageId);
        
        // const io = req.app.get('io');
        // if (io) {
        //    io.to(conversationId.toString()).emit('messagesRead', { conversationId, readerId: userId, lastReadMessageId });
        // }

        res.status(httpStatusCodes.OK).json(result);
    } catch (error) {
        logger.error('Error in markMessagesAsReadHandler:', error);
         if (error.status) {
             return res.status(error.status).json({ message: error.message });
        }
        next(error);
    }
};


module.exports = {
    sendMessageHandler,
    getMessagesHandler,
    markMessagesAsReadHandler,
    // Add other handlers as you implement them (update, delete, etc.)
};
</file>

<file path="controllers/participantController.js">
// Handles HTTP requests for participant management and delegates to participantService
const participantService = require('../services/participantService');
const logger = require('../utils/logger');

/**
 * @description Add participants to a group conversation.
 * @route POST /api/conversations/:conversationId/participants
 * @access Private (Typically, only creator or authorized users)
 */
const addParticipantsHandler = async (req, res) => {
    const requesterId = req.user.id;
    const { conversationId } = req.params;
    const { userIdsToAdd } = req.body;

    if (!userIdsToAdd || !Array.isArray(userIdsToAdd) || userIdsToAdd.length === 0) {
        return res.status(400).json({ message: 'userIdsToAdd must be a non-empty array.' });
    }

    try {
        const updatedConversation = await participantService.addParticipants(requesterId, conversationId, userIdsToAdd);
        // TODO: Emit WebSocket event to notify existing participants and newly added ones.
        // Example: req.io.to(conversationId).emit('participantsAdded', { conversationId, addedUserIds: userIdsToAdd, updatedConversation });
        // Notify each newly added user individually as well so their client can join the room/update UI
        // userIdsToAdd.forEach(uid => req.io.to(uid).emit('addedToConversation', updatedConversation));
        res.status(200).json(updatedConversation);
    } catch (error) {
        logger.error(`Error in addParticipantsHandler for conversation ${conversationId}:`, error);
        if (error.status === 403) {
            return res.status(403).json({ message: error.message });
        }
        if (error.message.includes('not found') || error.message.includes('do not exist')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message.includes('only be added to group') || error.message.includes('already in conversation')) {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to add participants', error: error.message });
    }
};

/**
 * @description Remove a participant from a group conversation.
 * @route DELETE /api/conversations/:conversationId/participants/:userId
 * @access Private (Creator can remove others; user can remove themselves)
 */
const removeParticipantHandler = async (req, res) => {
    const requesterId = req.user.id;
    const { conversationId, userId: userIdToRemove } = req.params;

    if (!userIdToRemove) {
        return res.status(400).json({ message: 'User ID to remove is required in the path.' });
    }

    try {
        const result = await participantService.removeParticipant(requesterId, conversationId, userIdToRemove);
        // TODO: Emit WebSocket event to notify remaining participants and the removed user.
        // Example: req.io.to(conversationId).emit('participantRemoved', { conversationId, removedUserId: userIdToRemove, updatedConversation: result.conversation });
        // Notify the removed user so their client can leave the room/update UI
        // req.io.to(userIdToRemove).emit('removedFromConversation', { conversationId });
        res.status(200).json(result); // result contains { message, conversation }
    } catch (error) {
        logger.error(`Error in removeParticipantHandler for conversation ${conversationId}, user ${userIdToRemove}:`, error);
        if (error.status === 403) {
            return res.status(403).json({ message: error.message });
        }
        if (error.message.includes('not found') || error.message.includes('not a participant')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message.includes('only be removed from group') || error.message.includes('Cannot remove the last participant')) {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to remove participant', error: error.message });
    }
};

module.exports = {
    addParticipantsHandler,
    removeParticipantHandler,
};
</file>

<file path="controllers/userController.js">
/**
 * User Controller
 * 
 * Handles user-related operations such as profile management and user data retrieval.
 * Provides endpoints for CRUD operations on user accounts.
 * 
 * @module controllers/userController
 * @requires jsonwebtoken
 * @requires ../models/User
 * @requires ../utils/logger
 * @requires ../middleware/auth
 * 
 * @example
 * // Example routes that use this controller:
 * GET    /api/users/me - Get current user profile
 * PUT    /api/users/me - Update current user
 * GET    /api/users/:userId - Get user by ID (admin only)
 * DELETE /api/users/:userId - Delete user (admin only)
 */

// File will be implemented with:
// 1. Get current user profile
// 2. Update user profile
// 3. Change password
// 4. Admin-only user management endpoints
// 5. User search and filtering

// Implementation will include proper authorization checks and validation
</file>

<file path="docs/api-specification.yml">
# OpenAPI/Swagger specification for the chat API
</file>

<file path="middleware/auth.js">
/**
 * Authentication Middleware (Development Version)
 * 
 * For development purposes only - automatically authenticates as a test user
 * In production, use proper JWT authentication
 */

const { User } = require('../models');
const logger = require('../utils/logger');
const { UnauthorizedError } = require('../utils/errors');

/**
 * Middleware that automatically authenticates as the test user
 * Skips JWT verification for development purposes
 */
const authenticateJWT_DevMode = async (req, res, next) => {
  logger.info('DEV_AUTH_MIDDLEWARE: Bypassing JWT, authenticating as test@example.com');
  try {
    const testUser = await User.findOne({
      where: { email: 'test@example.com' },
      attributes: ['id', 'email', 'username', 'role'] // Fetch necessary fields
    });

    if (!testUser) {
      logger.error('DEV_AUTH_MIDDLEWARE: Test user (test@example.com) not found!');
      return res.status(500).json({ message: 'Developer setup error: Test user not found.' });
    }
    req.user = testUser.get({ plain: true });
    logger.info(`DEV_AUTH_MIDDLEWARE: Authenticated as ${req.user.username}`);
    next();
  } catch (error) {
    logger.error('DEV_AUTH_MIDDLEWARE: Error fetching test user:', error);
    next(error);
  }
};

/**
 * Middleware to check if user has required roles
 * @param {...string} roles - Roles that are allowed to access the route
 * @returns {Function} Middleware function
 */
const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return next(new UnauthorizedError('Authentication required'));
    }
    
    if (roles.length && !roles.includes(req.user.role)) {
      return next(new UnauthorizedError('Insufficient permissions'));
    }
    
    next();
  };
};

module.exports = {
  authenticateJWT: authenticateJWT_DevMode, // Exporting the dev mode version
  authorizeRoles
};
</file>

<file path="middleware/authMiddleware.js">
// backend/middleware/authMiddleware.js

const jwt = require('jsonwebtoken');
const { User } = require('../models'); // Adjust path if necessary
const config = require('../config/config'); // Ensure this path is correct and loads your jwt.secret
const { UnauthorizedError } = require('../utils/errors');
const logger = require('../utils/logger');

const authMiddleware = async (req, res, next) => {
    let token;
    // Log the entire authorization header
    logger.info(`AUTH_MIDDLEWARE: Authorization Header: [${req.headers.authorization}]`);

    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
        try {
            token = req.headers.authorization.split(' ')[1];

            // Check for common invalid token string values
            if (!token || token === 'null' || token === 'undefined' || token.trim() === '') {
                logger.warn(`AUTH_MIDDLEWARE: Invalid token string extracted: [${token}]`);
                return next(new UnauthorizedError('Not authorized, malformed token.'));
            }

            logger.info(`AUTH_MIDDLEWARE: Token to verify: [${token}]`);

            const decoded = jwt.verify(token, config.jwt.secret); // Error happens here if token is bad
            logger.info(`AUTH_MIDDLEWARE: Token decoded successfully for user ID: ${decoded.id}`);

            const user = await User.findByPk(decoded.id, {
                attributes: { exclude: ['password', 'passwordResetToken', 'passwordResetTokenExpires', 'emailVerificationToken', 'emailVerificationTokenExpires', 'refreshTokenHash'] }
            });

            if (!user) {
                logger.warn(`AUTH_MIDDLEWARE: User not found for token ID: ${decoded.id}`);
                return next(new UnauthorizedError('Not authorized, user not found.'));
            }

            req.user = user.get({ plain: true }); // Attach plain user object
            logger.info(`AUTH_MIDDLEWARE: User ${req.user.username} authenticated.`);
            next();
        } catch (error) {
            logger.error('AUTH_MIDDLEWARE: JWT Verification or User Fetch Error:', {
                message: error.message,
                name: error.name,
                tokenProvided: token, // Log the token that caused the error
            });
            if (error.name === 'JsonWebTokenError') {
                return next(new UnauthorizedError('Not authorized, token failed verification (malformed or invalid signature).'));
            } else if (error.name === 'TokenExpiredError') {
                return next(new UnauthorizedError('Not authorized, token expired.'));
            }
            return next(new UnauthorizedError('Not authorized, an unexpected error occurred with token.'));
        }
    } else {
        logger.warn('AUTH_MIDDLEWARE: No Bearer token in authorization header.');
        return next(new UnauthorizedError('Not authorized, no token in header.'));
    }
};

module.exports = authMiddleware;
</file>

<file path="middleware/authValidators.js">
const Joi = require('joi');
const httpStatusCodes = require('http-status-codes');
const { BadRequestError } = require('../utils/errors'); // Path adjusted to .. from middleware directory

// Middleware to handle Joi validation
const validate = (schema, property = 'body') => {
  return (req, res, next) => {
    const dataToValidate = req[property];
    const { error, value } = schema.validate(dataToValidate, { abortEarly: false });

    if (error) {
      const errorMessage = error.details.map((detail) => detail.message).join(', ');
      return next(new BadRequestError(errorMessage));
    }
    req[property] = value; 
    next();
  };
};

// --- Individual Validation Schemas ---

const registrationSchema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(8).required()
    .messages({
      'string.min': 'Password must be at least 8 characters long.',
    }),
  first_name: Joi.string().min(1).max(50).optional().allow('').default(''),
  last_name: Joi.string().min(1).max(50).optional().allow('').default(''),
});

const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required(),
});

const emailSchema = Joi.object({
  email: Joi.string().email().required(),
});

const passwordResetSchemaBody = Joi.object({
  newPassword: Joi.string().min(8).required()
    .messages({
      'string.min': 'New password must be at least 8 characters long.',
    }),
});
const passwordResetSchemaParams = Joi.object({
    token: Joi.string().hex().length(64).required(), 
});

const tokenSchemaParams = Joi.object({
  token: Joi.string().hex().length(64).required(), 
});


module.exports = {
  validateRegistration: validate(registrationSchema, 'body'),
  validateLogin: validate(loginSchema, 'body'),
  validateEmail: validate(emailSchema, 'body'), 
  validatePasswordReset: [
    validate(passwordResetSchemaParams, 'params'), 
    validate(passwordResetSchemaBody, 'body')
  ],
  validateToken: validate(tokenSchemaParams, 'params'), 
};
</file>

<file path="middleware/errorHandler.js">
/**
 * Error Handling Middleware
 * 
 * Centralized error handling for the application.
 * Catches and processes errors, returning appropriate HTTP responses.
 * 
 * @module middleware/errorHandler
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // In your Express app:
 * const { errorHandler } = require('./middleware/errorHandler');
 * 
 * // After all routes:
 * app.use(errorHandler);
 */

// File will be implemented with:
// 1. Error classification (validation, authentication, not found, etc.)
// 2. Error logging with appropriate context
// 3. User-friendly error responses in development/production
// 4. Standardized error format
// 5. Handling of unhandled promise rejections

// Implementation will include proper error serialization and status codes
</file>

<file path="middleware/validation.js">
/**
 * Validation Middleware
 * 
 * Middleware for validating request payloads using Joi schemas.
 * Ensures data integrity before processing requests.
 * 
 * @module middleware/validation
 * @requires joi
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Define a validation schema
 * const userSchema = {
 *   body: Joi.object({
 *     username: Joi.string().required(),
 *     email: Joi.string().email().required(),
 *     password: Joi.string().min(8).required()
 *   })
 * };
 * 
 * // Apply to route
 * router.post('/users', validate(userSchema), userController.createUser);
 */

// File will be implemented with:
// 1. Request validation (body, params, query)
// 2. Custom validation rules
// 3. Sanitization of input data
// 4. Detailed validation error messages
// 5. Support for file uploads validation

// Implementation will include proper error formatting
</file>

<file path="middleware/validators/conversationValidator.js">
// Request validation for conversation endpoints

// Handles request validation for conversation endpoints
const { body, param, validationResult } = require('express-validator');

const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};

const createConversationRules = () => [
    body('type')
        .optional()
        .isIn(['direct', 'group'])
        .withMessage("Type must be 'direct' or 'group'."),
    body('name')
        .if(body('type').equals('group'))
        .notEmpty()
        .withMessage('Name is required for group conversations.')
        .isString()
        .withMessage('Name must be a string.')
        .optional({ checkFalsy: true }), // Allow it to be absent if type is not 'group'
    body('participantUserIds')
        .isArray({ min: 1 })
        .withMessage('participantUserIds must be an array with at least one user ID.')
        .custom((value, { req }) => {
            if (req.body.type === 'direct' || (!req.body.type && value.length > 0)) { // Default to direct if type not specified
                if (value.length !== 1) {
                    throw new Error('For direct conversations, participantUserIds must contain exactly one user ID.');
                }
            }
            // For group chats, participantUserIds can have multiple IDs (min 1 checked by isArray)
            return true;
        }),
    body('participantUserIds.*') // Validate each element in the array
        .isString() // Or isUUID() if your IDs are UUIDs
        .withMessage('Each participant user ID must be a string (or a valid ID format).')
];

const getConversationByIdRules = () => [
    param('id')
        .notEmpty()
        .withMessage('Conversation ID cannot be empty.')
        .isString() // or .isUUID() if applicable
        .withMessage('Conversation ID must be a valid string (or UUID).')
];

module.exports = {
    validateRequest,
    createConversationRules,
    getConversationByIdRules,
};
</file>

<file path="middleware/validators/messageValidator.js">
// Handles request validation for message endpoints
const { body, param, query, validationResult } = require('express-validator');

const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};

const sendMessageRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    body('content')
        .notEmpty().withMessage('Message content cannot be empty.')
        .isString().withMessage('Content must be a string.'),
    body('type')
        .optional()
        .isString().withMessage('Message type must be a string.')
        .isIn(['text', 'image', 'file', 'audio', 'video', 'system'])
        .withMessage("Invalid message type. Allowed types: 'text', 'image', 'file', 'audio', 'video', 'system'."),
    body('metadata')
        .optional()
        .isObject().withMessage('Metadata must be an object.')
];

const getMessagesRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    query('page')
        .optional()
        .isInt({ min: 1 }).withMessage('Page must be a positive integer.')
        .toInt(),
    query('limit')
        .optional()
        .isInt({ min: 1, max: 100 }).withMessage('Limit must be an integer between 1 and 100.')
        .toInt(),
    query('beforeMessageId')
        .optional()
        .isString().withMessage('beforeMessageId must be a string (or valid ID format).') // Or .isUUID()
        .custom((value, { req }) => {
            if (value && (req.query.page || req.query.afterMessageId)) {
                throw new Error('beforeMessageId cannot be used with page-based pagination or afterMessageId.');
            }
            return true;
        }),
    query('afterMessageId')
        .optional()
        .isString().withMessage('afterMessageId must be a string (or valid ID format).') // Or .isUUID()
        .custom((value, { req }) => {
            if (value && (req.query.page || req.query.beforeMessageId)) {
                throw new Error('afterMessageId cannot be used with page-based pagination or beforeMessageId.');
            }
            return true;
        })
];

const markMessagesAsReadRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    body('lastReadMessageId')
        .optional({ checkFalsy: true }) // Allows null or empty string to be considered 'absent'
        .isString().withMessage('lastReadMessageId must be a string (or valid ID format) if provided.') // Or .isUUID()
];

module.exports = {
    validateRequest,
    sendMessageRules,
    getMessagesRules,
    markMessagesAsReadRules,
};
</file>

<file path="middleware/validators/participantValidator.js">
// Handles request validation for participant management endpoints
const { body, param, validationResult } = require('express-validator');

const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};

const addParticipantsRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    body('userIdsToAdd')
        .isArray({ min: 1 }).withMessage('userIdsToAdd must be an array with at least one user ID.')
        .custom((value) => {
            if (!value.every(id => typeof id === 'string')) { // Or check for UUID format
                throw new Error('All user IDs in userIdsToAdd must be strings (or valid ID format).');
            }
            return true;
        })
];

const removeParticipantRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    param('userId')
        .notEmpty().withMessage('User ID to remove is required.')
        .isString().withMessage('User ID to remove must be a string (or valid ID format).') // Or .isUUID()
];

module.exports = {
    validateRequest,
    addParticipantsRules,
    removeParticipantRules,
};
</file>

<file path="middleware/websocket/auth.js">
/**
 * WebSocket authentication middleware
 * Verifies JWT tokens for WebSocket connections
 * Attaches user information to socket for authorization
 */
const jwt = require('jsonwebtoken');
const { User } = require('../../models'); 
const config = require('../../config/config'); 
const logger = require('../../utils/logger'); 

const socketAuthMiddleware = async (socket, next) => {
    // Token can be sent in handshake query or auth headers (e.g., socket.handshake.auth.token)
    const token = socket.handshake.auth?.token || socket.handshake.query?.token;

    if (!token) {
        logger.warn('WebSocket connection attempt without token.');
        // Create a custom error object that Socket.IO can send to the client
        const err = new Error('Authentication error: Token not provided');
        err.data = { content: 'Token not provided for WebSocket connection.' }; // additional details for client
        return next(err);
    }

    try {
        // Ensure you are using the correct secret key from config.js
        const jwtSecret = config.jwt.secret;
        logger.info(`WS Auth: JWT Secret Used: [${jwtSecret ? '***SECRET EXISTS***' : 'UNDEFINED'}]`);
        
        if (!jwtSecret) {
            logger.error('WS Auth: config.jwt.secret is indeed falsy.');
            const err = new Error('Authentication error: Server configuration issue');
            err.data = { content: 'Server configuration error for JWT.' };
            return next(err);
        }
        const decoded = jwt.verify(token, jwtSecret);
        
        // Assuming your JWT payload has an 'id' field for the user's primary key
        const user = await User.findByPk(decoded.id);

        if (!user) {
            logger.warn(`WebSocket authentication failed: User not found for ID ${decoded.id}`);
            const err = new Error('Authentication error: User not found');
            err.data = { content: 'User associated with token not found.' };
            return next(err);
        }

        // Attach user to the socket object for use in event handlers
        socket.user = {
            id: user.id,
            username: user.username,
            email: user.email
            // Add other relevant non-sensitive user fields if needed
        };
        logger.info(`WebSocket authenticated for user: ${socket.user.username} (ID: ${socket.user.id}) (Socket ID: ${socket.id})`);
        next(); // Proceed to the next middleware or connection handler
    } catch (error) {
        logger.error('WebSocket authentication error:', error.message);
        let authError = new Error('Authentication error: Could not verify token');
        if (error.name === 'TokenExpiredError') {
            authError = new Error('Authentication error: Token expired');
            authError.data = { content: 'Access token has expired.' };
        } else if (error.name === 'JsonWebTokenError') {
            authError = new Error('Authentication error: Invalid token');
            authError.data = { content: 'Access token is invalid.' };
        }
        return next(authError);
    }
};

module.exports = socketAuthMiddleware;
</file>

<file path="middleware/websocket/errorHandler.js">
/**
 * WebSocket error handling middleware
 * Centralizes error handling for WebSocket events
 * Logs errors and sends appropriate error responses to clients
 */
</file>

<file path="migrations/20250516003134-create-users.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('users', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      username: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true,
      },
      email: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true,
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      first_name: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      last_name: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('users');
  }
};
</file>

<file path="migrations/20250516003411-create-conversations.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('conversations', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('conversations');
  }
};
</file>

<file path="migrations/20250516003459-create-messages.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('messages', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false,
      },
      sender_id: {
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      conversation_id: {
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'conversations',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      is_read: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false,
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('messages');
  }
};
</file>

<file path="migrations/20250516003709-create-user-conversations-join-table.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('UserConversations', {
      user_id: {
        type: Sequelize.UUID,
        allowNull: false,
        primaryKey: true,
        references: {
          model: 'users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      conversation_id: {
        type: Sequelize.UUID,
        allowNull: false,
        primaryKey: true,
        references: {
          model: 'conversations',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('UserConversations');
  }
};
</file>

<file path="migrations/20250516003800-create-user-conversation.js">
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('UserConversations', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      user_id: {
        type: Sequelize.UUID,
        allowNull: false,
        field: 'user_id',
        references: {
          model: 'Users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      conversation_id: {
        type: Sequelize.UUID,
        allowNull: false,
        field: 'conversation_id',
        references: {
          model: 'Conversations',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        field: 'created_at',
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        field: 'updated_at',
      },
    });

    // Add composite unique index using the correct column names
    await queryInterface.addIndex('UserConversations', ['user_id', 'conversation_id'], {
      unique: true,
      name: 'user_conversation_unique'
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('UserConversations');
  }
};
</file>

<file path="migrations/20250516052212-add-auth-fields-to-user.js">
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('users', 'passwordResetToken', {
      type: Sequelize.STRING,
      allowNull: true
    });

    await queryInterface.addColumn('users', 'passwordResetExpires', {
      type: Sequelize.DATE,
      allowNull: true
    });

    await queryInterface.addColumn('users', 'emailVerificationToken', {
      type: Sequelize.STRING,
      allowNull: true
    });

    await queryInterface.addColumn('users', 'emailVerificationTokenExpires', {
      type: Sequelize.DATE,
      allowNull: true
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('users', 'passwordResetToken');
    await queryInterface.removeColumn('users', 'passwordResetExpires');
    await queryInterface.removeColumn('users', 'emailVerificationToken');
    await queryInterface.removeColumn('users', 'emailVerificationTokenExpires');
  }
};
</file>

<file path="migrations/20250516090000-add-missing-user-columns.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('users', 'role', {
      type: Sequelize.ENUM('user', 'admin'),
      allowNull: false,
      defaultValue: 'user',
    });

    await queryInterface.addColumn('users', 'is_email_verified', {
      type: Sequelize.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    });

    await queryInterface.addColumn('users', 'last_login', {
      type: Sequelize.DATE,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'refresh_token', {
      type: Sequelize.STRING,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'password_reset_token', {
      type: Sequelize.STRING,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'password_reset_expires', {
      type: Sequelize.DATE,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'email_verification_token', {
      type: Sequelize.STRING,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'email_verification_token_expires', {
      type: Sequelize.DATE,
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('users', 'role');
    await queryInterface.removeColumn('users', 'is_email_verified');
    await queryInterface.removeColumn('users', 'last_login');
    await queryInterface.removeColumn('users', 'refresh_token');
    await queryInterface.removeColumn('users', 'password_reset_token');
    await queryInterface.removeColumn('users', 'password_reset_expires');
    await queryInterface.removeColumn('users', 'email_verification_token');
    await queryInterface.removeColumn('users', 'email_verification_token_expires');
  }
};
</file>

<file path="migrations/20250516090001-update-conversations-table.js">
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Add the 'type' column
    await queryInterface.addColumn('conversations', 'type', {
      type: Sequelize.ENUM('direct', 'group'),
      defaultValue: 'direct',
      allowNull: false
    });

    // Add the 'name' column
    await queryInterface.addColumn('conversations', 'name', {
      type: Sequelize.STRING,
      allowNull: true
    });

    // Add the 'createdBy' column
    await queryInterface.addColumn('conversations', 'createdBy', {
      type: Sequelize.UUID,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE'
    });

    // Add index for better performance
    await queryInterface.addIndex('conversations', ['createdBy']);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('conversations', 'type');
    await queryInterface.removeColumn('conversations', 'name');
    await queryInterface.removeIndex('conversations', ['createdBy']);
    await queryInterface.removeColumn('conversations', 'createdBy');
  }
};
</file>

<file path="migrations/20250516234001-add-parent-message-id-to-messages.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('messages', 'parent_message_id', {
      type: Sequelize.UUID,
      allowNull: true,
      references: {
        model: 'messages', // Self-referencing
        key: 'id',
      },
      onUpdate: 'CASCADE',
      onDelete: 'SET NULL', // Or 'CASCADE' if you want replies deleted with parent
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('messages', 'parent_message_id');
  }
};
</file>

<file path="migrations/20250516234933-add-metadata-to-messages.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('messages', 'metadata', { // Ensure table name 'messages' is correct
      type: Sequelize.JSON, // Use Sequelize.JSON for MySQL compatibility
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('messages', 'metadata');
  }
};
</file>

<file path="models/Conversation.js">
/**
 * Conversation Model
 * 
 * Defines the Conversation model and its relationships.
 * Represents a chat conversation between users.
 * 
 * @module models/Conversation
 * @requires sequelize
 * @requires ../models/User
 * @requires ../models/Message
 * @requires ../utils/logger
 * 
 * @example
 * // Example usage:
 * const Conversation = require('../models/Conversation');
 * const conversation = await Conversation.create({ type: 'direct' });
 * const conversations = await Conversation.findAllForUser(userId);
 */

const { DataTypes, Model } = require('sequelize');

module.exports = (sequelize) => {
  class Conversation extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // Messages in this conversation
      Conversation.hasMany(models.Message, { 
        foreignKey: 'conversationId', 
        as: 'messages' 
      });
      
      // Participants in this conversation
      Conversation.belongsToMany(models.User, { 
        through: models.UserConversation, 
        foreignKey: 'conversationId', 
        otherKey: 'userId', 
        as: 'participants'
      });
      
      // User who created this conversation
      Conversation.belongsTo(models.User, { 
        foreignKey: 'createdBy', 
        as: 'creator' 
      });
      
      // UserConversation entries for this conversation
      Conversation.hasMany(models.UserConversation, {
        foreignKey: 'conversationId',
        as: 'userConversations' // Changed to match the alias used in conversationService.js
      });
    }
  }

  Conversation.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    type: {
      type: DataTypes.ENUM('direct', 'group'),
      allowNull: false,
      defaultValue: 'direct',
    },
    name: {
      type: DataTypes.STRING,
      allowNull: true,
      // This field is called 'name' in the database, not 'title'
    },
    // Critical field: The database column is called 'createdBy' (camelCase)
    createdBy: {
      type: DataTypes.UUID,
      allowNull: false,
      field: 'createdBy', // Explicitly map to the camelCase column name
      references: {
        model: 'users',
        key: 'id'
      }
    },
    // Standard timestamps with proper mappings
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'created_at',
      defaultValue: DataTypes.NOW
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'updated_at',
      defaultValue: DataTypes.NOW
    }
  }, {
    sequelize,
    modelName: 'Conversation',
    tableName: 'conversations',
    timestamps: true,
    underscored: false, // Do NOT use snake_case for regular fields like createdBy
    createdAt: 'created_at', // But manually map timestamp fields
    updatedAt: 'updated_at',
    hooks: {
      beforeCreate: (conversation) => {
        conversation.created_at = new Date();
        conversation.updated_at = new Date();
      },
      beforeUpdate: (conversation) => {
        conversation.updated_at = new Date();
      }
    }
  });

  // Add instance method to set participants
  Conversation.prototype.setParticipants = async function(userIds, options = {}) {
    const { transaction } = options;
    const UserConversation = this.sequelize.models.UserConversation;
    
    // Remove all existing participants
    await UserConversation.destroy({
      where: { conversationId: this.id },
      transaction
    });
    
    // Add new participants
    if (userIds && userIds.length > 0) {
      const participantRecords = userIds.map(userId => ({
        userId,
        conversationId: this.id,
        createdAt: new Date(),
        updatedAt: new Date()
      }));
      
      await UserConversation.bulkCreate(participantRecords, { transaction });
    }
    
    // Reload the conversation with participants
    return this.reload({
      include: [
        {
          model: this.sequelize.models.User,
          as: 'participants',
          through: { attributes: [] } // Exclude join table attributes
        }
      ],
      transaction
    });
  };

  return Conversation;
};
</file>

<file path="models/index.js">
'use strict';

/**
 * Models Index
 * 
 * This file initializes all Sequelize models and their relationships.
 * It automatically imports all model files from this directory and sets up associations.
 * 
 * @module models/index
 * @requires fs
 * @requires path
 * @requires sequelize
 * @requires process
 * @requires ../config/config
 * 
 * @example
 * // Example usage:
 * const { User, Conversation, Message } = require('./models');
 * // Now you can use the models with their associations set up
 */

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];

// Initialize an empty database object to hold all models
const db = {};

// Create Sequelize instance with configuration
let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(
    config.database,
    config.username,
    config.password,
    config
  );
}

// Import all model files from this directory
fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 && // Skip hidden files
      file !== basename && // Skip this file
      file.slice(-3) === '.js' && // Only .js files
      file.indexOf('.test.js') === -1 // Skip test files
    );
  })
  .forEach(file => {
    // Import each model file
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model; // Add model to the db object
  });

// Set up model associations if they exist
Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

// Add Sequelize instance and class to the db object
db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
</file>

<file path="models/Message.js">
/**
 * Message Model
 * 
 * Defines the Message model and its relationships.
 * Represents a single message in a conversation.
 * 
 * @module models/Message
 * @requires sequelize
 * @requires ../models/User
 * @requires ../models/Conversation
 * @requires ../utils/logger
 * 
 * @example
 * // Example usage:
 * const Message = require('../models/Message');
 * const message = await Message.create({ content, senderId, conversationId });
 * const messages = await Message.findByConversation(conversationId);
 */

const { DataTypes, Model } = require('sequelize');

module.exports = (sequelize) => {
  class Message extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Message.belongsTo(models.User, { foreignKey: 'senderId', as: 'sender' });
      Message.belongsTo(models.Conversation, { foreignKey: 'conversationId', as: 'conversation' });
      Message.belongsTo(models.Message, { foreignKey: 'parentMessageId', as: 'parentMessage' });
      Message.hasMany(models.Message, { foreignKey: 'parentMessageId', as: 'replies' });
    }
  }

  Message.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false,
      validate: {
        notEmpty: { msg: 'Message content cannot be empty.' },
      },
    },
    type: {
      type: DataTypes.ENUM('text', 'image', 'file', 'audio', 'video'), 
      defaultValue: 'text',
      allowNull: false,
    },
    status: {
      type: DataTypes.ENUM('sending', 'sent', 'delivered', 'read', 'failed'), 
      defaultValue: 'sending',
      allowNull: false,
    },
    senderId: {
      type: DataTypes.UUID,
      allowNull: false,
      field: 'sender_id',
      references: {
        model: 'users', 
        key: 'id'
      }
    },
    conversationId: {
      type: DataTypes.UUID,
      allowNull: false,
      field: 'conversation_id',
      references: {
        model: 'conversations', 
        key: 'id'
      }
    },
    parentMessageId: {
      type: DataTypes.UUID,
      allowNull: true,
      field: 'parent_message_id',
      references: {
        model: 'messages', 
        key: 'id'
      }
    },
    metadata: {
      type: DataTypes.JSON, // Changed from DataTypes.JSONB to DataTypes.JSON for MySQL compatibility
      allowNull: true,
    }
  }, {
    sequelize,
    modelName: 'Message',
    tableName: 'messages',
    timestamps: true,
    underscored: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    freezeTableName: true,
    indexes: [
      {
        fields: ['conversation_id'],
      },
      {
        fields: ['sender_id'],
      },
      {
        fields: ['created_at'],
      }
    ]
  });

  return Message;
};
</file>

<file path="models/User.js">
'use strict';
const { Model } = require('sequelize');
const bcrypt = require('bcryptjs');

module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    static associate(models) {
      // Messages sent by the user
      User.hasMany(models.Message, { 
        foreignKey: 'sender_id', 
        as: 'sentMessages' 
      });
      
      // Conversations the user participates in
      User.belongsToMany(models.Conversation, { 
        through: models.UserConversation,
        foreignKey: 'user_id',
        otherKey: 'conversation_id',
        as: 'conversations'
      });
      
      // User's participation in conversations
      User.hasMany(models.UserConversation, {
        foreignKey: 'user_id',
        as: 'conversationParticipants'
      });
    }

    async comparePassword(candidatePassword) {
      return bcrypt.compare(candidatePassword, this.password);
    }

    async generateAuthTokens() {
      const jwt = require('jsonwebtoken');
      const config = require('../config/config');
      
      const accessToken = jwt.sign(
        { id: this.id, role: this.role },
        config.jwt.secret,
        { expiresIn: config.jwt.accessExpirationMinutes * 60 }
      );
      
      const refreshToken = jwt.sign(
        { id: this.id },
        config.jwt.refreshSecret,
        { expiresIn: config.jwt.refreshExpirationDays * 24 * 60 * 60 }
      );
      
      this.refresh_token = refreshToken;
      await this.save();
      
      return { accessToken, refreshToken };
    }
  }

  User.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
      field: 'id'
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      field: 'username',
      validate: {
        notEmpty: { msg: 'Username cannot be empty.' },
        len: {
          args: [3, 30],
          msg: 'Username must be between 3 and 30 characters.'
        },
        is: {
          args: /^[a-zA-Z0-9_]+$/,
          msg: 'Username can only contain letters, numbers, and underscores.'
        }
      }
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      field: 'email',
      validate: {
        isEmail: { msg: 'Invalid email address.' },
        notEmpty: { msg: 'Email cannot be empty.' }
      }
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      field: 'password',
      validate: {
        notEmpty: { msg: 'Password cannot be empty.' },
        len: {
          args: [8, 100],
          msg: 'Password must be at least 8 characters long.'
        }
      }
    },
    first_name: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'first_name',
      validate: {
        len: {
          args: [1, 50],
          msg: 'First name must be between 1 and 50 characters.'
        }
      }
    },
    last_name: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'last_name',
      validate: {
        len: {
          args: [1, 50],
          msg: 'Last name must be between 1 and 50 characters.'
        }
      }
    },
    role: {
      type: DataTypes.ENUM('user', 'admin'),
      allowNull: false,
      defaultValue: 'user',
      field: 'role'
    },
    is_email_verified: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
      field: 'is_email_verified'
    },
    last_login: {
      type: DataTypes.DATE,
      allowNull: true,
      field: 'last_login'
    },
    refresh_token: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'refresh_token'
    },
    password_reset_token: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'password_reset_token'
    },
    password_reset_expires: {
      type: DataTypes.DATE,
      allowNull: true,
      field: 'password_reset_expires'
    },
    email_verification_token: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'email_verification_token'
    },
    email_verification_token_expires: {
      type: DataTypes.DATE,
      allowNull: true,
      field: 'email_verification_token_expires'
    },
    created_at: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'created_at',
      defaultValue: DataTypes.NOW
    },
    updated_at: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'updated_at',
      defaultValue: DataTypes.NOW
    }
  }, {
    sequelize,
    modelName: 'User',
    tableName: 'users',
    timestamps: true,
    underscored: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    defaultScope: {
      attributes: { 
        exclude: [
          'password', 
          'refresh_token', 
          'password_reset_token', 
          'email_verification_token',
          'email_verification_token_expires',
          'password_reset_expires'
        ] 
      },
    },
    scopes: {
      withSensitiveData: {
        attributes: { 
          include: [
            'password', 
            'refresh_token', 
            'password_reset_token', 
            'email_verification_token',
            'email_verification_token_expires',
            'password_reset_expires'
          ] 
        },
      },
    },
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
      },
      beforeUpdate: async (user) => {
        if (user.changed('password')) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
      }
    }
  });

  return User;
};
</file>

<file path="models/UserConversation.js">
/**
 * UserConversation Model (Join Table)
 * 
 * Defines the join table between Users and Conversations.
 * Represents a user's participation in a conversation.
 * 
 * @module models/UserConversation
 * @requires sequelize
 */

const { DataTypes, Model } = require('sequelize');

module.exports = (sequelize) => {
  class UserConversation extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // Define associations to User and Conversation
      UserConversation.belongsTo(models.User, { 
        foreignKey: 'userId',
        as: 'user'
      });
      
      UserConversation.belongsTo(models.Conversation, { 
        foreignKey: 'conversationId',
        as: 'conversation'
      });
    }
  }

  UserConversation.init({
    // No 'id' field - using composite primary key instead
    userId: {
      type: DataTypes.UUID,
      allowNull: false,
      primaryKey: true, // Part of composite primary key
      references: {
        model: 'users',
        key: 'id',
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE',
      field: 'user_id' // Explicitly map to DB column
    },
    conversationId: {
      type: DataTypes.UUID,
      allowNull: false,
      primaryKey: true, // Part of composite primary key
      references: {
        model: 'conversations',
        key: 'id',
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE',
      field: 'conversation_id' // Explicitly map to DB column
    },
    // Timestamps with underscored fields
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW
    },
    // You could add more attributes here, e.g.:
    // joinedAt: {
    //   type: DataTypes.DATE,
    //   defaultValue: DataTypes.NOW,
    //   allowNull: false,
    // },
    // lastReadMessageId: {
    //   type: DataTypes.UUID,
    //   allowNull: true,
    // },
    // muted: {
    //   type: DataTypes.BOOLEAN,
    //   defaultValue: false,
    // }
  }, {
    sequelize,
    modelName: 'UserConversation',
    tableName: 'userconversations', // Lowercase to match actual database table name
    timestamps: true,
    underscored: true, // Enable snake_case conversion for column names
    // No need for indexes as we're using a composite primary key
  });

  // Add indexes for better query performance
  UserConversation.addHook('afterSync', 'addIndexes', async () => {
    const queryInterface = sequelize.getQueryInterface();
    
    // Add composite unique index to prevent duplicate user-conversation pairs
    const indexes = await queryInterface.showIndex('userconversations');
    const hasCompositeIndex = indexes.some(index => 
      index.name === 'user_conversation_unique' || 
      (index.fields && index.fields.length === 2 && 
       index.fields.some(f => f.attribute === 'user_id') && 
       index.fields.some(f => f.attribute === 'conversation_id'))
    );
    
    if (!hasCompositeIndex) {
      await queryInterface.addIndex('userconversations', ['user_id', 'conversation_id'], {
        unique: true,
        name: 'user_conversation_unique'
      });
    }
  });

  return UserConversation;
};
</file>

<file path="package.json">
{
  "name": "coach-ally-backend",
  "version": "1.0.0",
  "description": "Backend for Coach Ally - AI-powered coaching platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest --detectOpenHandles --forceExit",
    "lint": "eslint . --ext .js",
    "format": "prettier --write \"**/*.{js,json,md}\"",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:migrate:undo": "npx sequelize-cli db:migrate:undo",
    "db:migrate:undo:all": "npx sequelize-cli db:migrate:undo:all",
    "db:seed": "npx sequelize-cli db:seed:all",
    "db:seed:undo": "npx sequelize-cli db:seed:undo:all"
  },
  "keywords": [
    "coaching",
    "ai",
    "chat",
    "nodejs",
    "express",
    "postgresql"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@stomp/stompjs": "^7.1.1",
    "axios": "^1.9.0",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-rate-limit": "^6.7.0",
    "helmet": "^6.0.1",
    "http-status-codes": "^2.2.0",
    "joi": "^17.7.0",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "mysql2": "^3.9.0",
    "openai": "^4.100.0",
    "pg": "^8.8.0",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.28.0",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sockjs-client": "^1.6.1",
    "uuid": "^9.0.1",
    "winston": "^3.8.2",
    "winston-daily-rotate-file": "^4.7.1"
  },
  "devDependencies": {
    "eslint": "^8.25.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.2.1",
    "jest": "^29.2.2",
    "nodemon": "^3.1.10",
    "prettier": "^2.7.1",
    "sequelize-cli": "^6.5.1",
    "supertest": "^6.3.0"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "jest": {
    "testEnvironment": "node",
    "coveragePathIgnorePatterns": [
      "/node_modules/"
    ]
  }
}
</file>

<file path="README.md">
# Coach Ally Backend

## Project Structure

```
backend/
â”œâ”€â”€ config/               # Configuration files
â”œâ”€â”€ controllers/          # Request handlers
â”œâ”€â”€ middleware/           # Express middleware
â”œâ”€â”€ models/               # Sequelize models
â”œâ”€â”€ routes/               # API routes
â”œâ”€â”€ services/             # Business logic
â”œâ”€â”€ utils/                # Utility functions
â”œâ”€â”€ .env                  # Environment variables
â”œâ”€â”€ .env.example          # Example environment variables
â”œâ”€â”€ .sequelizerc          # Sequelize configuration
â””â”€â”€ server.js             # Application entry point
```

## Getting Started

### Prerequisites

- Node.js (v16+)
- PostgreSQL (v12+)
- npm or yarn

### Installation

1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   ```
3. Copy `.env.example` to `.env` and update the values
4. Create a PostgreSQL database
5. Run migrations:
   ```bash
   npx sequelize-cli db:migrate
   ```
6. Start the development server:
   ```bash
   npm run dev
   ```

### Environment Variables

See `.env.example` for all required environment variables.

## API Documentation

### Authentication

- `POST /api/auth/register` - Register a new user
- `POST /api/auth/login` - Login with email and password
- `POST /api/auth/refresh-token` - Refresh access token
- `POST /api/auth/logout` - Invalidate refresh token

### Users

- `GET /api/users/me` - Get current user profile
- `PUT /api/users/me` - Update current user
- `DELETE /api/users/me` - Delete current user

### Conversations

- `GET /api/conversations` - List user's conversations
- `POST /api/conversations` - Create new conversation
- `GET /api/conversations/:id` - Get conversation details
- `PUT /api/conversations/:id` - Update conversation
- `DELETE /api/conversations/:id` - Delete conversation

### Messages

- `GET /api/messages?conversationId=:id` - Get messages in conversation
- `POST /api/messages` - Send new message
- `PUT /api/messages/:id` - Update message
- `DELETE /api/messages/:id` - Delete message

## Development

### Scripts

- `npm run dev` - Start development server with hot-reload
- `npm test` - Run tests
- `npm run lint` - Lint code
- `npm run format` - Format code
- `npm run db:migrate` - Run database migrations
- `npm run db:seed` - Seed database

### Code Style

This project uses:
- ESLint for code linting
- Prettier for code formatting
- JSDoc for documentation

## Deployment

### Production

1. Set `NODE_ENV=production`
2. Update database and other environment variables
3. Run migrations
4. Start the server with a process manager like PM2

## License

This project is licensed under the MIT License.
</file>

<file path="routes/api/conversations.js">
const express = require('express');
const router = express.Router();
const conversationController = require('../../controllers/conversationController');
const { createConversationRules, getConversationByIdRules, validateRequest } = require('../../middleware/validators/conversationValidator');
const authMiddleware = require('../../middleware/authMiddleware'); // Assuming this path for auth middleware

// @route   POST api/conversations
// @desc    Create a new conversation
// @access  Private
router.post(
    '/', 
    authMiddleware, 
    createConversationRules(), 
    validateRequest, 
    conversationController.createConversationHandler
);

// @route   GET api/conversations
// @desc    Get all conversations for the current user
// @access  Private
router.get(
    '/', 
    authMiddleware, 
    conversationController.getUserConversationsHandler
);

// @route   GET api/conversations/:id
// @desc    Get a specific conversation by its ID
// @access  Private
router.get(
    '/:id', 
    authMiddleware, 
    getConversationByIdRules(), 
    validateRequest, 
    conversationController.getConversationByIdHandler
);

// Mount nested routers for messages and participants
const messageRoutes = require('./messages'); // Assuming messages.js is in the same directory
const participantRoutes = require('./participants'); // Assuming participants.js is in the same directory

router.use('/:conversationId/messages', messageRoutes);
router.use('/:conversationId/participants', participantRoutes);

module.exports = router;
</file>

<file path="routes/api/messages.js">
const express = require('express');
// Ensure mergeParams is true to access :conversationId from parent router
const router = express.Router({ mergeParams: true }); 
const messageController = require('../../controllers/messageController');
const {
    sendMessageRules,
    getMessagesRules,
    markMessagesAsReadRules,
    validateRequest
} = require('../../middleware/validators/messageValidator');
const authMiddleware = require('../../middleware/authMiddleware'); // Use the real auth middleware
const logger = require('../../utils/logger');

logger.info('MESSAGE ROUTER FILE LOADED'); // Confirm this file is loaded by Node

// @route   POST /
// @desc    Send a new message in a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/messages)
router.post(
    '/',
    authMiddleware,
    sendMessageRules(),
    validateRequest,
    messageController.sendMessageHandler
);

// @route   GET /
// @desc    Get message history for a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/messages)
router.get(
    '/',
    (req, res, next) => {
        logger.info(`MESSAGE ROUTE: Initial entry for GET / (convId: ${req.params.conversationId})`);
        next();
    },
    authMiddleware,
    (req, res, next) => {
        logger.info(`MESSAGE ROUTE: After authMiddleware for GET / (user: ${req.user ? req.user.id : 'null'})`);
        next();
    },
    getMessagesRules(),
    (req, res, next) => {
        logger.info('MESSAGE ROUTE: After getMessagesRules for GET /');
        next();
    },
    validateRequest,
    (req, res, next) => {
        logger.info('MESSAGE ROUTE: After validateRequest for GET /');
        next();
    },
    messageController.getMessagesHandler
);

// @route   POST /read
// @desc    Mark messages in a conversation as read
// @access  Private
// (Mounted at /api/conversations/:conversationId/messages/read)
router.post(
    '/read',
    authMiddleware,
    markMessagesAsReadRules(),
    validateRequest,
    messageController.markMessagesAsReadHandler
);

module.exports = router;
</file>

<file path="routes/api/participants.js">
const express = require('express');
// Ensure mergeParams is true to access :conversationId from parent router
const router = express.Router({ mergeParams: true }); 
const participantController = require('../../controllers/participantController');
const {
    addParticipantsRules,
    removeParticipantRules,
    validateRequest
} = require('../../middleware/validators/participantValidator');
const authMiddleware = require('../../middleware/authMiddleware'); // Assuming this path

// @route   POST /
// @desc    Add participants to a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/participants)
router.post(
    '/',
    authMiddleware,
    addParticipantsRules(),
    validateRequest,
    participantController.addParticipantsHandler
);

// @route   DELETE /:userId
// @desc    Remove a participant from a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/participants/:userId)
router.delete(
    '/:userId',
    authMiddleware,
    removeParticipantRules(),
    validateRequest,
    participantController.removeParticipantHandler
);

module.exports = router;
</file>

<file path="routes/auth.js">
/**
 * Authentication Routes
 * 
 * Defines all authentication-related API endpoints.
 * Handles user registration, login, token refresh, and logout.
 * 
 * @module routes/auth
 * @requires express
 * @requires ../controllers/authController
 * @requires ../middleware/validation
 * @requires ../middleware/auth
 * 
 * @example
 * // Example usage in Express app:
 * const authRoutes = require('./routes/auth');
 * app.use('/api/auth', authRoutes);
 */

// File will be implemented with routes for:
// 1. POST /register - Register a new user
// 2. POST /login - User login with credentials
// 3. POST /refresh-token - Refresh access token
// 4. POST /logout - Invalidate refresh token
// 5. POST /forgot-password - Request password reset
// 6. POST /reset-password - Reset password with token

// Implementation will include proper route validation and error handling
</file>

<file path="routes/authRoutes.js">
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authenticateJWT } = require('../middleware/auth');
const { validateRegistration, validateLogin, validateEmail, validatePasswordReset, validateToken } = require('../middleware/authValidators'); // Assuming these validators will be created

// Public routes
router.post('/register', validateRegistration, authController.register);
router.post('/login', validateLogin, authController.login);
router.post('/refresh-token', authController.refreshToken); // Refresh token is in cookie, no specific validation here for body
router.post('/request-password-reset', validateEmail, authController.requestPasswordReset);
router.post('/reset-password/:token', validatePasswordReset, authController.resetPassword); // Token in URL, newPassword in body
router.get('/verify-email/:token', validateToken, authController.verifyEmail); // Token in URL

// Private routes (require authentication via JWT)
router.post('/logout', authenticateJWT, authController.logout);
router.post('/request-email-verification', authenticateJWT, authController.requestEmailVerification);

module.exports = router;
</file>

<file path="routes/conversations.js">
/**
 * Conversation Routes
 * 
 * Defines all conversation-related API endpoints.
 * Handles creating, retrieving, updating, and deleting conversations.
 * 
 * @module routes/conversations
 * @requires express
 * @requires ../controllers/conversationController
 * @requires ../middleware/auth
 * @requires ../middleware/validators/conversationValidator
 */

const express = require('express');
const { authenticateJWT } = require('../middleware/auth');
const conversationController = require('../controllers/conversationController');
const { createConversationRules, getConversationByIdRules, validateRequest } = require('../middleware/validators/conversationValidator');
const logger = require('../utils/logger');

// Import the message routes (from the api directory)
const messageRoutes = require('./api/messages');

module.exports = function(Router) {
  const router = Router();

  // Apply auth middleware to all routes
  router.use(authenticateJWT);

  /**
   * @route   POST /
   * @desc    Create a new conversation or return existing direct conversation
   * @access  Private
   */
  router.post(
    '/',
    createConversationRules(),
    validateRequest,
    conversationController.createConversationHandler
  );

  /**
   * @route   GET /:id
   * @desc    Get a conversation by ID
   * @access  Private
   */
  router.get(
    '/:id',
    getConversationByIdRules(),
    validateRequest,
    conversationController.getConversationByIdHandler
  );

  /**
   * @route   GET /
   * @desc    Get all conversations for the logged-in user
   * @access  Private
   */
  router.get('/', conversationController.getUserConversationsHandler);
  
  // Mount message routes under /:conversationId/messages
  logger.info('Mounting message routes under /conversations/:conversationId/messages');
  router.use('/:conversationId/messages', messageRoutes);
  
  // Future routes can be added here:
  // router.put('/:id/participants', conversationController.addParticipantsHandler);
  // router.delete('/:id/participants', conversationController.removeParticipantsHandler);
  // router.delete('/:id', conversationController.deleteConversationHandler);

  return router;
};
</file>

<file path="routes/messages.js">
/**
 * Message Routes
 *
 * Defines all message-related API endpoints.
 * Handles sending, retrieving, updating, and deleting messages.
 *
 * @module routes/messages
 * @requires express
 * @requires ../controllers/messageController
 * @requires ../middleware/authMiddleware
 * @requires ../middleware/validation/messageValidation
 * @requires ../middleware/uploadMiddleware
 */

// const messageController = require('../controllers/messageController'); // To be implemented
// const authMiddleware = require('../middleware/authMiddleware'); // To be implemented
// const { validateMessageCreation } = require('../middleware/validation/messageValidation'); // To be implemented
// const upload = require('../middleware/uploadMiddleware'); // To be implemented for attachments

module.exports = function(Router) {
  const router = Router();

  // Placeholder route - GET /api/messages/
  // This will eventually list messages in a conversation
  router.get('/', (req, res) => {
    res.status(200).json({ message: 'Message routes are active. Implementation pending.' });
  });

  // Future routes (examples):
  // router.post('/', authMiddleware, upload.single('attachment'), validateMessageCreation, messageController.sendMessage);
  // router.get('/:id', authMiddleware, messageController.getMessageById);
  // router.put('/:id', authMiddleware, messageController.updateMessage);
  // router.delete('/:id', authMiddleware, messageController.deleteMessage);
  // router.post('/:id/read', authMiddleware, messageController.markAsRead);

  return router;
};
</file>

<file path="routes/participants.js">
/**
 * Routes for managing conversation participants
 */
const express = require('express');
const router = express.Router({ mergeParams: true });
const participantController = require('../controllers/participantController');
const { authenticate } = require('../middleware/authMiddleware');

// Add participant to conversation
router.post('/', authenticate, participantController.addParticipantsHandler);

// Remove participant from conversation
router.delete('/:userId', authenticate, participantController.removeParticipantHandler);

module.exports = router;
</file>

<file path="routes/users.js">
/**
 * User Routes
 *
 * Defines all user-related API endpoints.
 * Handles user profile management and user data retrieval.
 *
 * @module routes/users
 * @requires express
 * @requires ../controllers/userController
 * @requires ../middleware/authMiddleware
 * @requires ../middleware/validation/userValidation
 * @requires ../middleware/uploadMiddleware
 */

// const userController = require('../controllers/userController'); // To be implemented
// const authMiddleware = require('../middleware/authMiddleware'); // To be implemented
// const { validateUserUpdate } = require('../middleware/validation/userValidation'); // To be implemented
// const upload = require('../middleware/uploadMiddleware'); // For profile picture uploads

module.exports = function(Router) {
  const router = Router();

  // Placeholder route - GET /api/users/me
  // This will eventually retrieve the current user's profile
  router.get('/me', (req, res) => {
    res.status(200).json({ message: 'User "me" route active. Implementation pending.' });
  });

  // Future routes (examples):
  // router.put('/me', authMiddleware, upload.single('profilePicture'), validateUserUpdate, userController.updateCurrentUser);
  // router.delete('/me', authMiddleware, userController.deleteCurrentUser);
  // router.get('/:userId', authMiddleware, userController.getUserById); // Admin or specific access

  return router;
};
</file>

<file path="scripts/checkDbStructure.js">
'use strict';

const { sequelize } = require('../models');
const logger = require('../utils/logger');

/**
 * Checks database structure and logs table names and columns
 */
async function checkDbStructure() {
  try {
    // Check database connection
    await sequelize.authenticate();
    console.log('Database connection has been established successfully.');
    
    // Get all table names
    const [tables] = await sequelize.query("SHOW TABLES");
    console.log('\nTables in database:');
    const tableNames = tables.map(t => Object.values(t)[0]);
    console.log(tableNames);
    
    // For each table, get column information
    for (const tableName of tableNames) {
      console.log(`\nColumns for table '${tableName}':`);
      const [columns] = await sequelize.query(`DESCRIBE \`${tableName}\``);
      columns.forEach(column => {
        console.log(`- ${column.Field} (${column.Type}, ${column.Null === 'YES' ? 'nullable' : 'NOT NULL'}, ${column.Key ? `key: ${column.Key}` : 'no key'})`);
      });
    }
    
    console.log('\nDatabase inspection complete');
  } catch (error) {
    console.error('Error inspecting database:', error);
  } finally {
    await sequelize.close();
  }
}

// Run the function
checkDbStructure().catch(console.error);
</file>

<file path="scripts/createSpecificUser.js">
'use strict';

const { User } = require('../models');
const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');

/**
 * Creates a user with a specific ID that the mobile app is trying to use
 */
const createSpecificUser = async () => {
  // The specific ID that the mobile app is trying to use
  const specificUserId = 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e';
  
  try {
    // Check if the user with this specific ID already exists
    const existingUser = await User.findByPk(specificUserId);
    
    if (existingUser) {
      logger.info(`User with ID ${specificUserId} already exists.`);
      return { 
        success: true, 
        message: 'User already exists', 
        user: existingUser.get({ plain: true }) 
      };
    }
    
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash('password123', salt);
    
    // Create the user with the specific ID
    const newUser = await User.create({
      id: specificUserId,
      username: 'mobileuser',
      email: 'mobile@example.com',
      password: hashedPassword,
      first_name: 'Mobile',
      last_name: 'User',
      role: 'user',
      is_email_verified: true
    });
    
    logger.info(`Created user with specific ID: ${specificUserId}`);
    
    return { 
      success: true, 
      message: 'User created successfully', 
      user: newUser.get({ plain: true }) 
    };
  } catch (error) {
    logger.error('Error creating specific user:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    
    return { 
      success: false, 
      message: 'Failed to create user',
      error: error.message
    };
  }
};

// Run the function if this script is executed directly
if (require.main === module) {
  createSpecificUser()
    .then(result => {
      console.log('Result:', result);
      process.exit(0);
    })
    .catch(error => {
      console.error('Error:', error);
      process.exit(1);
    });
}

module.exports = createSpecificUser;
</file>

<file path="scripts/debugConversationModel.js">
'use strict';

const { Conversation, User, UserConversation, sequelize } = require('../models');
const logger = require('../utils/logger');

/**
 * Debug script to test conversation fetching
 */
async function debugConversationModel() {
  try {
    console.log('Starting Conversation model debugging...');
    
    // Check database connection
    await sequelize.authenticate();
    console.log('Database connection established successfully.');
    
    // Find all conversations
    console.log('\nFetching all conversations:');
    const conversations = await Conversation.findAll({
      raw: true
    });
    console.log(`Found ${conversations.length} conversations:`);
    conversations.forEach(conv => {
      console.log(`ID: ${conv.id}, Type: ${conv.type}, CreatedBy: ${conv.createdBy}`);
    });
    
    if (conversations.length === 0) {
      console.log('No conversations found.');
      return;
    }
    
    // Get the first conversation ID to test
    const testConversationId = conversations[0].id;
    console.log(`\nTesting conversation fetching with ID: ${testConversationId}`);
    
    // Try to fetch a single conversation
    try {
      const singleConversation = await Conversation.findByPk(testConversationId);
      console.log('Conversation found:');
      console.log(JSON.stringify(singleConversation && singleConversation.toJSON(), null, 2));
    } catch (error) {
      console.error('Error fetching conversation by ID:', error.message);
      console.error('SQL Error:', error.sql || 'No SQL available');
    }
    
    // Fetch all participants for the conversation
    try {
      console.log('\nFetching participants for conversation:');
      const participants = await UserConversation.findAll({
        where: { conversation_id: testConversationId },
        raw: true
      });
      console.log(`Found ${participants.length} participants:`);
      console.log(JSON.stringify(participants, null, 2));
      
      // Get user details for each participant
      if (participants.length > 0) {
        const userIds = participants.map(p => p.user_id);
        const users = await User.findAll({
          where: { id: userIds },
          attributes: ['id', 'username', 'email'],
          raw: true
        });
        console.log('\nUser details:');
        console.log(JSON.stringify(users, null, 2));
      }
    } catch (error) {
      console.error('Error fetching participants:', error.message);
    }
    
    console.log('\nDebug complete');
  } catch (error) {
    console.error('Error in debug script:', error);
  } finally {
    await sequelize.close();
  }
}

// Run the debug function
debugConversationModel().catch(console.error);
</file>

<file path="scripts/update-test-user-email.js">
'use strict';

const { sequelize } = require('../models');
const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');

async function ensureTestUser() {
  const transaction = await sequelize.transaction();
  
  try {
    // Check if test user exists
    const [users] = await sequelize.query(
      `SELECT id, username, email FROM users WHERE username = 'testuser' OR email = 'test@example.com'`,
      { transaction }
    );

    if (users.length > 0) {
      // Update existing user
      const [updated] = await sequelize.query(
        `UPDATE users SET 
          email = 'test@example.com', 
          username = 'testuser',
          password = ?,
          updated_at = NOW()
        WHERE id = ?`,
        {
          replacements: [await bcrypt.hash('testpassword123', 10), users[0].id],
          transaction
        }
      );
      logger.info('Updated existing test user');
    } else {
      // Create new test user
      await sequelize.query(
        `INSERT INTO users 
        (id, username, email, password, created_at, updated_at)
        VALUES (?, ?, ?, ?, NOW(), NOW())`,
        {
          replacements: [
            '11111111-1111-1111-1111-111111111111',
            'testuser',
            'test@example.com',
            await bcrypt.hash('testpassword123', 10)
          ],
          transaction
        }
      );
      logger.info('Created new test user');
    }

    // Verify the user exists
    const [updatedUsers] = await sequelize.query(
      `SELECT id, username, email FROM users WHERE username = 'testuser'`,
      { transaction }
    );
    
    logger.info('Current test user data:', updatedUsers[0]);
    
    await transaction.commit();
    return updatedUsers[0];
    
  } catch (error) {
    await transaction.rollback();
    logger.error('Error ensuring test user:', error);
    throw error;
  }
}

async function run() {
  try {
    await ensureTestUser();
    logger.info('Test user setup completed successfully');
  } catch (error) {
    logger.error('Failed to setup test user:', error);
  } finally {
    await sequelize.close();
    process.exit(0);
  }
}

run();
</file>

<file path="seeders/20250516164510-add-test-user.js">
'use strict';
const bcrypt = require('bcryptjs');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    const hashedPassword = await bcrypt.hash('testpassword123', 10);
    
    // Check if test user already exists
    const [existingUser] = await queryInterface.sequelize.query(
      `SELECT id FROM users WHERE email = 'test@example.com' OR username = 'testuser'`,
      { type: Sequelize.QueryTypes.SELECT }
    );

    if (!existingUser) {
      await queryInterface.bulkInsert('users', [{
        id: '11111111-1111-1111-1111-111111111111',
        username: 'testuser',
        email: 'test@example.com',
        password: hashedPassword,
        first_name: 'Test',
        last_name: 'User',
        created_at: new Date(),
        updated_at: new Date()
      }]);
    }
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', {
      email: 'test@example.com'
    });
  }
};
</file>

<file path="seeders/20250516164600-add-test-user-seed.js">
'use strict';
const bcrypt = require('bcryptjs');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    const hashedPassword = await bcrypt.hash('testpassword123', 10);
    
    // Check if test user already exists
    const [existingUser] = await queryInterface.sequelize.query(
      `SELECT id FROM users WHERE email = 'test@example.com' OR username = 'testuser'`,
      { type: Sequelize.QueryTypes.SELECT }
    );

    if (!existingUser) {
      await queryInterface.bulkInsert('users', [{
        id: '11111111-1111-1111-1111-111111111111',
        username: 'testuser',
        email: 'test@example.com',
        password: hashedPassword,
        first_name: 'Test',
        last_name: 'User',
        created_at: new Date(),
        updated_at: new Date()
      }]);
    }
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', {
      email: 'test@example.com'
    });
  }
};
</file>

<file path="seeders/createTestUser.js">
'use strict';

const { User, sequelize } = require('../models');
const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');
const { v4: uuidv4 } = require('uuid');
const { Op } = require('sequelize');

/**
 * Creates a test user if it doesn't exist
 * @returns {Promise<{success: boolean, message: string, user?: object}>}
 */
const createTestUser = async () => {
  const testUserData = {
    id: uuidv4(),
    username: 'testuser',
    email: 'test@example.com',
    password: 'testpassword123',
    first_name: 'Test',
    last_name: 'User',
    role: 'user',
    is_email_verified: true
  };

  const transaction = await sequelize.transaction();
  
  try {
    logger.info('Starting test user creation...', { email: testUserData.email });
    
    // Log database connection status
    try {
      await sequelize.authenticate();
      logger.info('Database connection established successfully');
    } catch (dbError) {
      logger.error('Database connection error:', dbError);
      throw new Error(`Database connection failed: ${dbError.message}`);
    }
    
    // Check if users table exists
    const [tables] = await sequelize.query("SHOW TABLES LIKE 'users'");
    if (tables.length === 0) {
      throw new Error('Users table does not exist');
    }
    
    // Check if test user already exists
    logger.info('Checking for existing test user...');
    const existingUser = await User.findOne({
      where: {
        [Op.or]: [
          { email: testUserData.email },
          { username: testUserData.username }
        ]
      },
      transaction,
      raw: true
    });

    if (existingUser) {
      logger.info('Test user already exists', { 
        userId: existingUser.id,
        email: existingUser.email 
      });
      await transaction.commit();
      return { 
        success: true, 
        message: 'Test user already exists',
        user: existingUser
      };
    }

    logger.info('Creating test user...', { 
      userId: testUserData.id,
      email: testUserData.email 
    });
    
    try {
      // Create user using the model to ensure all hooks and validations run
      const user = await User.create(testUserData, { transaction });
      await transaction.commit();
      
      logger.info('Test user created successfully', { 
        userId: user.id,
        email: user.email 
      });
      
      return { 
        success: true, 
        message: 'Test user created successfully',
        user: user.get({ plain: true })
      };
    } catch (createError) {
      await transaction.rollback();
      throw createError; // Re-throw to be caught by the outer catch
    }
    
  } catch (error) {
    await transaction.rollback();
    
    // Log detailed error information
    logger.error('Error in createTestUser:', {
      message: error.message,
      name: error.name,
      stack: error.stack,
      ...(error.errors && { 
        validationErrors: error.errors.map(e => ({
          path: e.path,
          message: e.message,
          type: e.type,
          value: e.value
        }))
      })
    });
    
    // For unique constraint errors
    if (error.name === 'SequelizeUniqueConstraintError') {
      return { 
        success: false, 
        message: 'A user with this email or username already exists',
        error: 'DUPLICATE_ENTRY'
      };
    }
    
    // For validation errors
    if (error.name === 'SequelizeValidationError') {
      return { 
        success: false, 
        message: 'Validation error creating test user',
        error: 'VALIDATION_ERROR',
        details: error.errors.map(e => ({
          field: e.path,
          message: e.message
        }))
      };
    }
    
    // For all other errors
    return { 
      success: false, 
      message: 'Failed to create test user',
      error: error.message,
      errorType: error.name
    };
  }
};

// If this file is run directly, execute the function
if (require.main === module) {
  createTestUser()
    .then(result => {
      console.log(result);
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('Fatal error:', error);
      process.exit(1);
    });
}

module.exports = createTestUser;
</file>

<file path="server.js">
'use strict';

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cookieParser = require('cookie-parser');
const logger = require('./utils/logger');
const { sequelize } = require('./models'); // Corrected: import sequelize instance

// Route imports
const authRoutes = require('./routes/authRoutes');
const initializeUserRoutes = require('./routes/users');
const userRoutes = initializeUserRoutes(express.Router);
const initializeConversationRoutes = require('./routes/conversations');
const conversationRoutes = initializeConversationRoutes(express.Router);
// Message routes are now imported and mounted within conversation routes

// WebSocket middleware and event handlers
const socketAuthMiddleware = require('./middleware/websocket/auth');
const initializeSocketEventHandlers = require('./socket/events');

const app = express();
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: process.env.NODE_ENV === 'production' 
      ? process.env.CLIENT_URL 
      : ['http://localhost:3000', 'http://localhost:19000', 'http://localhost:19006', 
         'exp://localhost:19000', 'exp://127.0.0.1:19000', 
         'exp://69.120.124.150:19000', 'http://69.120.124.150:19000',
         'http://69.120.124.150:5000', 'http://69.120.124.150:3000'],
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization']
  },
  pingTimeout: 60000,
  pingInterval: 25000,
  maxHttpBufferSize: 1e8 // 100MB
});

// Make io instance available in app requests (if needed, though typically not for io itself)
app.set('io', io);

// Security Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.CLIENT_URL 
    : ['http://localhost:3000', 'http://localhost:19000', 'http://localhost:19006', 
       'exp://localhost:19000', 'exp://127.0.0.1:19000', 
       'exp://69.120.124.150:19000', 'http://69.120.124.150:19000',
       'http://69.120.124.150:5000', 'http://69.120.124.150:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Rate Limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || (15 * 60 * 1000).toString()), // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX || '100'), // 100 requests per windowMs per IP
  standardHeaders: true,
  legacyHeaders: false,
});
app.use(limiter);

// Body Parsers
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/conversations', conversationRoutes);
// Removed top-level message routes - these should only be accessed via conversations

// Health Check Endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    version: process.env.npm_package_version || 'unknown'
  });
});

// Socket.IO Middleware and Connection Handling
io.use(socketAuthMiddleware); // Apply authentication middleware to Socket.IO
io.on('connection', (socket) => {
  if (socket.user) {
    logger.info(`Authenticated client connected: ${socket.user.username} (Socket ID: ${socket.id})`);
    socket.join(socket.user.id.toString()); // Join a room specific to the user
    initializeSocketEventHandlers(io, socket); // Initialize event handlers for this socket
  } else {
    logger.warn(`Unauthenticated client connected (Socket ID: ${socket.id}). Disconnecting.`);
    socket.disconnect(true);
    return;
  }

  socket.on('disconnect', () => {
    if (socket.user) {
      logger.info(`Client disconnected: ${socket.user.username} (Socket ID: ${socket.id})`);
    }
  });

  socket.on('error', (error) => {
    logger.error(`Socket error for user ${socket.user ? socket.user.username : 'unknown'}:`, error);
  });
});

// 404 Handler (after all routes)
app.use((req, res) => {
  res.status(404).json({
    status: 'error',
    message: 'Resource not found',
    path: req.originalUrl
  });
});

// Global Error Handling Middleware (last middleware)
app.use((err, req, res, next) => {
  logger.error('Unhandled error:', err.stack || err.message || err);
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'An unexpected error occurred!',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

const PORT = process.env.PORT || 5000;

// Import test user creator
const createTestUser = require('./seeders/createTestUser');

// Database connection and server start
sequelize.authenticate()
  .then(async () => {
    logger.info('Database connection established successfully.');
    
    // Create test user
    if (process.env.NODE_ENV !== 'production') {
      try {
        logger.info('Setting up test user...');
        const result = await createTestUser();
        if (result.success) {
          logger.info(result.message);
        } else {
          logger.error('Failed to create test user:', result.message);
          if (result.error) logger.error('Error details:', result.error);
        }
      } catch (error) {
        logger.error('Unexpected error in test user setup:', error);
      }
    }
    
    // Start the server
    server.listen(PORT, '0.0.0.0', () => {
      logger.info(`Server running on port ${PORT} in ${process.env.NODE_ENV || 'development'} mode`);
      logger.info(`Server bound to all network interfaces (0.0.0.0)`);
    });
  })
  .catch(error => {
    logger.error('Unable to connect to the database:', error);
    process.exit(1); // Exit if DB connection fails
  });

// Graceful shutdown
const gracefulShutdown = (signal) => {
  logger.info(`${signal} signal received: closing HTTP server`);
  server.close(() => {
    logger.info('HTTP server closed');
    sequelize.close().then(() => {
      logger.info('Database connection closed');
      process.exit(0);
    }).catch(err => {
      logger.error('Error closing database connection:', err);
      process.exit(1);
    });
  });
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT')); // Handle Ctrl+C

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // Optionally, close server and exit
});

process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  // Optionally, close server and exit
  process.exit(1); // Mandatory exit after uncaught exception
});

module.exports = { app, server, io };
</file>

<file path="services/authService.js">
/**
 * Authentication Service
 * 
 * Handles core authentication logic including user registration, login,
 * token generation, and password management.
 * 
 * @module services/authService
 * @requires bcryptjs
 * @requires jsonwebtoken
 * @requires ../models/User
 * @requires ../config/config
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { registerUser, loginUser } = require('../services/authService');
 * const user = await registerUser(userData);
 * const tokens = await loginUser(email, password);
 */

const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { User } = require('../models'); // Assuming models/index.js exports models
const config = require('../config/config');
const logger = require('../utils/logger');
const crypto = require('crypto');
const { ApiError, SMTPEror, BadRequestError, NotFoundError, UnauthorizedError, ForbiddenError } = require('../utils/errors'); // Assuming custom errors
const httpStatusCodes = require('http-status-codes');

/**
 * Registers a new user.
 * @param {object} userData - The user data (username, email, password, firstName, lastName).
 * @returns {Promise<User>} The created user object (without sensitive data).
 * @throws {ApiError} If email or username already exists, or on other validation errors.
 */
const registerUser = async (userData) => {
  const { email, username, password, first_name, last_name } = userData;

  // Check if email or username already exists
  const existingUserByEmail = await User.findOne({ where: { email } });
  if (existingUserByEmail) {
    throw new BadRequestError('Email address is already in use.');
  }

  const existingUserByUsername = await User.findOne({ where: { username } });
  if (existingUserByUsername) {
    throw new BadRequestError('Username is already taken.');
  }

  try {
    const user = await User.create({
      username,
      email,
      password,
      first_name,
      last_name,
      role: 'user',
      is_email_verified: false,
    });
    logger.info(`User registered successfully: ${user.email}`);
    // The toJSON method in the User model should handle removing sensitive fields.
    return user; 
  } catch (error) {
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
      // Extract meaningful messages from Sequelize errors
      const messages = error.errors.map(e => e.message).join(', ');
      logger.error(`Validation error during registration: ${messages}`);
      throw new BadRequestError(`Registration failed: ${messages}`);
    }    
    logger.error(`Error registering user: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred during registration.');
  }
};

/**
 * Logs in an existing user.
 * @param {string} email - The user's email.
 * @param {string} password - The user's password.
 * @returns {Promise<{user: User, tokens: {accessToken: string, refreshToken: string}}>} User object and tokens.
 * @throws {ApiError} If login fails (e.g., invalid credentials, user not found).
 */
const loginUser = async (email, password) => {
  if (!email || !password) {
    throw new BadRequestError('Email and password are required.');
  }

  // Find user by email, including sensitive info for password comparison
  const user = await User.scope('withSensitiveData').findOne({ where: { email } });

  if (!user) {
    logger.warn(`Login attempt failed for non-existent email: ${email}`);
    throw new UnauthorizedError('Invalid email or password.');
  }

  // Compare password
  const isPasswordMatch = await user.comparePassword(password);
  if (!isPasswordMatch) {
    logger.warn(`Login attempt failed for user ${email}: Incorrect password.`);
    throw new UnauthorizedError('Invalid email or password.');
  }

  // Generate tokens
  const tokens = await user.generateAuthTokens();

  // Update lastLogin timestamp
  user.lastLogin = new Date();
  await user.save({ fields: ['lastLogin'] }); // Only update lastLogin

  logger.info(`User logged in successfully: ${user.email}`);
  // The user object returned here will be serialized by its toJSON method (or defaultScope if not overridden by toJSON)
  return { user, tokens }; 
};

/**
 * Refreshes authentication tokens using a refresh token.
 * @param {string} oldRefreshToken - The refresh token to be verified.
 * @returns {Promise<{accessToken: string, refreshToken: string}>} New access and refresh tokens.
 * @throws {ApiError} If the refresh token is invalid, expired, or not found.
 */
const refreshAuthTokens = async (oldRefreshToken) => {
  if (!oldRefreshToken) {
    throw new BadRequestError('Refresh token is required.');
  }

  try {
    // Verify the refresh token
    const decoded = jwt.verify(oldRefreshToken, config.jwt.refreshSecret);
    
    // Find user by ID from token, including sensitive info to check stored refresh token
    const user = await User.scope('withSensitiveInfo').findByPk(decoded.id);

    if (!user) {
      logger.warn(`Refresh token verification failed: User ${decoded.id} not found.`);
      throw new UnauthorizedError('Invalid refresh token: User not found.');
    }

    // Check if the provided refresh token matches the one stored in the database
    if (user.refreshToken !== oldRefreshToken) {
      logger.warn(`Refresh token mismatch for user ${user.email}. Possible token reuse or old token.`);
      // Optionally, invalidate all user sessions here for security
      // user.refreshToken = null;
      // await user.save();
      throw new UnauthorizedError('Invalid refresh token: Token has been invalidated or is old.');
    }

    // Generate new tokens (this will also save the new refresh token to the user model)
    const newTokens = await user.generateAuthTokens();
    logger.info(`Tokens refreshed successfully for user: ${user.email}`);
    return newTokens;

  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError || error instanceof jwt.TokenExpiredError) {
      logger.warn(`Refresh token verification failed: ${error.message}`);
      throw new UnauthorizedError(`Invalid or expired refresh token: ${error.message}`);
    }
    logger.error(`Error refreshing tokens: ${error.message}`, { stack: error.stack });
    // If it's an error we threw (like UnauthorizedError from user not found/token mismatch), rethrow it
    if (error instanceof ApiError) {
        throw error;
    }
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while refreshing tokens.');
  }
};

/**
 * Logs out a user by invalidating their refresh token.
 * @param {string} userId - The ID of the user to log out.
 * @returns {Promise<void>}
 * @throws {ApiError} If the user is not found or an error occurs.
 */
const logoutUser = async (userId) => {
  if (!userId) {
    throw new BadRequestError('User ID is required for logout.');
  }

  const user = await User.scope('withSensitiveInfo').findByPk(userId);

  if (!user) {
    // This case might be debatable: if user doesn't exist, are they 'logged out'? 
    // For security, treating as an error or logging is fine.
    logger.warn(`Logout attempt for non-existent user ID: ${userId}`);
    throw new NotFoundError('User not found, cannot logout.');
  }

  // Invalidate the refresh token
  user.refreshToken = null;
  try {
    await user.save({ fields: ['refreshToken'] });
    logger.info(`User logged out successfully: ${user.email}`);
  } catch (error) {
    logger.error(`Error during logout for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred during logout.');
  }
};

/**
 * Generates a password reset token for a user and stores its hash.
 * (In a real app, this would also trigger sending an email with the plain token).
 * @param {string} email - The email of the user requesting a password reset.
 * @returns {Promise<string>} The plain password reset token (for email sending).
 * @throws {ApiError} If the user is not found or an error occurs.
 */
const requestPasswordReset = async (email) => {
  if (!email) {
    throw new BadRequestError('Email is required to request a password reset.');
  }

  const user = await User.scope('withSensitiveInfo').findOne({ where: { email } });

  if (!user) {
    // Do not reveal if the user exists or not for security reasons.
    // Log it, but return a generic success-like message or handle it in the controller.
    logger.info(`Password reset request for non-existent email: ${email}`);
    // To prevent email enumeration, you might not want to throw an error here that indicates the user doesn't exist.
    // However, for service-level logic, knowing the user wasn't found is important. The controller can mask this.
    // For now, we'll throw NotFoundError, but this is a design consideration.
    throw new NotFoundError('User with this email not found.'); 
  }

  // Generate a plain token
  const resetToken = crypto.randomBytes(32).toString('hex');

  // Hash the token before storing it in the database
  user.passwordResetToken = crypto.createHash('sha256').update(resetToken).digest('hex');
  // Set expiration (e.g., 1 hour from now)
  user.passwordResetExpires = new Date(Date.now() + (config.jwt.passwordResetExpirationMinutes || 60) * 60 * 1000); 

  try {
    await user.save({ fields: ['passwordResetToken', 'passwordResetExpires'] });
    logger.info(`Password reset token generated for user: ${email}`);
    // In a real application, you would now send an email to the user with 'resetToken'
    // e.g., sendPasswordResetEmail(user.email, resetToken);
    return resetToken; // Return the plain token to be used in the reset link
  } catch (error) {
    logger.error(`Error saving password reset token for user ${email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while requesting password reset.');
  }
};

/**
 * Resets a user's password using a valid reset token.
 * @param {string} resetToken - The plain password reset token.
 * @param {string} newPassword - The new password to set.
 * @returns {Promise<void>}
 * @throws {ApiError} If the token is invalid, expired, or the user is not found.
 */
const resetPassword = async (resetToken, newPassword) => {
  if (!resetToken || !newPassword) {
    throw new BadRequestError('Reset token and new password are required.');
  }

  // Hash the incoming plain token to match the one stored in the database
  const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');

  // Find user by the hashed token and check if it's not expired
  const user = await User.scope('withSensitiveInfo').findOne({
    where: {
      passwordResetToken: hashedToken,
      passwordResetExpires: { [User.sequelize.Op.gt]: new Date() }, // Check if token is not expired
    },
  });

  if (!user) {
    logger.warn('Invalid or expired password reset token attempt.');
    throw new BadRequestError('Password reset token is invalid or has expired.');
  }

  // Set the new password (it will be hashed by the beforeUpdate hook in the User model)
  user.password = newPassword;
  // Clear the reset token fields
  user.passwordResetToken = null;
  user.passwordResetExpires = null;
  // Also clear any existing refresh token to force re-login on other devices
  user.refreshToken = null; 

  try {
    await user.save({ fields: ['password', 'passwordResetToken', 'passwordResetExpires', 'refreshToken'] });
    logger.info(`Password reset successfully for user: ${user.email}`);
    // In a real application, you might send a confirmation email here
    // e.g., sendPasswordResetSuccessEmail(user.email);
  } catch (error) {
    if (error.name === 'SequelizeValidationError') {
        const messages = error.errors.map(e => e.message).join(', ');
        logger.error(`Validation error during password reset for ${user.email}: ${messages}`);
        throw new BadRequestError(`Password reset failed: ${messages}`);
    }
    logger.error(`Error resetting password for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while resetting password.');
  }
};


/**
 * Generates an email verification token for a user and stores its hash.
 * (In a real app, this would also trigger sending an email with the plain token).
 * @param {string} userId - The ID of the user requesting email verification.
 * @returns {Promise<string>} The plain email verification token (for email sending).
 * @throws {ApiError} If the user is not found, already verified, or an error occurs.
 */
const requestEmailVerification = async (userId) => {
  if (!userId) {
    throw new BadRequestError('User ID is required to request email verification.');
  }

  const user = await User.scope('withSensitiveInfo').findByPk(userId);

  if (!user) {
    logger.warn(`Email verification request for non-existent user ID: ${userId}`);
    throw new NotFoundError('User not found.');
  }

  if (user.isEmailVerified) {
    logger.info(`Email verification requested for already verified user: ${user.email}`);
    throw new BadRequestError('Email is already verified.');
  }

  // Generate a plain token
  const verificationToken = crypto.randomBytes(32).toString('hex');

  // Hash the token before storing it in the database
  user.emailVerificationToken = crypto.createHash('sha256').update(verificationToken).digest('hex');
  // Set expiration (e.g., 24 hours from now)
  user.emailVerificationTokenExpires = new Date(Date.now() + (config.jwt.emailVerificationExpirationMinutes || 24 * 60) * 60 * 1000); 

  try {
    await user.save({ fields: ['emailVerificationToken', 'emailVerificationTokenExpires'] });
    logger.info(`Email verification token generated for user: ${user.email}`);
    // In a real application, you would now send an email to the user with 'verificationToken'
    // e.g., sendEmailVerificationLink(user.email, verificationToken);
    return verificationToken; // Return the plain token to be used in the verification link
  } catch (error) {
    logger.error(`Error saving email verification token for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while requesting email verification.');
  }
};

/**
 * Verifies a user's email address using a valid verification token.
 * @param {string} verificationToken - The plain email verification token.
 * @returns {Promise<void>}
 * @throws {ApiError} If the token is invalid, expired, or the user is not found.
 */
const verifyEmail = async (verificationToken) => {
  if (!verificationToken) {
    throw new BadRequestError('Email verification token is required.');
  }

  // Hash the incoming plain token to match the one stored in the database
  const hashedToken = crypto.createHash('sha256').update(verificationToken).digest('hex');

  // Find user by the hashed token and check if it's not expired
  const user = await User.scope('withSensitiveInfo').findOne({
    where: {
      emailVerificationToken: hashedToken,
      emailVerificationTokenExpires: { [User.sequelize.Op.gt]: new Date() }, // Check if token is not expired
    },
  });

  if (!user) {
    logger.warn('Invalid or expired email verification token attempt.');
    throw new BadRequestError('Email verification token is invalid or has expired.');
  }

  if (user.isEmailVerified) {
    logger.info(`Email already verified for user: ${user.email}. Token was (re)used.`);
    // Optionally, still clear the token to prevent reuse, even if already verified.
    user.emailVerificationToken = null;
    user.emailVerificationTokenExpires = null;
    try {
      await user.save({ fields: ['emailVerificationToken', 'emailVerificationTokenExpires']});
    } catch (saveError) {
        // Log error but don't fail the overall already-verified status.
        logger.error(`Error clearing already-used verification token for ${user.email}: ${saveError.message}`);
    }
    return; // Or throw BadRequestError('Email is already verified.') if strict about token reuse.
  }

  user.isEmailVerified = true;
  user.emailVerificationToken = null;
  user.emailVerificationTokenExpires = null;

  try {
    await user.save({ fields: ['isEmailVerified', 'emailVerificationToken', 'emailVerificationTokenExpires'] });
    logger.info(`Email verified successfully for user: ${user.email}`);
    // In a real application, you might send a welcome email or confirmation here
  } catch (error) {
    logger.error(`Error verifying email for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while verifying email.');
  }
};

module.exports = {
  registerUser,
  loginUser,
  refreshAuthTokens,
  logoutUser,
  requestPasswordReset,
  resetPassword,
  requestEmailVerification,
  verifyEmail,
};
</file>

<file path="services/chatService.js">
/**
 * Chat Service
 * 
 * Handles business logic for chat operations including conversation management,
 * message handling, and real-time updates.
 * 
 * @module services/chatService
 * @requires ../models/Conversation
 * @requires ../models/Message
 * @requires ../models/User
 * @requires ../services/socketService
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { createConversation, sendMessage } = require('../services/chatService');
 * const conversation = await createConversation(creatorId, participants);
 * const message = await sendMessage(senderId, conversationId, content);
 */

// File will be implemented with:
// 1. Conversation creation and management
// 2. Message sending and retrieval
// 3. Real-time message delivery via WebSocket
// 4. Message status updates (sent, delivered, read)
// 5. Typing indicators and online status

// Implementation will include proper error handling and data validation
</file>

<file path="services/conversationService.js">
// Contains business logic and data access for conversation operations
const { Op } = require('sequelize');
const { Conversation, User, UserConversation, Message, sequelize } = require('../models'); // Adjust path if your models are elsewhere
const logger = require('../utils/logger'); // Adjust path for your logger

/**
 * Checks if a direct conversation already exists between two users.
 * @param {string} userId1 - ID of the first user.
 * @param {string} userId2 - ID of the second user.
 * @returns {Promise<Conversation|null>} The existing conversation or null.
 */
const findExistingDirectConversation = async (userId1, userId2) => {
    try {
        logger.info(`Finding existing direct conversation between users ${userId1} and ${userId2}`);
        // Find conversations involving userId1
        const conversationsOfUser1 = await UserConversation.findAll({
            where: { userId: userId1 },
            attributes: ['conversationId'],
        });

        if (!conversationsOfUser1.length) {
            logger.info(`No conversations found for user ${userId1}`);
            return null;
        }

        const conversationIdsOfUser1 = conversationsOfUser1.map(uc => uc.conversationId);
        logger.info(`Found ${conversationIdsOfUser1.length} conversations for user ${userId1}`);

        // Find direct conversations among these that also involve userId2
        const directConversation = await Conversation.findOne({
            where: {
                id: { [Op.in]: conversationIdsOfUser1 },
                type: 'direct',
            },
            include: [{
                model: UserConversation,
                as: 'userConversations', // This matches the alias in Conversation model
                attributes: ['userId'],
                where: { userId: userId2 }, // Ensure the other user is part of this conversation
                required: true // This makes it an INNER JOIN on this include
            }],
        });
        
        // Further check to ensure ONLY these two users are in the direct conversation
        if (directConversation) {
            const participants = await directConversation.getParticipants({ attributes: ['id'] });
            if (participants.length === 2 && participants.some(p => p.id === userId1) && participants.some(p => p.id === userId2)) {
                return directConversation;
            }
        }
        return null;

    } catch (error) {
        logger.error('Error finding existing direct conversation:', error);
        throw error; // Re-throw to be handled by the caller
    }
};

/**
 * Creates a new conversation.
 * @param {string} creatorId - The ID of the user creating the conversation.
 * @param {string[]} participantUserIds - An array of user IDs to be included in the conversation.
 * @param {string} type - Type of conversation ('direct' or 'group'). Defaults to 'direct'.
 * @param {string|null} name - Name of the conversation, primarily for group chats.
 * @returns {Promise<Conversation>} The created conversation object with participants.
 */
const createConversation = async (creatorId, participantUserIds, type = 'direct', name = null) => {
    logger.info(`Creating conversation: type=${type}, creatorId=${creatorId}, participants=${participantUserIds.join(',')}, name=${name}`);
    
    if (!creatorId || !participantUserIds || participantUserIds.length === 0) {
        throw new Error('Creator ID and at least one participant are required.');
    }

    // Ensure creator is also part of the participant list for simplicity in UserConversation entries
    const allParticipantIds = Array.from(new Set([creatorId, ...participantUserIds]));

    if (type === 'direct') {
        if (allParticipantIds.length !== 2) {
            throw new Error('Direct conversations must have exactly two participants (including the creator).');
        }
        const existingConversation = await findExistingDirectConversation(allParticipantIds[0], allParticipantIds[1]);
        if (existingConversation) {
            logger.info(`Returning existing direct conversation ${existingConversation.id} for users ${allParticipantIds.join(', ')}`);
            // Optionally, load participants if not already loaded correctly
            return Conversation.findByPk(existingConversation.id, { include: [{ model: User, as: 'participants', attributes: ['id', 'username', 'email'] }] });
        }
    } else if (type === 'group' && !name) {
        throw new Error('Group conversations must have a name.');
    }

    const transaction = await sequelize.transaction();
    try {
        const conversation = await Conversation.create({
            type,
            name: type === 'group' ? name : null, // Name is typically for group chats
            createdBy: creatorId,
        }, { transaction });

        const userConversationEntries = allParticipantIds.map(userId => ({
            userId,
            conversationId: conversation.id,
        }));

        await UserConversation.bulkCreate(userConversationEntries, { transaction });

        await transaction.commit();

        // Fetch the conversation again with participants to return the full object
        const newConversationWithParticipants = await Conversation.findByPk(conversation.id, {
            include: [
                { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
            ]
        });
        logger.info(`Conversation ${newConversationWithParticipants.id} created successfully.`);
        return newConversationWithParticipants;
    } catch (error) {
        await transaction.rollback();
        logger.error('Error creating conversation:', error);
        throw error; // Re-throw to be handled by controller/error handler
    }
};

/**
 * Retrieves all conversations for a given user, with pagination and last message.
 * @param {string} userId - The ID of the user.
 * @param {object} options - Pagination options.
 * @param {number} options.page - The page number (default: 1).
 * @param {number} options.limit - Number of conversations per page (default: 20).
 * @returns {Promise<object>} An object containing conversations and pagination info.
 */
const getUserConversations = async (userId, { page = 1, limit = 20 } = {}) => {
    logger.info(`Fetching conversations for user ${userId}, page=${page}, limit=${limit}`);
    const offset = (page - 1) * limit;

    try {
        const { count, rows: userConversations } = await UserConversation.findAndCountAll({
            where: { userId },
            include: [{
                model: Conversation,
                as: 'conversation', // This matches the alias in UserConversation model
                include: [
                    { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                    {
                        model: Message,
                        as: 'messages',
                        attributes: ['id', 'content', 'senderId', 'createdAt', 'type'],
                        limit: 1, // Get only the last message
                        order: [['createdAt', 'DESC']],
                        include: [{model: User, as: 'sender', attributes: ['id', 'username']}]
                    }
                ]
            }],
            order: [[{model: Conversation, as: 'conversation'}, 'updatedAt', 'DESC']], // Order conversations by recent activity
            limit,
            offset,
            distinct: true, // Important for count when using includes
        });

        const conversations = userConversations.map(uc => {
            const conv = uc.conversation.toJSON(); // Work with plain object
            // Simplify the last message structure
            conv.lastMessage = conv.messages && conv.messages.length > 0 ? conv.messages[0] : null;
            delete conv.messages; // Remove the array of messages as we only needed the last one
            return conv;
        });

        return {
            conversations,
            totalPages: Math.ceil(count / limit),
            currentPage: page,
            totalConversations: count
        };
    } catch (error) {
        logger.error(`Error fetching conversations for user ${userId}:`, error);
        throw error;
    }
};

/**
 * Retrieves a specific conversation by its ID, ensuring the requesting user is a participant.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userId - The ID of the user requesting the conversation (for auth check).
 * @returns {Promise<Conversation|null>} The conversation object or null if not found or user is not a participant.
 */
const getConversationById = async (conversationId, userId) => {
    logger.info(`Fetching conversation ${conversationId} for user ${userId}`);
    try {
        const conversation = await Conversation.findByPk(conversationId, {
            include: [
                { 
                    model: User, 
                    as: 'participants', 
                    attributes: ['id', 'username', 'email'], 
                    through: { attributes: [] } // Don't need join table attributes here
                },
                { model: User, as: 'creator', attributes: ['id', 'username', 'email'] },
                // Optionally include last few messages or other relevant details
            ]
        });

        if (!conversation) {
            logger.warn(`Conversation ${conversationId} not found.`);
            return null;
        }

        // Check if the requesting user is a participant
        const isParticipant = conversation.participants.some(participant => participant.id === userId);
        if (!isParticipant) {
            logger.warn(`User ${userId} is not a participant of conversation ${conversationId}. Access denied.`);
            // Throw an error or return null based on how you want to handle unauthorized access
            const error = new Error('Access denied: You are not a participant of this conversation.');
            error.status = 403; // Forbidden
            throw error;
        }
        
        logger.info(`Conversation ${conversationId} fetched successfully for user ${userId}`);
        return conversation;
    } catch (error) {
        logger.error(`Error fetching conversation ${conversationId} for user ${userId}:`, error);
        if (!error.status) error.status = 500; // Default to server error if not set
        throw error;
    }
};

module.exports = {
    createConversation,
    getUserConversations,
    getConversationById,
    // findExistingDirectConversation, // Not typically exported unless needed elsewhere directly
};
</file>

<file path="services/messageService.js">
// Contains business logic and data access for message operations
const { Op, col } = require('sequelize');
const { Message, User, Conversation, UserConversation, sequelize } = require('../models'); // Adjust path if your models are elsewhere
const logger = require('../utils/logger'); // Adjust path for your logger
const openAIService = require('../../openai-integration/src/services/openaiService'); // Import OpenAI service

/**
 * Sends a new message in a conversation.
 * @param {string} senderId - The ID of the user sending the message.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} content - The content of the message.
 * @param {string} type - The type of message (e.g., 'text', 'image'). Defaults to 'text'.
 * @param {object|null} metadata - Additional metadata for the message (e.g., image URL, file info).
 * @returns {Promise<Message>} The created message object with sender details.
 */
const sendMessage = async (senderId, conversationId, content, type = 'text', metadata = null) => {
    logger.info(`Sending message: senderId=${senderId}, conversationId=${conversationId}, type=${type}`);

    if (!senderId || !conversationId || !content) {
        throw new Error('Sender ID, Conversation ID, and Content are required to send a message.');
    }

    try {
        // 1. Verify conversation exists and sender is a participant (important for authorization)
        const conversation = await Conversation.findByPk(conversationId, {
            include: [{
                model: UserConversation,
                as: 'userConversations',
                attributes: ['userId']
            }]
        });

        if (!conversation) {
            throw new Error(`Conversation with ID ${conversationId} not found.`);
        }

        const isParticipant = conversation.userConversations.some(uc => uc.userId === senderId);
        if (!isParticipant) {
            const authError = new Error(`User ${senderId} is not a participant of conversation ${conversationId}.`);
            authError.status = 403; // Forbidden
            throw authError;
        }

        // 2. Create the message
        const message = await Message.create({
            senderId,
            conversationId,
            content,
            type,
            metadata,
            status: 'sent' // Or 'sending' if client confirmation is awaited for 'sent'
        });
        
        // 3. Update the conversation's updatedAt timestamp to mark recent activity
        // This helps in ordering conversations by the latest message.
        await conversation.changed('updatedAt', true); // Mark 'updatedAt' as changed
        await conversation.update({ updatedAt: new Date() }); // Force update, or simply save if no other changes

        // 4. Fetch the message again with sender details to return the full object (as expected by WebSocket handlers)
        const userMessageWithSender = await Message.findByPk(message.id, {
            include: [{
                model: User,
                as: 'sender',
                attributes: ['id', 'username', 'email'] // Include necessary sender fields
            }]
        });

        logger.info(`User message ${userMessageWithSender.id} sent successfully by ${senderId} in conversation ${conversationId}`);
        
        // 5. Generate AI response
        let aiMessageWithSender = null;
        try {
            // Fetch recent conversation history for context
            const history = await Message.findAll({
                where: { conversationId },
                order: [[sequelize.col('created_at'), 'DESC']], // Use sequelize.col for proper column name
                limit: 10, // Get last 10 messages for context
                include: [{
                    model: User,
                    as: 'sender',
                    attributes: ['id', 'username']
                }]
            });
            
            // Format history for OpenAI API
            const formattedHistory = history.reverse().map(msg => ({
                role: msg.sender.id === senderId ? 'user' : 'assistant',
                content: msg.content
            }));
            
            // Get AI coach user ID
            const AI_COACH_USER_ID = process.env.AI_COACH_USER_ID || 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e';
            
            // Call OpenAI service to generate response
            logger.info(`Generating AI response for message: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`);
            const aiResponseContent = await openAIService.generateReply(formattedHistory, content);
            
            if (aiResponseContent) {
                // Create AI message in database
                const aiMessage = await Message.create({
                    senderId: AI_COACH_USER_ID,
                    conversationId,
                    content: aiResponseContent,
                    type: 'text',
                    status: 'sent'
                });
                
                // Update conversation timestamp again
                await conversation.update({ updatedAt: new Date() });
                
                // Fetch AI message with sender details
                aiMessageWithSender = await Message.findByPk(aiMessage.id, {
                    include: [{
                        model: User,
                        as: 'sender',
                        attributes: ['id', 'username', 'email']
                    }]
                });
                
                logger.info(`AI message ${aiMessageWithSender.id} created for conversation ${conversationId}`);
            }
        } catch (aiError) {
            logger.error(`Error generating AI response: ${aiError.message}`, aiError);
            // Don't let AI errors block the user message flow
        }
        
        // Return both messages
        return {
            userMessage: userMessageWithSender,
            aiMessage: aiMessageWithSender // Will be null if AI didn't respond or errored
        };
    } catch (error) {
        logger.error('Error sending message:', error);
        if (!error.status) error.status = 500; // Default to server error if not set
        throw error;
    }
};

/**
 * Retrieves messages for a specific conversation with pagination.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userId - The ID of the user requesting messages (for auth check).
 * @param {object} options - Pagination options.
 * @param {number} options.page - The page number (e.g., 1 for the latest page if ordering DESC).
 * @param {number} options.limit - Number of messages per page (default: 50).
 * @param {string|null} options.beforeMessageId - Fetches messages created before the message with this ID (for older messages).
 * @param {string|null} options.afterMessageId - Fetches messages created after the message with this ID (for newer messages/updates).
 * @returns {Promise<object>} An object containing messages and pagination info.
 */
const getMessages = async (conversationId, userId, { page, limit = 30, beforeMessageId, afterMessageId } = {}) => {
    logger.info(`MESSAGE SERVICE: Entered getMessages for convId: ${conversationId}, userId: ${userId}`);
    logger.info(`Fetching messages for conversation ${conversationId}, user ${userId}, options: ${JSON.stringify({ page, limit, beforeMessageId, afterMessageId })}`);

    try {
        // 1. Verify conversation exists and user is a participant
        logger.info(`MESSAGE SERVICE: Finding conversation ${conversationId} for participation check.`);
        const conversation = await Conversation.findByPk(conversationId, {
            include: [{
                model: UserConversation,
                as: 'userConversations', // Ensure this alias is correct as per Conversation.js model
                attributes: ['userId']
            }]
        });

        if (!conversation) {
            logger.warn(`MESSAGE SERVICE: Conversation ${conversationId} not found during getMessages.`);
            // For a 404 from the service layer, you might want a custom error
            const notFoundError = new Error(`Conversation with ID ${conversationId} not found.`);
            notFoundError.status = 404;
            throw notFoundError;
        }

        logger.info(`MESSAGE SERVICE: Conversation ${conversationId} found.`);

        const isParticipant = conversation.userConversations.some(uc => uc.userId === userId);
        if (!isParticipant) {
            logger.warn(`MESSAGE SERVICE: User ${userId} is not a participant of conversation ${conversationId}. Access denied.`);
            const authError = new Error(`User ${userId} is not a participant of conversation ${conversationId}.`);
            authError.status = 403; // Forbidden
            throw authError;
        }
        logger.info(`MESSAGE SERVICE: User ${userId} is participant. Fetching messages.`);

        // Default query options
        const queryOptions = {
            where: { conversationId },
            include: [{
                model: User,
                as: 'sender',
                attributes: ['id', 'username', 'email']
            }],
            order: [[sequelize.col('created_at'), 'DESC']], // Use sequelize.col() to reference the actual DB column name
            limit
        };

        if (beforeMessageId) {
            const cursorMessage = await Message.findByPk(beforeMessageId, { attributes: ['createdAt'] });
            if (cursorMessage) {
                queryOptions.where.createdAt = { [Op.lt]: cursorMessage.createdAt };
            }
        } else if (afterMessageId) {
             const cursorMessage = await Message.findByPk(afterMessageId, { attributes: ['createdAt'] });
            if (cursorMessage) {
                queryOptions.where.createdAt = { [Op.gt]: cursorMessage.createdAt };
                queryOptions.order = [[sequelize.col('created_at'), 'ASC']]; // Use sequelize.col() here too
            }
        } else if (page) {
            queryOptions.offset = (page - 1) * limit;
        }
        // If no pagination option (page, beforeMessageId, afterMessageId) is provided, it fetches the latest 'limit' messages.

        const { count, rows: messages } = await Message.findAndCountAll(queryOptions);
        
        // If using afterMessageId, reverse the order to be chronological for the client
        if (afterMessageId) {
            messages.reverse();
        }

        // Calculate totalPages only if using page-based pagination
        const totalPages = page ? Math.ceil(await Message.count({ where: { conversationId } }) / limit) : undefined;

        return {
            messages,
            // totalMessages: count, // This count is for the current query, not total in conversation if paginating
            totalPages, // Only relevant for page-based pagination
            currentPage: page, // Only relevant for page-based pagination
            hasNextPage: page && (page * limit < await Message.count({ where: { conversationId } })), // simplified hasNextPage
            hasPreviousPage: page && page > 1, // simplified hasPreviousPage
        };

    } catch (error) {
        logger.error(`Error fetching messages for conversation ${conversationId}:`, error);
        if (!error.status) error.status = 500; // Default to server error if not set
        throw error;
    }
};

/**
 * Marks messages in a conversation as read by a user.
 * (Placeholder - Full implementation would involve updating message statuses or a UserMessageRead table).
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userId - The ID of the user who read the messages.
 * @param {string|null} lastReadMessageId - ID of the last message read by the user. If null, could mark all.
 * @returns {Promise<object>} A success status or details of messages marked as read.
 */
const markMessagesAsRead = async (conversationId, userId, lastReadMessageId = null) => {
    logger.info(`Marking messages as read: conversationId=${conversationId}, userId=${userId}, lastReadMessageId=${lastReadMessageId}`);
    // TODO: Implement actual logic
    // 1. Verify user is participant of conversationId.
    // 2. If lastReadMessageId is provided, find all messages up to that ID (and possibly timestamp).
    // 3. Update their status to 'read' for this specific user.
    //    - This could mean updating a join table (e.g., MessageReadBy) or individual message records if status is per user.
    //    - Or, more commonly, update a UserConversation record with `lastReadMessageTimestamp` or `lastReadMessageId`.
    // 4. Potentially broadcast an event via WebSockets to notify other clients of read status update.
    
    // Example (Conceptual - requires UserConversation model to have lastReadMessageId field):
    /*
    const userConv = await UserConversation.findOne({ where: { userId, conversationId } });
    if (userConv) {
        userConv.lastReadMessageId = lastReadMessageId || userConv.lastReadMessageId; // Update if new one is provided
        // userConv.lastReadTimestamp = new Date(); // Alternative or complementary
        await userConv.save();
        return { status: 'success', message: 'Messages marked as read.' };
    } else {
        throw new Error('User or conversation not found for marking messages as read.');
    }
    */
    return { status: 'pending_implementation', message: 'Mark as read functionality is not fully implemented.' };
};

module.exports = {
    sendMessage,
    getMessages,
    markMessagesAsRead,
};
</file>

<file path="services/participantService.js">
// Contains business logic and data access for participant management
const { Op } = require('sequelize');
const { Conversation, User, UserConversation, sequelize } = require('../models'); // Adjust path if your models are elsewhere
const logger = require('../utils/logger'); // Adjust path for your logger

/**
 * Adds participants to a group conversation.
 * @param {string} requesterId - The ID of the user making the request.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string[]} userIdsToAdd - An array of user IDs to add to the conversation.
 * @returns {Promise<Conversation>} The updated conversation object with all participants.
 * @throws {Error} If validation or permission checks fail.
 */
const addParticipants = async (requesterId, conversationId, userIdsToAdd) => {
    logger.info(`Adding participants to conversation ${conversationId}: requesterId=${requesterId}, usersToAdd=${userIdsToAdd.join(',')}`);

    if (!requesterId || !conversationId || !userIdsToAdd || userIdsToAdd.length === 0) {
        throw new Error('Requester ID, Conversation ID, and at least one User ID to add are required.');
    }

    const transaction = await sequelize.transaction();
    try {
        const conversation = await Conversation.findByPk(conversationId, {
            include: [
                { model: User, as: 'participants', attributes: ['id'] },
                { model: User, as: 'creator', attributes: ['id'] }
            ],
            transaction
        });

        if (!conversation) {
            throw new Error(`Conversation with ID ${conversationId} not found.`);
        }

        if (conversation.type !== 'group') {
            throw new Error('Participants can only be added to group conversations.');
        }

        if (conversation.creatorId !== requesterId) {
            const authError = new Error('Only the conversation creator can add participants.');
            authError.status = 403; // Forbidden
            throw authError;
        }

        const existingParticipantIds = new Set(conversation.participants.map(p => p.id));
        const newParticipantIds = userIdsToAdd.filter(id => !existingParticipantIds.has(id) && id !== requesterId); // Ensure creator isn't re-added if somehow in list

        if (newParticipantIds.length === 0) {
            logger.info('No new participants to add (all users already in conversation or invalid).');
            // Fetch and return the current state of the conversation with full participant details
            await transaction.commit(); // Commit as no changes were made to UserConversation, but we did read.
            return Conversation.findByPk(conversationId, {
                include: [
                    { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                    { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
                ]
            });
        }

        // Verify that all userIdsToAdd correspond to actual users
        const usersToAddExist = await User.count({ where: { id: { [Op.in]: newParticipantIds } } });
        if (usersToAddExist !== newParticipantIds.length) {
            throw new Error('One or more users to add do not exist.');
        }

        const userConversationEntries = newParticipantIds.map(userId => ({
            userId,
            conversationId: conversation.id,
        }));

        await UserConversation.bulkCreate(userConversationEntries, { transaction });
        
        // Update conversation's updatedAt timestamp
        await conversation.update({ updatedAt: new Date() }, { transaction });

        await transaction.commit();

        logger.info(`Successfully added ${newParticipantIds.length} participants to conversation ${conversationId}.`);
        // Fetch the conversation again with full participant details
        return Conversation.findByPk(conversationId, {
            include: [
                { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
            ]
        });

    } catch (error) {
        await transaction.rollback();
        logger.error('Error adding participants:', error);
        if (!error.status) error.status = 500;
        throw error;
    }
};

/**
 * Removes a participant from a group conversation.
 * @param {string} requesterId - The ID of the user making the request.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userIdToRemove - The ID of the user to remove.
 * @returns {Promise<object>} A success message or the updated conversation.
 * @throws {Error} If validation or permission checks fail.
 */
const removeParticipant = async (requesterId, conversationId, userIdToRemove) => {
    logger.info(`Removing participant ${userIdToRemove} from conversation ${conversationId}: requesterId=${requesterId}`);

    if (!requesterId || !conversationId || !userIdToRemove) {
        throw new Error('Requester ID, Conversation ID, and User ID to remove are required.');
    }

    const transaction = await sequelize.transaction();
    try {
        const conversation = await Conversation.findByPk(conversationId, {
            include: [
                { model: User, as: 'participants', attributes: ['id'] },
                { model: User, as: 'creator', attributes: ['id'] }
            ],
            transaction
        });

        if (!conversation) {
            throw new Error(`Conversation with ID ${conversationId} not found.`);
        }

        if (conversation.type !== 'group') {
            throw new Error('Participants can only be removed from group conversations.');
        }

        const isParticipantToRemoveInConversation = conversation.participants.some(p => p.id === userIdToRemove);
        if (!isParticipantToRemoveInConversation) {
            throw new Error(`User ${userIdToRemove} is not a participant in conversation ${conversationId}.`);
        }

        // Permission checks
        const isRequesterCreator = conversation.creatorId === requesterId;
        const isRequesterRemovingThemselves = requesterId === userIdToRemove;

        if (!isRequesterCreator && !isRequesterRemovingThemselves) {
            const authError = new Error('Only the conversation creator can remove other participants, or a user can remove themselves.');
            authError.status = 403; // Forbidden
            throw authError;
        }
        
        // Prevent creator from being removed by someone else (this case should be caught above, but as a safeguard)
        if (userIdToRemove === conversation.creatorId && !isRequesterRemovingThemselves) {
             const authError = new Error('The conversation creator cannot be removed by another user.');
             authError.status = 403;
             throw authError;
        }

        // Prevent removing the last participant
        if (conversation.participants.length <= 1 && isParticipantToRemoveInConversation) {
            // If the one to remove is indeed one of the (or the only) participant
            throw new Error('Cannot remove the last participant from a group conversation. Consider deleting the conversation instead.');
        }

        const result = await UserConversation.destroy({
            where: {
                userId: userIdToRemove,
                conversationId: conversation.id,
            },
            transaction
        });

        if (result === 0) {
            // Should have been caught by `isParticipantToRemoveInConversation` check, but good to have.
            throw new Error(`Failed to remove participant ${userIdToRemove}. User may not have been a participant or an issue occurred.`);
        }

        // Update conversation's updatedAt timestamp
        await conversation.update({ updatedAt: new Date() }, { transaction });

        await transaction.commit();

        logger.info(`Successfully removed participant ${userIdToRemove} from conversation ${conversationId}.`);
        
        // If the user removed themselves, and they were the creator, specific logic might be needed (e.g., assign new creator or archive chat)
        // For now, we'll just return a success message or the updated conversation without the removed participant.
        // Fetching the updated conversation is good practice.
        const updatedConversation = await Conversation.findByPk(conversationId, {
             include: [
                { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
            ]
        });

        return {
            message: `Participant ${userIdToRemove} removed successfully.`,
            conversation: updatedConversation
        };

    } catch (error) {
        await transaction.rollback();
        logger.error('Error removing participant:', error);
        if (!error.status) error.status = 500;
        throw error;
    }
};

module.exports = {
    addParticipants,
    removeParticipant,
};
</file>

<file path="services/socketService.js">
/**
 * Socket Service
 * 
 * Manages WebSocket connections and real-time event broadcasting.
 * Handles user connections, disconnections, and room management.
 * 
 * @module services/socketService
 * @requires socket.io
 * @requires ../models/User
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { initSocket, emitToUser } = require('../services/socketService');
 * const io = initSocket(server);
 * emitToUser(userId, 'new_message', messageData);
 */

// File will be implemented with:
// 1. WebSocket server initialization
// 2. Connection and disconnection handling
// 3. Room management for conversations
// 4. Event broadcasting to users/rooms
// 5. Online status tracking

// Implementation will include proper error handling and connection state management
</file>

<file path="socket/events.js">
/**
 * Socket.IO event handlers for real-time communication
 */
const logger = require('../utils/logger');
const messageService = require('../services/messageService');

/**
 * Initialize socket event handlers for a connected client
 * @param {Object} io - Socket.IO server instance
 * @param {Object} socket - Socket.IO client socket
 */
const initializeSocketEventHandlers = (io, socket) => {
  const userId = socket.user.id;
  const username = socket.user.username;

  // Join user to their own room for direct messages
  socket.join(userId.toString());

  // Handle joining conversation rooms
  socket.on('joinConversation', (conversationId) => {
    if (!conversationId) return;
    
    logger.info(`User ${username} (${userId}) joining conversation room: ${conversationId}`);
    socket.join(conversationId.toString());
  });

  // Handle leaving conversation rooms
  socket.on('leaveConversation', (conversationId) => {
    if (!conversationId) return;
    
    logger.info(`User ${username} (${userId}) leaving conversation room: ${conversationId}`);
    socket.leave(conversationId.toString());
  });

  // Handle new message from client
  socket.on('sendMessage', async (data) => {
    try {
      const { conversationId, content, type = 'text', metadata = null } = data;
      
      if (!conversationId || !content) {
        logger.warn(`Invalid message data from user ${username}: missing conversationId or content`);
        socket.emit('messageError', { error: 'Conversation ID and content are required' });
        return;
      }

      logger.info(`SOCKET: Processing message from user ${userId} in conversation ${conversationId}`);
      
      // Send message and get both user message and AI response
      const { userMessage, aiMessage } = await messageService.sendMessage(
        userId,
        conversationId,
        content,
        type,
        metadata
      );

      // Broadcast user message to all participants in the conversation
      logger.info(`SOCKET: Broadcasting user message ${userMessage.id} to conversation ${conversationId}`);
      io.to(conversationId.toString()).emit('newMessage', userMessage);

      // Broadcast AI message with slight delay to simulate thinking
      if (aiMessage) {
        logger.info(`SOCKET: Broadcasting AI message ${aiMessage.id} to conversation ${conversationId}`);
        setTimeout(() => {
          io.to(conversationId.toString()).emit('newMessage', aiMessage);
        }, 500); // 500ms delay
      }
    } catch (error) {
      logger.error(`Error processing message from user ${username}:`, error);
      socket.emit('messageError', { 
        error: 'Failed to process message', 
        details: error.message 
      });
    }
  });

  // Handle typing indicators
  socket.on('typing', (data) => {
    const { conversationId } = data;
    if (!conversationId) return;
    
    logger.debug(`User ${username} is typing in conversation ${conversationId}`);
    
    // Broadcast typing event to all participants except sender
    socket.to(conversationId.toString()).emit('userTyping', {
      userId,
      username,
      conversationId
    });
  });

  // Handle read receipts
  socket.on('markAsRead', async (data) => {
    try {
      const { conversationId, lastReadMessageId } = data;
      
      if (!conversationId || !lastReadMessageId) {
        logger.warn(`Invalid read receipt data from user ${username}`);
        return;
      }
      
      logger.info(`User ${username} marked messages as read up to ${lastReadMessageId} in conversation ${conversationId}`);
      
      // Update read status in database
      await messageService.markMessagesAsRead(conversationId, userId, lastReadMessageId);
      
      // Broadcast read receipt to all participants
      io.to(conversationId.toString()).emit('messagesRead', {
        userId,
        username,
        conversationId,
        lastReadMessageId
      });
    } catch (error) {
      logger.error(`Error processing read receipt from user ${username}:`, error);
    }
  });
};

module.exports = initializeSocketEventHandlers;
</file>

<file path="socket/events/index.js">
/**
 * Centralized event handlers for WebSocket connections.
 * This function is called when a new authenticated client connects.
 * It registers various event handlers (for messages, user status, etc.) for that client's socket.
 */
const messageHandlers = require('./messageHandlers');
const userHandlers = require('./userHandlers');
const logger = require('../../utils/logger'); // Assuming logger is in 'backend/utils/logger.js'

const onConnection = (io, socket) => {
    // This function is called for each authenticated socket connection
    logger.info(`Setting up event handlers for connected user: ${socket.user.username} (Socket ID: ${socket.id})`);

    // Register message-related event handlers from messageHandlers.js
    messageHandlers(io, socket);

    // Register user-related event handlers (e.g., typing, online status) from userHandlers.js
    userHandlers(io, socket);

    // Example: Generic error handler for this specific socket, if not handled by global io error handler
    // socket.on('error', (error) => {
    //     logger.error(`Socket-specific error for user ${socket.user.username} (Socket ID: ${socket.id}):`, error);
    // });

    // You can also register other general purpose handlers here if needed
    // For example, a custom ping/pong for keep-alive or latency checks
    socket.on('custom_ping', (callback) => {
        logger.debug(`Received custom_ping from ${socket.user.username}, sending custom_pong.`);
        if (typeof callback === 'function') {
            callback({ status: 'ok', timestamp: new Date().toISOString(), fromServer: true });
        }
    });

    // Note: The main 'disconnect' event is typically handled where the 'connection' event is defined (e.g., server.js)
    // to ensure it's always attached. However, specific cleanup related to these handlers can be done here if needed.
};

module.exports = onConnection;
</file>

<file path="socket/events/messageHandlers.js">
/**
 * Handles all message-related WebSocket events.
 * Processes incoming messages, saves them to the database, and broadcasts to recipients.
 * Manages message status updates (e.g., sent, delivered, read).
 */
const { Message, Conversation, User } = require('../../models'); // Assuming models are in backend/models
const logger = require('../../utils/logger'); // Assuming logger is in backend/utils/logger
// const { Op } = require('sequelize'); // Uncomment if needed for complex queries

module.exports = (io, socket) => {
    /**
     * Handles incoming messages from clients.
     * @param {object} data - The message data from the client.
     * Expected structure: { conversationId: string, content: string }
     * @param {function} callback - Acknowledgment callback to the client.
     * Called with { status: 'ok', messageId: string, sentAt: Date } or { status: 'error', message: string }.
     */
    const sendMessage = async (data, callback) => {
        try {
            const { conversationId, content } = data;
            const senderId = socket.user.id; // User ID from authenticated socket (socket.user set by auth middleware)

            if (!conversationId || !content || String(content).trim() === '') {
                logger.warn(`sendMessage: Missing conversationId or content from user ${senderId}. Data: ${JSON.stringify(data)}`);
                if (typeof callback === 'function') callback({ status: 'error', message: 'Conversation ID and content are required.' });
                return;
            }

            // 1. Verify the conversation exists and the user is a participant.
            // This check is crucial for security and data integrity.
            const conversation = await Conversation.findByPk(conversationId, {
                include: [{
                    model: User,
                    as: 'participants',
                    attributes: ['id'],
                    through: { attributes: [] } // We only need to know if the user is a participant.
                }]
            });

            if (!conversation) {
                logger.warn(`sendMessage: Conversation ${conversationId} not found. Attempt by user ${senderId}.`);
                if (typeof callback === 'function') callback({ status: 'error', message: 'Conversation not found.' });
                return;
            }

            const isParticipant = conversation.participants.some(p => p.id === senderId);
            if (!isParticipant) {
                logger.warn(`sendMessage: User ${senderId} (${socket.user.username}) is not a participant of conversation ${conversationId}.`);
                if (typeof callback === 'function') callback({ status: 'error', message: 'Access denied: You are not a participant of this conversation.' });
                return;
            }

            // 2. Create and save the message to the database.
            const message = await Message.create({
                content: String(content).trim(), // Ensure content is a string and trimmed
                senderId,
                conversationId,
                // timestamp: new Date() // Sequelize automatically adds createdAt and updatedAt
            });

            // 3. Fetch the newly created message along with sender details to broadcast.
            // This ensures the broadcasted message has all necessary info for clients to render it.
            const messageWithSender = await Message.findByPk(message.id, {
                include: [{
                    model: User,
                    as: 'sender', // Make sure this alias matches your Message model association
                    attributes: ['id', 'username', 'email'] // Send only necessary, non-sensitive sender info
                }]
            });

            // 4. Broadcast the new message to all clients in the specific conversation room.
            // It's assumed that clients join a room named after the conversationId when they select a conversation.
            const roomName = conversationId.toString();
            io.to(roomName).emit('newMessage', messageWithSender);
            logger.info(`Message from ${socket.user.username} (ID: ${senderId}) sent to conversation ${conversationId}: "${message.content.substring(0, 50)}..."`);

            // 5. Send an acknowledgment callback to the sender.
            if (typeof callback === 'function') {
                callback({ 
                    status: 'ok', 
                    messageId: message.id, 
                    tempId: data.tempId, // Optionally echo back a temporary client-side ID for UI updates
                    sentAt: message.createdAt 
                });
            }

        } catch (error) {
            logger.error(`sendMessage error for user ${socket.user?.id} in conversation ${data?.conversationId}:`, error);
            if (typeof callback === 'function') {
                callback({ status: 'error', message: 'Failed to send message due to a server error.' });
            }
        }
    };

    /**
     * Handles requests to mark messages as read within a conversation.
     * @param {object} data - Data from the client.
     * Expected structure: { conversationId: string, messageId: string (optional, for specific message) or lastReadTimestamp: Date (optional) }
     * @param {function} callback - Acknowledgment callback.
     */
    const markAsRead = async (data, callback) => {
        // Placeholder for 'mark as read' functionality.
        // This would typically involve:
        // 1. Identifying which messages to mark as read (e.g., all messages up to messageId or timestamp).
        // 2. Updating database records (e.g., a 'readBy' field in Message or a separate ReadReceipts table).
        // 3. Broadcasting an event like 'messagesRead' to participants in the conversation,
        //    so their UIs can update read statuses.
        logger.info(`markAsRead event received from ${socket.user.username} for conversation ${data?.conversationId}`, data);
        // Example: io.to(data.conversationId.toString()).emit('messagesRead', { conversationId: data.conversationId, readerId: socket.user.id, messageId: data.messageId });
        if (typeof callback === 'function') callback({ status: 'info', message: 'Read status handling is under development.' });
    };

    // Register event listeners for this socket connection
    socket.on('sendMessage', sendMessage);
    socket.on('markAsRead', markAsRead);

    // TODO: Add handlers for other message-related events such as:
    // socket.on('editMessage', editMessageHandler);
    // socket.on('deleteMessage', deleteMessageHandler);
    // socket.on('messageDelivered', messageDeliveredHandler); // If implementing custom delivery receipts
};
</file>

<file path="socket/events/readReceiptHandlers.js">
// Handles WebSocket events for read receipts and delivery status
</file>

<file path="socket/events/userHandlers.js">
/**
 * Handles user-related WebSocket events such as typing indicators and presence.
 */
const logger = require('../../utils/logger'); // Assuming logger is in backend/utils/logger

// Store typing users: { conversationId: { userId: socketId, ... } }
// This is a simple in-memory store. For a distributed system, use Redis or similar.
const typingUsersByConversation = {}; 

module.exports = (io, socket) => {
    const userId = socket.user.id;
    const username = socket.user.username;

    /**
     * Handles 'typing_start' event from a client.
     * @param {object} data - Data from the client.
     * Expected structure: { conversationId: string }
     */
    const handleUserTypingStart = (data) => {
        const { conversationId } = data;
        if (!conversationId) {
            logger.warn(`User ${username} (ID: ${userId}) sent 'typing_start' without conversationId.`);
            return;
        }

        // Add user to typing list for this conversation
        if (!typingUsersByConversation[conversationId]) {
            typingUsersByConversation[conversationId] = {};
        }
        typingUsersByConversation[conversationId][userId] = socket.id; // Store socket.id if needed for multi-device scenarios

        // Broadcast to other users in the conversation room that this user is typing.
        // The client sending 'typing_start' should not receive this event back from the server.
        socket.to(conversationId.toString()).emit('userTyping', {
            conversationId,
            userId,
            username,
            isTyping: true
        });
        logger.debug(`User ${username} (ID: ${userId}) started typing in conversation ${conversationId}`);
    };

    /**
     * Handles 'typing_stop' event from a client.
     * @param {object} data - Data from the client.
     * Expected structure: { conversationId: string }
     */
    const handleUserTypingStop = (data) => {
        const { conversationId } = data;
        if (!conversationId) {
            logger.warn(`User ${username} (ID: ${userId}) sent 'typing_stop' without conversationId.`);
            return;
        }

        // Remove user from typing list
        if (typingUsersByConversation[conversationId]) {
            delete typingUsersByConversation[conversationId][userId];
            if (Object.keys(typingUsersByConversation[conversationId]).length === 0) {
                delete typingUsersByConversation[conversationId]; // Clean up empty conversation entry
            }
        }

        // Broadcast to other users in the conversation room that this user stopped typing.
        socket.to(conversationId.toString()).emit('userTyping', {
            conversationId,
            userId,
            username,
            isTyping: false
        });
        logger.debug(`User ${username} (ID: ${userId}) stopped typing in conversation ${conversationId}`);
    };

    /**
     * Placeholder for handling user explicitly setting their status (e.g., 'online', 'away', 'offline').
     * This is distinct from basic WebSocket connection/disconnection presence.
     * @param {object} data - Data from the client, e.g., { status: 'away' }
     */
    const handleUserSetStatus = (data) => {
        const { status } = data;
        logger.info(`User ${username} (ID: ${userId}) set status to: ${status}`);
        // TODO: Update user's status in a presence system (e.g., Redis, database)
        // and broadcast this status change to relevant users (e.g., friends, contacts).
        // io.emit('userStatusChanged', { userId, username, status }); // Example broadcast to all
    };

    // Register event listeners for this socket connection
    socket.on('typing_start', handleUserTypingStart);
    socket.on('typing_stop', handleUserTypingStop);
    socket.on('set_user_status', handleUserSetStatus); // Example for explicit status setting

    // Cleanup logic when this specific socket disconnects.
    // This is in addition to the generic 'disconnect' logger in server.js.
    socket.on('disconnect', (reason) => {
        logger.debug(`User handlers: ${username} (ID: ${userId}, Socket ID: ${socket.id}) disconnected. Reason: ${reason}`);
        // If the user was typing in any conversation, emit 'typing_stop' for them.
        for (const conversationId in typingUsersByConversation) {
            if (typingUsersByConversation[conversationId][userId] === socket.id) {
                delete typingUsersByConversation[conversationId][userId];
                 if (Object.keys(typingUsersByConversation[conversationId]).length === 0) {
                    delete typingUsersByConversation[conversationId];
                }
                socket.to(conversationId.toString()).emit('userTyping', {
                    conversationId,
                    userId,
                    username,
                    isTyping: false
                });
                logger.debug(`Auto-stopped typing for ${username} in ${conversationId} due to disconnect.`);
            }
        }
        // TODO: Add more sophisticated presence management if needed (e.g., user has other active sockets).
        // For a simple setup, you might broadcast 'user_offline' to relevant rooms/users.
    });
};
</file>

<file path="socket/index.js">
/**
 * Main WebSocket server configuration and initialization
 * Handles real-time communication between clients using Socket.IO
 * Manages connection events, authentication, and message broadcasting
 */
</file>

<file path="src/api/chat/messages.js">
/**
 * API endpoints for handling chat messages
 * Manages message creation and retrieval
 */

// TODO: Implement:
// - GET /messages - List messages
// - POST /messages - Send new message
// - GET /messages/:id - Get message details
// - DELETE /messages/:id - Delete message
// - GET /messages/history - Get message history

module.exports = {}
</file>

<file path="src/api/chat/rooms.js">
/**
 * API endpoints for managing chat rooms
 * Handles room creation, retrieval, and updates
 */

// TODO: Implement:
// - GET /rooms - List all rooms
// - POST /rooms - Create new room
// - GET /rooms/:id - Get room details
// - DELETE /rooms/:id - Delete room
// - POST /rooms/:id/join - Join room
// - POST /rooms/:id/leave - Leave room

module.exports = {}
</file>

<file path="src/api/controllers/conversationController.js">
/**
 * Handles business logic for conversation-related API requests.
 * Processes user messages, calls the OpenAI service, and formats responses.
 * Implements emotion detection, context management, and personalized responses.
 */
</file>

<file path="src/api/controllers/taskController.js">
/**
 * Handles business logic for task management API requests.
 * Processes task creation, updates, deletion, and retrieval operations.
 * Implements ADHD-specific features like AI-assisted task breakdown and priority suggestions.
 */
</file>

<file path="src/api/controllers/userController.js">
/**
 * Handles business logic for user management API requests.
 * Processes user registration, authentication, profile updates, and preference management.
 * Implements secure password handling and user data validation.
 */
</file>

<file path="src/api/middlewares/auth.js">
/**
 * Authentication middleware to verify user identity and permissions.
 * Validates JWT tokens, checks user authorization, and secures protected routes.
 * Implements proper error handling for authentication failures.
 */
</file>

<file path="src/api/middlewares/errorHandler.js">
/**
 * Global error handling middleware for API requests.
 * Centralizes error processing, logging, and client response formatting.
 * Implements consistent error reporting with appropriate HTTP status codes.
 */
</file>

<file path="src/api/routes/conversationRoutes.js">
/**
 * API endpoints for conversation-related actions.
 * Handles routes for initiating conversations, sending/receiving messages, and managing chat history.
 * Integrates with the OpenAI service to provide AI-powered responses.
 */
</file>

<file path="src/api/routes/taskRoutes.js">
/**
 * API endpoints for task management actions.
 * Handles routes for creating, updating, deleting, and retrieving tasks.
 * Implements ADHD-specific features like task breakdown, priority management, and reminders.
 */
</file>

<file path="src/api/routes/userRoutes.js">
/**
 * API endpoints for user account management.
 * Handles routes for authentication, profile management, and user preferences.
 * Implements secure storage of user data and ADHD-specific preference settings.
 */
</file>

<file path="src/api/socket/socket.js">
/**
 * Socket.IO configuration and connection handling
 * Sets up real-time communication
 */

// TODO: Implement:
// - Socket.IO server setup
// - Connection handling
// - Event registration
// - Room management
// - Error handling

module.exports = {}
</file>

<file path="src/config/database.js">
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: console.log,
  },
  test: {
    username: process.env.TEST_DB_USER || process.env.DB_USER,
    password: process.env.TEST_DB_PASSWORD || process.env.DB_PASSWORD,
    database: process.env.TEST_DB_NAME || `${process.env.DB_NAME}_test`,
    host: process.env.TEST_DB_HOST || process.env.DB_HOST,
    port: process.env.TEST_DB_PORT || process.env.DB_PORT,
    dialect: 'postgres',
    logging: false,
  },
  production: {
    username: process.env.PROD_DB_USER,
    password: process.env.PROD_DB_PASSWORD,
    database: process.env.PROD_DB_NAME,
    host: process.env.PROD_DB_HOST,
    port: process.env.PROD_DB_PORT,
    dialect: 'postgres',
    logging: false,
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false
      }
    }
  }
};
</file>

<file path="src/config/sequelize.js">
const { Sequelize } = require('sequelize');
const config = require('./database');

const env = process.env.NODE_ENV || 'development';
const dbConfig = config[env];

const sequelize = new Sequelize(
  dbConfig.database,
  dbConfig.username,
  dbConfig.password,
  {
    host: dbConfig.host,
    port: dbConfig.port,
    dialect: dbConfig.dialect,
    logging: dbConfig.logging,
    dialectOptions: dbConfig.dialectOptions || {},
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    }
  }
);

// Test the database connection
const testConnection = async () => {
  try {
    await sequelize.authenticate();
    console.log('Database connection has been established successfully.');
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1);
  }
};

module.exports = {
  sequelize,
  testConnection,
  Sequelize
};
</file>

<file path="src/models/ChatRoom.js">
/**
 * Model for managing chat rooms
 * Stores information about chat conversations
 * Handles 1-on-1 and group chat rooms
 */

// TODO: Define ChatRoom schema with:
// - Room ID
// - Participants
// - Created date
// - Last active
// - Room type (1-on-1, group)
// - Room metadata

module.exports = {}
</file>

<file path="src/models/Conversation.js">
module.exports = (sequelize, DataTypes) => {
  const Conversation = sequelize.define('Conversation', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    // Timestamps
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
  }, {
    timestamps: true,
    underscored: true,
    tableName: 'conversations',
  });

  return Conversation;
};
</file>

<file path="src/models/EmotionalState.js">
/**
 * Data model for tracking user emotional states over time.
 * Stores detected emotions, sentiment scores, and associated timestamps.
 * Enables analysis of emotional patterns to adapt coaching approaches.
 */
</file>

<file path="src/models/index.js">
const { sequelize, Sequelize } = require('../config/sequelize');
const db = {};

db.Sequelize = Sequelize;
db.sequelize = sequelize;

// Import models
const User = require('./User');
const Message = require('./Message');
const Conversation = require('./Conversation');

// Initialize models
db.User = User(sequelize, Sequelize);
db.Message = Message(sequelize, Sequelize);
db.Conversation = Conversation(sequelize, Sequelize);

// Define relationships
const { User: UserModel, Message: MessageModel, Conversation: ConversationModel } = db;

// User has many Messages (as sender)
UserModel.hasMany(MessageModel, {
  foreignKey: 'senderId',
  as: 'sentMessages'
});

// Message belongs to User (sender)
MessageModel.belongsTo(UserModel, {
  foreignKey: 'senderId',
  as: 'sender'
});

// Conversation has many Messages
ConversationModel.hasMany(MessageModel, {
  foreignKey: 'conversationId',
  as: 'messages'
});

// Message belongs to Conversation
MessageModel.belongsTo(ConversationModel, {
  foreignKey: 'conversationId',
  as: 'conversation'
});

// User belongs to many Conversations (Participants)
UserModel.belongsToMany(ConversationModel, {
  through: 'UserConversations',
  as: 'conversations',
  foreignKey: 'userId'
});

// Conversation belongs to many Users (Participants)
ConversationModel.belongsToMany(UserModel, {
  through: 'UserConversations',
  as: 'participants',
  foreignKey: 'conversationId'
});

module.exports = db;
</file>

<file path="src/models/Message.js">
module.exports = (sequelize, DataTypes) => {
  const Message = sequelize.define('Message', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false,
    },
    senderId: {
      type: DataTypes.UUID,
      allowNull: false,
      // References will be set up in models/index.js
    },
    conversationId: {
      type: DataTypes.UUID,
      allowNull: false,
      // References will be set up in models/index.js
    },
    isRead: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    },
    // Timestamps
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
  }, {
    timestamps: true,
    underscored: true,
    tableName: 'messages',
  });

  return Message;
};
</file>

<file path="src/models/Task.js">
/**
 * Data model for tasks and to-do items.
 * Defines schema, validation, and methods for task-related data.
 * Implements ADHD-specific task properties like difficulty rating, estimated time, and priority level.
 */
</file>

<file path="src/models/User.js">
const bcrypt = require('bcryptjs');

module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        notEmpty: true,
        len: [3, 30],
      },
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true,
      },
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true,
        len: [8, 100], // Minimum 8 characters for password
      },
    },
    firstName: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    lastName: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    // Timestamps
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
    },
  }, {
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
      },
      beforeUpdate: async (user) => {
        if (user.changed('password')) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
      },
    },
    timestamps: true, // Enables createdAt and updatedAt
    underscored: true, // Use snake_case for automatically generated attributes (e.g., foreign keys)
    tableName: 'users' // Explicitly define table name
  });

  // Instance method to compare passwords
  User.prototype.isValidPassword = async function (password) {
    return bcrypt.compare(password, this.password);
  };

  return User;
};
</file>

<file path="src/services/ai/adaptiveCoaching.js">
/**
 * Service that adapts coaching strategies based on user behavior and needs.
 * Analyzes user patterns, response effectiveness, and emotional state to personalize coaching.
 * Implements ADHD-specific adaptive techniques like motivation adjustment and focus strategies.
 */
</file>

<file path="src/services/ai/chatService.js">
/**
 * Service for handling AI chat functionality
 * Integrates with OpenAI's GPT-4 for generating responses
 * Manages conversation context and personalization
 */

// TODO: Implement:
// - GPT-4 integration
// - Context management
// - Response generation
// - Emotion-aware responses
// - Personalization based on user profile

module.exports = {}
</file>

<file path="src/services/ai/emotionDetection.js">
/**
 * Service for detecting and analyzing user emotions from text.
 * Leverages OpenAI API to identify emotional states, sentiment, and tone.
 * Provides insights to help tailor coaching approaches based on the user's emotional state.
 */
</file>

<file path="src/services/ai/languageModel.js">
/**
 * Service for interacting with the OpenAI language model.
 * Handles prompt formatting, API requests, and response processing.
 * Implements optimizations for token usage and context management.
 */
</file>

<file path="src/services/chat/messageService.js">
/**
 * Service for handling chat messages
 * Manages message creation, retrieval, and updates
 * Handles message history and context
 */

// TODO: Implement:
// - Message creation
// - Message retrieval
// - Message updates
// - Message deletion
// - Message history management

module.exports = {}
</file>

<file path="src/services/chat/roomService.js">
/**
 * Service for managing chat rooms
 * Handles room creation, joining, and management
 * Manages participant tracking and room state
 */

// TODO: Implement:
// - Room creation
// - Room joining/leaving
// - Participant management
// - Room state tracking
// - Room metadata management

module.exports = {}
</file>

<file path="src/services/socket/socketService.js">
/**
 * Service for handling WebSocket connections
 * Manages Socket.IO connections and events
 * Handles real-time communication
 */

// TODO: Implement:
// - Socket connection management
// - Event handling
// - Room joining/leaving
// - Message broadcasting
// - Presence detection

module.exports = {}
</file>

<file path="src/services/task/reminderService.js">
/**
 * Service for managing task reminders and notifications.
 * Handles scheduling, delivery, and tracking of time-based alerts.
 * Implements ADHD-friendly reminder strategies like multiple cues and adaptive timing.
 */
</file>

<file path="src/services/task/taskBreakdown.js">
/**
 * Service for breaking down complex tasks into manageable steps.
 * Uses AI to analyze task complexity and create appropriate substeps.
 * Implements ADHD coaching strategies for task decomposition and sequencing.
 */
</file>

<file path="src/services/user/preferencesService.js">
/**
 * Service for managing user preferences and settings.
 * Handles storage and retrieval of personalized app configurations.
 * Implements ADHD-specific settings like notification preferences, UI complexity, and coaching intensity.
 */
</file>

<file path="src/services/user/profileService.js">
/**
 * Service for managing user profile information.
 * Handles creation, retrieval, updating, and deletion of user profiles.
 * Implements secure data handling and validation for personal information.
 */
</file>

<file path="src/utils/chatUtils.js">
/**
 * Utility functions for chat functionality
 * Provides helper methods for common operations
 */

// TODO: Implement:
// - Message formatting
// - Time utilities
// - Room utilities
// - Validation helpers
// - Error handling

module.exports = {}
</file>

<file path="src/utils/logger.js">
const winston = require('winston');
const { combine, timestamp, printf, colorize, align } = winston.format;

// Define log format
const logFormat = printf(({ level, message, timestamp, ...metadata }) => {
  let msg = `${timestamp} [${level}]: ${message} `;
  if (Object.keys(metadata).length > 0) {
    msg += JSON.stringify(metadata);
  }
  return msg;
});

// Create logger instance
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: combine(
    colorize({ all: true }),
    timestamp({
      format: 'YYYY-MM-DD hh:mm:ss.SSS A',
    }),
    align(),
    logFormat
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    })
  ],
  exitOnError: false
});

// Create logs directory if it doesn't exist
const fs = require('fs');
const path = require('path');
const logsDir = path.join(__dirname, '../../logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir);
}

module.exports = logger;
</file>

<file path="utils/errorHandler.js">
// Custom error handling middleware for API routes
</file>

<file path="utils/errors.js">
/**
 * Custom Error Classes
 * 
 * Defines custom error classes for different types of application errors.
 * Provides consistent error handling and formatting.
 * 
 * @module utils/errors
 * @requires http-status-codes
 * 
 * @example
 * // Example usage:
 * const { NotFoundError, ValidationError, BadRequestError } = require('../utils/errors');
 * throw new NotFoundError('User not found');
 * throw new ValidationError('Invalid input', { field: 'email' });
 * throw new BadRequestError('Invalid request');
 */

// File implemented with custom error classes:
// 1. ApiError - Base error class
// 2. NotFoundError - 404 errors
// 3. ValidationError - 400 errors
// 4. UnauthorizedError - 401 errors
// 5. ForbiddenError - 403 errors
// 6. ConflictError - 409 errors
// 7. BadRequestError - 400 errors

// Implementation includes proper error serialization and status codes

const httpStatus = require('http-status-codes');

/**
 * Base API Error class that all other error classes extend.
 * Sets up common properties for all API errors.
 */
class ApiError extends Error {
  constructor(
    message = 'An error occurred',
    statusCode = httpStatus.INTERNAL_SERVER_ERROR,
    isOperational = true,
    stack = ''
  ) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = isOperational;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * 400 Bad Request Error
 * Used when the server cannot process the request due to client error.
 */
class BadRequestError extends ApiError {
  constructor(message = 'Bad Request') {
    super(message, httpStatus.BAD_REQUEST);
  }
}

/**
 * 401 Unauthorized Error
 * Used when authentication is required but has failed or not been provided.
 */
class UnauthorizedError extends ApiError {
  constructor(message = 'Unauthorized') {
    super(message, httpStatus.UNAUTHORIZED);
  }
}

/**
 * 403 Forbidden Error
 * Used when the user doesn't have permission to access a resource.
 */
class ForbiddenError extends ApiError {
  constructor(message = 'Forbidden') {
    super(message, httpStatus.FORBIDDEN);
  }
}

/**
 * 404 Not Found Error
 * Used when a requested resource is not found.
 */
class NotFoundError extends ApiError {
  constructor(message = 'Resource not found') {
    super(message, httpStatus.NOT_FOUND);
  }
}

/**
 * 409 Conflict Error
 * Used when a request conflicts with the current state of the server.
 */
class ConflictError extends ApiError {
  constructor(message = 'Conflict') {
    super(message, httpStatus.CONFLICT);
  }
}

/**
 * 422 Validation Error
 * Used when request data fails validation.
 */
class ValidationError extends ApiError {
  constructor(message = 'Validation Error', errors = []) {
    super(message, httpStatus.UNPROCESSABLE_ENTITY);
    this.errors = errors;
  }
}

module.exports = {
  ApiError,
  BadRequestError,
  UnauthorizedError,
  ForbiddenError,
  NotFoundError,
  ConflictError,
  ValidationError
};
</file>

<file path="utils/logger.js">
/**
 * Logger Utility
 *
 * Centralized logging service for the application.
 * Supports different log levels and transports (console, file, etc.).
 *
 * @module utils/logger
 * @requires winston
 * @requires winston-daily-rotate-file
 */

const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const path = require('path');

const { combine, timestamp, printf, colorize, align, json } = winston.format;

// Define the log directory
const logDirectory = path.join(__dirname, '../logs');

// Custom log format
const logFormat = printf(({ level, message, timestamp: ts, stack }) => {
  return `${ts} ${level}: ${stack || message}`;
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info', // Default to 'info'
  format: combine(
    colorize({ all: true }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    align(),
    logFormat
  ),
  transports: [
    new winston.transports.Console(),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'application-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m', // Max size of each log file
      maxFiles: '14d', // Keep logs for 14 days
      format: combine(timestamp(), json()), // File logs in JSON format
      level: 'debug', // Log debug and above to file
    }),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: combine(timestamp(), json()),
      level: 'error', // Log only errors to this file
    }),
  ],
  exceptionHandlers: [
    new winston.transports.Console({
      format: combine(colorize(), timestamp(), align(), logFormat),
    }),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'exceptions-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: combine(timestamp(), json()),
    }),
  ],
  rejectionHandlers: [ // Handle unhandled promise rejections
    new winston.transports.Console({
      format: combine(colorize(), timestamp(), align(), logFormat),
    }),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'rejections-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: combine(timestamp(), json()),
    }),
  ],
  exitOnError: false, // Do not exit on handled exceptions
});

// Create a stream object with a 'write' function that will be used by morgan
logger.stream = {
  write: function(message, encoding) {
    // use the 'info' log level so the output will be picked up by both transports
    logger.info(message.trim());
  },
};

module.exports = logger;
</file>

<file path="utils/socketUtils.js">
// Helper functions for WebSocket operations and room management
</file>

<file path="utils/validators.js">
/**
 * Validation Utilities
 * 
 * Centralized validation schemas and helper functions.
 * Uses Joi for schema validation and custom validation logic.
 * 
 * @module utils/validators
 * @requires joi
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { validateEmail, userSchema } = require('../utils/validators');
 * await validateEmail(email);
 * const { error, value } = userSchema.validate(userData);
 */

// File will be implemented with:
// 1. Common validation schemas (email, password, etc.)
// 2. Custom validation functions
// 3. Schema validation middleware
// 4. Request parameter validation
// 5. Error message formatting

// Implementation will include proper error handling and schema definitions
</file>

</files>
