This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
backend/__tests__/__factories__/conversationFactory.js
backend/__tests__/__factories__/messageFactory.js
backend/__tests__/__factories__/userFactory.js
backend/__tests__/__helpers__/testSetup.js
backend/__tests__/__helpers__/testUtils.js
backend/__tests__/integration/api/conversations.test.js
backend/__tests__/integration/api/messages.test.js
backend/__tests__/integration/api/participants.test.js
backend/__tests__/unit/middleware/validators/conversationValidator.test.js
backend/__tests__/unit/middleware/validators/messageValidator.test.js
backend/__tests__/unit/middleware/validators/participantValidator.test.js
backend/__tests__/unit/services/conversationService.test.js
backend/__tests__/unit/services/messageService.test.js
backend/__tests__/unit/services/participantService.test.js
backend/.env.example
backend/.sequelizerc
backend/config/config.js
backend/config/config.json
backend/config/passport.js
backend/controllers/aiChatController.js
backend/controllers/authController.js
backend/controllers/chatController.js
backend/controllers/conversationController.js
backend/controllers/messageController.js
backend/controllers/participantController.js
backend/controllers/taskController.js
backend/controllers/userController.js
backend/docs/api-specification.yml
backend/middleware/auth.js
backend/middleware/authMiddleware.js
backend/middleware/authValidators.js
backend/middleware/errorHandler.js
backend/middleware/validation.js
backend/middleware/validators/commonValidator.js
backend/middleware/validators/conversationValidator.js
backend/middleware/validators/messageValidator.js
backend/middleware/validators/participantValidator.js
backend/middleware/websocket/auth.js
backend/middleware/websocket/errorHandler.js
backend/migrations/20250516003134-create-users.js
backend/migrations/20250516003411-create-conversations.js
backend/migrations/20250516003459-create-messages.js
backend/migrations/20250516003800-create-user-conversation.js
backend/migrations/20250516052212-add-auth-fields-to-user.js
backend/migrations/20250516090000-add-missing-user-columns.js
backend/migrations/20250516090001-update-conversations-table.js
backend/migrations/20250516234001-add-parent-message-id-to-messages.js
backend/migrations/20250516234933-add-metadata-to-messages.js
backend/models/Conversation.js
backend/models/index.js
backend/models/Message.js
backend/models/Task.js
backend/models/User.js
backend/models/UserConversation.js
backend/package.json
backend/README.md
backend/routes/aiChat.js
backend/routes/api/conversations.js
backend/routes/api/messages.js
backend/routes/api/participants.js
backend/routes/auth.js
backend/routes/authRoutes.js
backend/routes/conversations.js
backend/routes/messages.js
backend/routes/participants.js
backend/routes/tasks.js
backend/routes/users.js
backend/scripts/check-schema.js
backend/scripts/checkDbStructure.js
backend/scripts/createSpecificUser.js
backend/scripts/debugConversationModel.js
backend/scripts/mark-migration-complete.js
backend/scripts/update-test-user-email.js
backend/seeders/20250516164510-add-test-user.js
backend/seeders/20250516164600-add-test-user-seed.js
backend/seeders/createTestUser.js
backend/server.js
backend/services/aiChatService.js
backend/services/aiService.js
backend/services/authService.js
backend/services/chatService.js
backend/services/conversationService.js
backend/services/messageService.js
backend/services/participantService.js
backend/services/socketService.js
backend/services/taskService.js
backend/socket/events.js
backend/socket/events/index.js
backend/socket/events/messageHandlers.js
backend/socket/events/userHandlers.js
backend/socket/index.js
backend/utils/errorHandler.js
backend/utils/errors.js
backend/utils/logger.js
backend/utils/socketUtils.js
backend/utils/validators.js
frontend/package.json
frontend/public/index.html
frontend/src/App.js
frontend/src/components/chat/ChatWindow.js
frontend/src/components/chat/ConversationList.js
frontend/src/components/chat/Message.js
frontend/src/components/chat/MessageInput.js
frontend/src/components/chat/MessageList.js
frontend/src/components/chat/TypingIndicator.js
frontend/src/components/common/Button.jsx
frontend/src/components/common/Input.jsx
frontend/src/components/common/Navbar.js
frontend/src/components/common/PrivateRoute.js
frontend/src/components/layout/Header.jsx
frontend/src/components/layout/Layout.jsx
frontend/src/config/constants.js
frontend/src/context/AuthContext.jsx
frontend/src/contexts/ChatContext.js
frontend/src/hooks/useChat.js
frontend/src/index.js
frontend/src/pages/auth/Login.jsx
frontend/src/pages/auth/Register.jsx
frontend/src/pages/ChatPage.js
frontend/src/pages/dashboard/Dashboard.jsx
frontend/src/pages/LoginPage.js
frontend/src/pages/RegisterPage.js
frontend/src/routes/PrivateRoute.jsx
frontend/src/services/api.js
frontend/src/services/apiService.js
frontend/src/services/authService.js
frontend/src/services/socketService.js
frontend/src/utils/validators.js
LICENSE
mobile-app/.eslintrc.js
mobile-app/.git/COMMIT_EDITMSG
mobile-app/.git/config
mobile-app/.git/description
mobile-app/.git/HEAD
mobile-app/.git/hooks/applypatch-msg.sample
mobile-app/.git/hooks/commit-msg.sample
mobile-app/.git/hooks/fsmonitor-watchman.sample
mobile-app/.git/hooks/post-update.sample
mobile-app/.git/hooks/pre-applypatch.sample
mobile-app/.git/hooks/pre-commit.sample
mobile-app/.git/hooks/pre-merge-commit.sample
mobile-app/.git/hooks/pre-push.sample
mobile-app/.git/hooks/pre-rebase.sample
mobile-app/.git/hooks/pre-receive.sample
mobile-app/.git/hooks/prepare-commit-msg.sample
mobile-app/.git/hooks/push-to-checkout.sample
mobile-app/.git/hooks/sendemail-validate.sample
mobile-app/.git/hooks/update.sample
mobile-app/.git/info/exclude
mobile-app/.git/logs/HEAD
mobile-app/.git/logs/refs/heads/Beginning
mobile-app/.git/logs/refs/heads/main
mobile-app/.git/logs/refs/remotes/origin/main
mobile-app/.git/refs/heads/Beginning
mobile-app/.git/refs/heads/main
mobile-app/.git/refs/remotes/origin/main
mobile-app/.gitignore
mobile-app/.husky/pre-commit
mobile-app/.lintstagedrc
mobile-app/.prettierrc
mobile-app/app.json
mobile-app/App.tsx
mobile-app/index.ts
mobile-app/package.json
mobile-app/src/App.tsx
mobile-app/src/components/common/Button.tsx
mobile-app/src/components/common/Card.tsx
mobile-app/src/components/common/FloatingActionButton.tsx
mobile-app/src/components/common/Input.tsx
mobile-app/src/components/common/Modal.tsx
mobile-app/src/components/tasks/TaskFilterBar.tsx
mobile-app/src/components/tasks/TaskForm.tsx
mobile-app/src/components/tasks/TaskItem.tsx
mobile-app/src/components/tasks/TaskList.tsx
mobile-app/src/config/api.ts
mobile-app/src/hooks/useAuth.ts
mobile-app/src/navigation/AppNavigator.tsx
mobile-app/src/navigation/ChatStackNavigator.tsx
mobile-app/src/navigation/types.ts
mobile-app/src/screens/Chat/ChatScreen.tsx
mobile-app/src/screens/Chat/ChatScreen.tsx.new
mobile-app/src/screens/Settings/SettingsScreen.tsx
mobile-app/src/screens/Tamagotchi/TamagotchiScreen.tsx
mobile-app/src/screens/TasksScreen.tsx
mobile-app/src/screens/WebScreen.js
mobile-app/src/services/apiService.ts
mobile-app/src/services/socketService.ts
mobile-app/src/store/actions/taskActions.ts
mobile-app/src/store/rootReducer.ts
mobile-app/src/store/selectors/taskSelectors.ts
mobile-app/src/store/slices/authSlice.ts
mobile-app/src/store/slices/chatSlice.ts
mobile-app/src/store/slices/tamagotchiSlice.ts
mobile-app/src/store/slices/tasksSlice.ts
mobile-app/src/store/store.ts
mobile-app/src/theme/index.ts
mobile-app/src/types/task.ts
mobile-app/tsconfig.json
package.json
project_documentation.md
README.md
test-login.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="mobile-app/.eslintrc.js">
module.exports = {
  extends: ['eslint:recommended', 'plugin:react/recommended', '@react-native-community'],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint', 'react', 'react-hooks'],
  root: true,
  rules: {
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',
    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
};
</file>

<file path="mobile-app/.git/COMMIT_EDITMSG">
Initial commit: Set up mobile app with React Native and TypeScript
</file>

<file path="mobile-app/.git/config">
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
	hooksPath = .husky/_
[remote "origin"]
	url = https://github.com/ldl7/322_final.git
	fetch = +refs/heads/*:refs/remotes/origin/*
</file>

<file path="mobile-app/.git/description">
Unnamed repository; edit this file 'description' to name the repository.
</file>

<file path="mobile-app/.git/HEAD">
ref: refs/heads/Beginning
</file>

<file path="mobile-app/.git/hooks/applypatch-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
</file>

<file path="mobile-app/.git/hooks/commit-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
</file>

<file path="mobile-app/.git/hooks/fsmonitor-watchman.sample">
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
</file>

<file path="mobile-app/.git/hooks/post-update.sample">
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
</file>

<file path="mobile-app/.git/hooks/pre-applypatch.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
</file>

<file path="mobile-app/.git/hooks/pre-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
</file>

<file path="mobile-app/.git/hooks/pre-merge-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
</file>

<file path="mobile-app/.git/hooks/pre-push.sample">
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
</file>

<file path="mobile-app/.git/hooks/pre-rebase.sample">
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
</file>

<file path="mobile-app/.git/hooks/pre-receive.sample">
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
</file>

<file path="mobile-app/.git/hooks/prepare-commit-msg.sample">
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
</file>

<file path="mobile-app/.git/hooks/push-to-checkout.sample">
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
</file>

<file path="mobile-app/.git/hooks/sendemail-validate.sample">
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi
</file>

<file path="mobile-app/.git/hooks/update.sample">
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
</file>

<file path="mobile-app/.git/info/exclude">
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</file>

<file path="mobile-app/.git/logs/HEAD">
0000000000000000000000000000000000000000 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243437 -0400	commit (initial): Initial commit: Set up mobile app with React Native and TypeScript
c302775d23fecea7502c66755137befb69b135c3 0000000000000000000000000000000000000000 ldl7 <ldl7@njit.edu> 1747243443 -0400	Branch: renamed refs/heads/Beginning to refs/heads/main
0000000000000000000000000000000000000000 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243443 -0400	Branch: renamed refs/heads/Beginning to refs/heads/main
c302775d23fecea7502c66755137befb69b135c3 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243723 -0400	checkout: moving from main to Beginning
</file>

<file path="mobile-app/.git/logs/refs/heads/Beginning">
0000000000000000000000000000000000000000 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243723 -0400	branch: Created from HEAD
</file>

<file path="mobile-app/.git/logs/refs/heads/main">
0000000000000000000000000000000000000000 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243437 -0400	commit (initial): Initial commit: Set up mobile app with React Native and TypeScript
c302775d23fecea7502c66755137befb69b135c3 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243443 -0400	Branch: renamed refs/heads/Beginning to refs/heads/main
</file>

<file path="mobile-app/.git/logs/refs/remotes/origin/main">
0000000000000000000000000000000000000000 c302775d23fecea7502c66755137befb69b135c3 ldl7 <ldl7@njit.edu> 1747243823 -0400	update by push
</file>

<file path="mobile-app/.git/refs/heads/Beginning">
c302775d23fecea7502c66755137befb69b135c3
</file>

<file path="mobile-app/.git/refs/heads/main">
c302775d23fecea7502c66755137befb69b135c3
</file>

<file path="mobile-app/.git/refs/remotes/origin/main">
c302775d23fecea7502c66755137befb69b135c3
</file>

<file path="mobile-app/.gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# Expo specific
.expo/
dist/
web-build/

# macOS
.DS_Store

# Editor-specific
*.code-workspace
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env
.env.*
!/.env.example

# Others
*.local
</file>

<file path="mobile-app/.husky/pre-commit">
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged
</file>

<file path="mobile-app/.lintstagedrc">
{
  "*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"],
  "*.{json,md,yml,yaml}": ["prettier --write"]
}
</file>

<file path="mobile-app/.prettierrc">
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80
}
</file>

<file path="mobile-app/app.json">
{
  "expo": {
    "name": "mobile-app",
    "slug": "mobile-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true,
      "infoPlist": {
        "NSAppTransportSecurity": {
          "NSAllowsArbitraryLoads": true
        }
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "allowBackup": true,
      "usesCleartextTraffic": true
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": ["expo-sqlite"],
    "packagerOpts": {
      "port": 8082
    }
  }
}
</file>

<file path="mobile-app/App.tsx">
import React, { useEffect } from 'react';
import { Provider as StoreProvider, useDispatch, useSelector } from 'react-redux';
import { Provider as PaperProvider } from 'react-native-paper';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { NavigationContainer } from '@react-navigation/native';
import { store } from './src/store/store';
import AppNavigator from './src/navigation/AppNavigator';
import { checkAuthState } from './src/store/slices/authSlice';
import { RootState } from './src/store/store';

// Check for existing auth state when app starts
const AppContent = () => {
  const dispatch = useDispatch();
  const { isAuthenticated, loading } = useSelector((state: RootState) => state.auth);

  useEffect(() => {
    // Check if user is already authenticated (token in AsyncStorage)
    dispatch(checkAuthState() as any);
    console.log('App started - checking authentication state');
  }, [dispatch]);

  return (
    <SafeAreaProvider>
      <PaperProvider>
        <NavigationContainer>
          <AppNavigator />
        </NavigationContainer>
      </PaperProvider>
    </SafeAreaProvider>
  );
};

export default function App() {
  return (
    <StoreProvider store={store}>
      <AppContent />
    </StoreProvider>
  );
}
</file>

<file path="mobile-app/index.ts">
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
</file>

<file path="mobile-app/package.json">
{
  "name": "mobile-app",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "prepare": "husky"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.1.0",
    "@react-native-async-storage/async-storage": "2.1.2",
    "@react-native-community/datetimepicker": "8.3.0",
    "@react-native-community/netinfo": "11.4.1",
    "@react-native-picker/picker": "^2.11.0",
    "@react-navigation/bottom-tabs": "^7.3.13",
    "@react-navigation/native": "^7.1.9",
    "@react-navigation/native-stack": "^7.3.13",
    "@reduxjs/toolkit": "^2.8.1",
    "@types/date-fns": "^2.5.3",
    "@types/react-native-vector-icons": "^6.4.18",
    "@types/react-redux": "^7.1.34",
    "axios": "^1.9.0",
    "date-fns": "^4.1.0",
    "expo": "~53.0.9",
    "expo-constants": "~17.1.6",
    "expo-notifications": "~0.31.1",
    "expo-sqlite": "~15.2.9",
    "expo-status-bar": "~2.2.3",
    "react": "19.0.0",
    "react-native": "0.79.2",
    "react-native-calendars": "^1.1312.0",
    "react-native-paper": "^5.14.3",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.10.0",
    "react-native-vector-icons": "^10.2.0",
    "react-native-webview": "13.13.5",
    "react-redux": "^9.2.0",
    "socket.io-client": "^4.6.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@react-native-community/cli": "^13.5.2",
    "@types/react": "~19.0.10",
    "@types/socket.io-client": "^1.4.36",
    "eslint": "^9.26.0",
    "husky": "^9.1.7",
    "lint-staged": "^16.0.0",
    "prettier": "^3.5.3",
    "typescript": "~5.8.3"
  },
  "private": true
}
</file>

<file path="mobile-app/src/App.tsx">
import React from 'react';
import { Provider as StoreProvider } from 'react-redux';
import { Provider as PaperProvider, DefaultTheme } from 'react-native-paper';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { NavigationContainer } from '@react-navigation/native';
import { store } from './store/store';
import AppNavigator from './navigation/AppNavigator';

const theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    primary: 'tomato',
    accent: 'yellow',
  },
};

export default function App() {
  return (
    <StoreProvider store={store}>
      <PaperProvider theme={theme}>
        <SafeAreaProvider>
          <NavigationContainer>
            <AppNavigator />
          </NavigationContainer>
        </SafeAreaProvider>
      </PaperProvider>
    </StoreProvider>
  );
}
</file>

<file path="mobile-app/src/components/common/Button.tsx">
/**
 * Button.tsx
 * 
 * A reusable button component that follows design system guidelines.
 * 
 * Features:
 * - Multiple variants (primary, secondary, outlined, text)
 * - Size options (small, medium, large)
 * - Support for icons (left, right, icon-only)
 * - Loading state with appropriate visual feedback
 * - Disabled state handling
 * - Consistent styling across the application
 * - Accessibility features (proper labeling, touch targets)
 * 
 * This component extends React Native Paper's Button component
 * with custom styling and additional functionality.
 */

// Button.tsx - Button component will go here
</file>

<file path="mobile-app/src/components/common/Card.tsx">
/**
 * Card.tsx
 * 
 * A reusable card component that provides a consistent container for content.
 * 
 * Features:
 * - Multiple elevation levels for depth hierarchy
 * - Optional header and footer sections
 * - Support for custom content layouts
 * - Configurable padding and margins
 * - Border radius customization
 * - Shadow styling appropriate for both light and dark themes
 * - Optional action buttons
 * - Support for touch interactions
 * 
 * This component extends React Native Paper's Card component
 * with application-specific styling and enhancements.
 */

// Card.tsx - Card component will go here
</file>

<file path="mobile-app/src/components/common/FloatingActionButton.tsx">
/**
 * FloatingActionButton.tsx
 *
 * A reusable floating action button component that appears in the bottom-right corner
 * of the screen, typically used for primary actions like creating a new item.
 * 
 * Features:
 * - Customizable icon and color
 * - Accessibility support with proper labeling
 * - Ripple effect feedback on press
 * - Optional badge for notifications
 * - Support for different sizes (small, medium, large)
 * 
 * Usage:
 * <FloatingActionButton 
 *   onPress={() => handleAddTask()}
 *   iconName="plus" 
 *   iconColor="#fff"
 *   backgroundColor="#4a90e2"
 *   size={60}
 *   accessibilityLabel="Create new task"
 * />
 */

import React from 'react';
import { TouchableOpacity, StyleSheet, ViewStyle, StyleProp, GestureResponderEvent } from 'react-native';
import { Ionicons } from '@expo/vector-icons'; 

interface FloatingActionButtonProps {
  onPress: (event: GestureResponderEvent) => void;
  iconName: keyof typeof Ionicons.glyphMap; 
  iconColor?: string;
  backgroundColor?: string;
  size?: number;
  style?: StyleProp<ViewStyle>;
  accessibilityLabel: string;
  disabled?: boolean;
}

const FloatingActionButton: React.FC<FloatingActionButtonProps> = ({
  onPress,
  iconName,
  iconColor = '#fff',
  backgroundColor = '#007AFF', 
  size = 60,
  style,
  accessibilityLabel,
  disabled = false,
}) => {
  const buttonStyle: StyleProp<ViewStyle> = [
    styles.fab,
    { 
      width: size, 
      height: size, 
      borderRadius: size / 2, 
      backgroundColor 
    },
    disabled && styles.disabled,
    style,
  ];

  const iconSize = size * 0.5;

  return (
    <TouchableOpacity
      style={buttonStyle}
      onPress={onPress}
      activeOpacity={0.7}
      accessibilityLabel={accessibilityLabel}
      accessibilityRole="button"
      accessibilityState={{ disabled }}
      disabled={disabled}
    >
      <Ionicons name={iconName} size={iconSize} color={iconColor} />
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  fab: {
    position: 'absolute',
    right: 20,
    bottom: 20,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 8, 
    shadowColor: '#000', 
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
  },
  disabled: {
    backgroundColor: '#A9A9A9', 
    opacity: 0.7,
  },
});

export default FloatingActionButton;
</file>

<file path="mobile-app/src/components/common/Input.tsx">
/**
 * Input.tsx
 * 
 * A reusable text input component that follows design system guidelines.
 * 
 * Features:
 * - Multiple input types (text, email, password, number)
 * - Form validation integration
 * - Error state display with helpful messages
 * - Optional label and placeholder text
 * - Icon support (leading and trailing)
 * - Character count and max length handling
 * - Accessibility features (proper labeling, hints)
 * 
 * This component extends React Native Paper's TextInput component
 * with consistent styling and enhanced functionality.
 */

// Input.tsx - Input component will go here
</file>

<file path="mobile-app/src/components/common/Modal.tsx">
/**
 * Modal.tsx
 *
 * A reusable modal component that displays content over the current screen.
 * This component follows React Native best practices and SOLID principles.
 * 
 * Features:
 * - Backdrop with customizable opacity and color
 * - Animated entrance and exit transitions (via React Native's Modal component)
 * - Support for different modal positions (center, bottom, top) - Centered by default for this implementation
 * - Close on backdrop tap option
 * - Hardware back button handling (Android - via React Native's Modal component)
 * - Keyboard avoiding behavior (can be added by wrapping children with KeyboardAvoidingView)
 * - Accessibility support with proper focus management (leveraging React Native's Modal)
 * - Compatible with both portrait and landscape orientations
 * 
 * Performance Considerations:
 * - Uses React.memo to prevent unnecessary re-renders if props are stable.
 * - Leverages the optimized React Native Modal component.
 * 
 * Error Handling:
 * - Parent component is responsible for error boundaries around children.
 * 
 * Usage:
 * <Modal
 *   visible={isModalVisible}
 *   onClose={() => setModalVisible(false)}
 *   animationType="fade"
 *   closeOnBackdropPress={true}
 * >
 *   <View style={styles.modalContentExample}> // Example style for content
 *     <Text>Your modal content goes here</Text>
 *     <Button title="Close" onPress={() => setModalVisible(false)} />
 *   </View>
 * </Modal>
 */

import React from 'react';
import {
  Modal as ReactNativeModal,
  View,
  StyleSheet,
  TouchableWithoutFeedback,
  StyleProp,
  ViewStyle,
  Keyboard,
  Platform,
} from 'react-native';

interface ModalProps {
  visible: boolean;
  onClose: () => void;
  children: React.ReactNode;
  animationType?: 'none' | 'slide' | 'fade';
  transparent?: boolean;
  closeOnBackdropPress?: boolean;
  backdropColor?: string;
  backdropOpacity?: number;
  containerStyle?: StyleProp<ViewStyle>; // Style for the view that centers the content box
  contentStyle?: StyleProp<ViewStyle>;   // Style for the actual content box
}

const Modal: React.FC<ModalProps> = React.memo(
  ({
    visible,
    onClose,
    children,
    animationType = 'fade',
    transparent = true,
    closeOnBackdropPress = true,
    backdropColor = 'black',
    backdropOpacity = 0.5,
    containerStyle,
    contentStyle,
  }) => {
    const handleBackdropPress = () => {
      if (closeOnBackdropPress) {
        Keyboard.dismiss(); // Dismiss keyboard if open
        onClose();
      }
    };

    return (
      <ReactNativeModal
        visible={visible}
        onRequestClose={onClose} // Handles Android back button
        animationType={animationType}
        transparent={transparent}
        statusBarTranslucent // Allows modal to go over status bar
      >
        <TouchableWithoutFeedback onPress={handleBackdropPress} accessible={false}>
          <View 
            style={[
              styles.backdrop,
              { backgroundColor: backdropColor, opacity: backdropOpacity },
            ]}
          />
        </TouchableWithoutFeedback>
        
        <View style={[styles.modalContainer, containerStyle]} pointerEvents="box-none">
          {/* The content itself should not be pressable to close unless explicitly handled by children */} 
          <View style={[styles.contentBox, contentStyle]}>
            {children}
          </View>
        </View>
      </ReactNativeModal>
    );
  }
);

const styles = StyleSheet.create({
  backdrop: {
    position: 'absolute',
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center', // Default to center position
    alignItems: 'center',
    padding: 20, // Ensure content doesn't touch screen edges
  },
  contentBox: {
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
    maxWidth: '90%',
    maxHeight: '80%',
    elevation: 5, // Android shadow
    shadowColor: '#000', // iOS shadow
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    // Ensure children with own scrolling work as expected
    overflow: Platform.OS === 'android' ? 'hidden' : undefined, // Fix for Android borderRadius with shadow
  },
  // Example style mentioned in usage comments, not part of the component itself
  /* modalContentExample: {
    alignItems: 'center',
  }, */
});

export default Modal;
</file>

<file path="mobile-app/src/components/tasks/TaskFilterBar.tsx">
/**
 * TaskFilterBar.tsx
 *
 * A component that provides filtering options for the task list, allowing users
 * to toggle between viewing active tasks and tasks completed on the current day.
 * 
 * Features:
 * - Toggle buttons for filtering tasks (Active/Today's Completed)
 * - Visual indicators for the currently selected filter
 * - Animated transitions between filter states (Future enhancement)
 * - Accessibility support with proper labeling
 * - Responsive design that adapts to different screen sizes
 * 
 * The component emits events when filters are changed, allowing parent components
 * to update their state and re-render filtered content accordingly.
 * 
 * Usage:
 * <TaskFilterBar
 *   activeFilter="active" // or "completedToday"
 *   onFilterChange={(filter) => handleFilterChange(filter)}
 *   showCompletedCount={true} // Prop name updated for clarity
 *   completedCount={5}
 * />
 */

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, StyleProp, ViewStyle } from 'react-native';

export type TaskFilter = 'active' | 'completedToday';

interface TaskFilterBarProps {
  activeFilter: TaskFilter;
  onFilterChange: (filter: TaskFilter) => void;
  completedCount?: number;
  style?: StyleProp<ViewStyle>;
}

const TaskFilterBar: React.FC<TaskFilterBarProps> = ({
  activeFilter,
  onFilterChange,
  completedCount = 0,
  style,
}) => {
  const filters: { label: string; value: TaskFilter }[] = [
    { label: 'Active', value: 'active' },
    { label: `Today's Completed`, value: 'completedToday' },
  ];

  return (
    <View style={[styles.container, style]}>
      {filters.map((filter) => {
        const isActive = activeFilter === filter.value;
        return (
          <TouchableOpacity
            key={filter.value}
            style={[
              styles.filterButton,
              isActive && styles.activeFilterButton,
            ]}
            onPress={() => onFilterChange(filter.value)}
            accessibilityLabel={`Filter tasks by ${filter.label}`}
            accessibilityRole="button"
            accessibilityState={{ selected: isActive }}
          >
            <Text
              style={[
                styles.filterButtonText,
                isActive && styles.activeFilterButtonText,
              ]}
            >
              {filter.label}
            </Text>
            {filter.value === 'completedToday' && completedCount > 0 && (
              <View style={styles.badgeContainer}>
                <Text style={styles.badgeText}>{completedCount}</Text>
              </View>
            )}
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    backgroundColor: '#F0F0F0', // Light gray background
    borderRadius: 25, // Rounded corners for the bar
    marginHorizontal: 16,
    marginVertical: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
  },
  filterButton: {
    flexDirection: 'row',
    paddingVertical: 10,
    paddingHorizontal: 18, // Increased padding for better touch area
    borderRadius: 20, // Rounded corners for buttons
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeFilterButton: {
    backgroundColor: '#007AFF', // iOS blue for active filter
  },
  filterButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#007AFF', // Text color for inactive buttons
  },
  activeFilterButtonText: {
    color: '#FFFFFF', // White text for active button
    fontWeight: 'bold',
  },
  badgeContainer: {
    backgroundColor: '#FF3B30', // iOS red for badge
    borderRadius: 9,
    width: 18,
    height: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  badgeText: {
    color: '#FFFFFF',
    fontSize: 10,
    fontWeight: 'bold',
  },
});

export default TaskFilterBar;
</file>

<file path="mobile-app/src/components/tasks/TaskForm.tsx">
/**
 * TaskForm.tsx
 *
 * A form component for creating new tasks and editing existing ones.
 * 
 * Features:
 * - Provides input fields for all task properties (title, description, due date, priority)
 * - Implements form validation with helpful error messages
 * - Supports both creation and edit modes
 * - Includes date picker for selecting due dates
 * - Offers priority selection via radio buttons or dropdown
 * - Connects to Redux to dispatch task actions
 *
 * This component follows form best practices with proper validation,
 * accessibility, and user feedback for a smooth task management experience.
 */

import React, { useState, useCallback } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  StyleSheet, 
  TouchableOpacity, 
  Alert, 
  Platform,
  ScrollView,
  KeyboardAvoidingView
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useAppDispatch } from '../../store/store';
import { addTask } from '../../store/actions/taskActions';
import { NewTask, Task, TaskPriority } from '../../types/task';
import { Picker } from '@react-native-picker/picker';
import { Calendar } from 'react-native-calendars';

interface TaskFormProps {
  onSuccess?: () => void;
  initialTask?: Partial<Task>;
  submitButtonText?: string;
  onDismiss?: () => void;
}

const TaskForm: React.FC<TaskFormProps> = ({
  onSuccess,
  initialTask,
  submitButtonText = 'Add Task',
  onDismiss,
}) => {
  const dispatch = useAppDispatch();
  const [title, setTitle] = useState(initialTask?.title || '');
  const [description, setDescription] = useState(initialTask?.description || '');
  const [priority, setPriority] = useState<TaskPriority>(initialTask?.priority || 'medium');
  const [dueDate, setDueDate] = useState<Date | null>(initialTask?.dueDate ? new Date(initialTask.dueDate) : null);
  const [showCalendar, setShowCalendar] = useState(false);
  const [errors, setErrors] = useState<{title?: string}>({});

  const validateForm = useCallback((): boolean => {
    const newErrors: {title?: string} = {};
    
    if (!title.trim()) {
      newErrors.title = 'Task title is required';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [title]);

  const handleSubmit = useCallback(() => {
    if (!validateForm()) return;

    const newTaskData: NewTask = {
      title: title.trim(),
      description: description.trim() || undefined,
      priority,
      dueDate: dueDate?.toISOString(),
      completed: false,
    };

    dispatch(addTask(newTaskData))
      .unwrap()
      .then(() => {
        if (!initialTask) {
          // Only clear if it's a new task form
          setTitle('');
          setDescription('');
          setPriority('medium');
          setDueDate(null);
        }
        onSuccess?.();
      })
      .catch((error) => {
        Alert.alert('Error', error.message || 'Failed to save task');
      });
  }, [title, description, priority, dueDate, validateForm, dispatch, onSuccess, initialTask]);

  const handleDateChange = (event: any, selectedDate?: Date) => {
    const currentDate = selectedDate || dueDate;
    setShowCalendar(Platform.OS === 'ios');
    setDueDate(currentDate);
  };

  return (
    <View style={{ flex: 1, backgroundColor: '#fff' }}>
      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
      >
        <ScrollView 
          contentContainerStyle={[styles.scrollContent, { paddingBottom: 40 }]}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <Text style={styles.label}>Task Title *</Text>
          <TextInput
            style={[styles.input, errors.title && styles.inputError]}
            placeholder="Enter task title"
            placeholderTextColor="#999"
            value={title}
            onChangeText={(text) => {
              setTitle(text);
              if (errors.title) setErrors({});
            }}
            maxLength={100}
          />
          {errors.title && <Text style={styles.errorText}>{errors.title}</Text>}

          <Text style={styles.label}>Description (Optional)</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            placeholder="Enter task description"
            placeholderTextColor="#999"
            value={description}
            onChangeText={setDescription}
            multiline
            numberOfLines={4}
            maxLength={500}
            textAlignVertical="top"
          />

          <View style={styles.column}>
            <Text style={styles.label}>Priority</Text>
            <View style={[styles.pickerContainer]}>
              <Picker
                selectedValue={priority}
                onValueChange={(itemValue: TaskPriority | string) => 
                  setPriority(itemValue as TaskPriority)
                }
                style={[styles.picker, { color: '#000' }]}
                dropdownIconColor="#000"
                mode="dropdown"
              >
                <Picker.Item label="High" value="high" color="#000" />
                <Picker.Item label="Medium" value="medium" color="#000" />
                <Picker.Item label="Low" value="low" color="#000" />
              </Picker>
            </View>
          </View>

          <View style={[styles.column, styles.datePickerContainer]}>
            <Text style={styles.label}>Due Date</Text>
            <TouchableOpacity 
              style={styles.datePickerButton}
              onPress={() => setShowCalendar(!showCalendar)}
            >
              <Text style={styles.dateText}>
                {dueDate ? dueDate.toLocaleDateString() : 'Select date'}
              </Text>
              <Ionicons 
                name={showCalendar ? 'calendar' : 'calendar-outline'}
                size={20} 
                color="#666"
                style={styles.calendarIcon}
              />
            </TouchableOpacity>
            {showCalendar && (
              <View style={styles.calendarContainer}>
                <Calendar
                  onDayPress={(day) => {
                    setDueDate(new Date(day.timestamp));
                    setShowCalendar(false);
                  }}
                  minDate={new Date().toISOString()}
                  theme={{
                    backgroundColor: '#ffffff',
                    calendarBackground: '#ffffff',
                    textSectionTitleColor: '#b6c1cd',
                    selectedDayBackgroundColor: '#3498db',
                    selectedDayTextColor: '#ffffff',
                    todayTextColor: '#3498db',
                    dayTextColor: '#2d4150',
                    textDisabledColor: '#d9e1e8',
                    dotColor: '#3498db',
                    selectedDotColor: '#ffffff',
                    arrowColor: '#3498db',
                    monthTextColor: '#3498db',
                    textMonthFontWeight: 'bold',
                    textDayFontSize: 16,
                    textMonthFontSize: 16,
                    textDayHeaderFontSize: 16
                  }}
                />
                <TouchableOpacity 
                  style={styles.calendarCloseButton}
                  onPress={() => setShowCalendar(false)}
                >
                  <Text style={styles.calendarCloseText}>Close</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>

          <TouchableOpacity 
            style={styles.submitButton}
            onPress={handleSubmit}
            activeOpacity={0.8}
          >
            <Text style={styles.submitButtonText}>{submitButtonText}</Text>
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  scrollContent: {
    padding: 20,
    paddingBottom: 40,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    padding: 14,
    fontSize: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  inputError: {
    borderColor: '#ff4444',
  },
  errorText: {
    color: '#ff4444',
    marginTop: -12,
    marginBottom: 16,
    fontSize: 14,
  },
  textArea: {
    minHeight: 120,
    textAlignVertical: 'top',
  },
  row: {
    flexDirection: 'column',
    marginBottom: 16,
  },
  column: {
    width: '100%',
    marginBottom: 16,
  },
  pickerContainer: {
    padding: 0,
    justifyContent: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  picker: {
    width: '100%',
  },
  datePickerButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 15,
    marginTop: 5,
    backgroundColor: '#f9f9f9',
  },
  calendarIcon: {
    marginLeft: 8,
  },
  dateText: {
    fontSize: 16,
    color: '#333',
  },
  submitButton: {
    backgroundColor: '#3498db',
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    marginTop: 8,
  },
  submitButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  calendarContainer: {
    position: 'relative',
    marginTop: 10,
    backgroundColor: '#fff',
    borderRadius: 10,
    elevation: 5,
    zIndex: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    width: '100%',
    alignSelf: 'center',
  },
  calendarCloseButton: {
    backgroundColor: '#3498db',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
  },
  calendarCloseText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  datePickerContainer: {
    position: 'relative',
    zIndex: 1001,
  },
});

export default TaskForm;
</file>

<file path="mobile-app/src/components/tasks/TaskItem.tsx">
/**
 * TaskItem.tsx
 *
 * A reusable component that displays a single task item in the list.
 * 
 * Features:
 * - Renders task details (title, description, due date, priority)
 * - Provides a checkbox to toggle task completion status
 * - Includes swipe actions for quick editing and deletion
 * - Displays visual indicators for priority levels
 * - Handles overdue task styling
 * - Implements proper accessibility features
 *
 * This component is responsible for the presentation and interaction
 * with individual task items, following a consistent design system.
 */

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Alert, GestureResponderEvent } from 'react-native';
import { Ionicons } from '@expo/vector-icons'; // Import Ionicons
import { useDispatch } from 'react-redux';
import { Task } from '../../types/task';
import { toggleTask, deleteTask } from '../../store/actions/taskActions';
import { useAppDispatch } from '../../store/store'; 

interface TaskItemProps {
  task: Task;
  onEdit?: (task: Task) => void;
  showCheckmark?: boolean;
}

const TaskItem: React.FC<TaskItemProps> = ({ task, onEdit, showCheckmark = false }) => {
  const dispatch = useAppDispatch();

  const handleToggleComplete = () => {
    if (task.id) {
      dispatch(toggleTask({ taskId: task.id, completed: !task.completed }));
    }
  };

  const handlePress = (e: GestureResponderEvent) => {
    // Only toggle if the press is not on the delete button
    if (e.target !== e.currentTarget) {
      onEdit?.(task);
    }
  };

  const handleDelete = () => {
    Alert.alert(
      'Delete Task',
      `Are you sure you want to delete "${task.title}"?`,
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => {
            if (task.id) {
              dispatch(deleteTask(task.id));
            }
          },
        },
      ]
    );
  };

  return (
    <View style={[styles.container, task.completed && styles.completedContainer]}>
      {/* Delete Button - Moved to the left */}
      <TouchableOpacity 
        onPress={handleDelete} 
        style={styles.deleteButton}
        hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
      >
        <Ionicons name="trash-outline" size={22} color="#e74c3c" />
      </TouchableOpacity>

      {/* Info Container - Takes remaining space, includes completion toggle */}
      <TouchableOpacity 
        onPress={handlePress} // This now primarily serves for onEdit
        style={styles.infoContainer}
        activeOpacity={0.7}
      >
        <View style={styles.mainContentContainer}> 
          <View style={styles.header}>
            <Text 
              style={[
                styles.title,
                task.completed && styles.completedText
              ]}
              numberOfLines={1}
              ellipsizeMode="tail"
            >
              {task.title}
            </Text>
            <Text style={styles.priority}>
              {task.priority?.toUpperCase() || 'NORMAL'}
            </Text>
          </View>
          
          {task.description && (
            <Text 
              style={[
                styles.description, 
                task.completed && styles.completedText
              ]}
              numberOfLines={2}
              ellipsizeMode="tail"
            >
              {task.description}
            </Text>
          )}
          
          <View style={styles.footer}>
            {/* Removed old status text - will be replaced by icon toggle */}
            {task.dueDate && (
              <Text style={styles.dueDate}>
                <Ionicons name="calendar-outline" size={12} color="#888" /> {new Date(task.dueDate).toLocaleDateString()}
              </Text>
            )}
          </View>
        </View>
      </TouchableOpacity>

      {/* Completion Toggle - Positioned to the right, within the bounds of the old delete button's visual space */}
      <TouchableOpacity 
        onPress={handleToggleComplete} 
        style={styles.completionToggle}
        hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
        accessibilityLabel={task.completed ? "Mark as incomplete" : "Mark as complete"}
        accessibilityRole="button"
      >
        <View style={[
          styles.completionRing,
          task.completed && styles.completedRing
        ]}>
          {showCheckmark && (
            <Ionicons 
              name="checkmark"
              size={20} 
              color={"#ffffff"}
              style={styles.checkIcon}
            />
          )}
        </View>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#fff',
    paddingVertical: 12, // Adjusted padding
    paddingHorizontal: 16, // Adjusted padding
    marginVertical: 6,
    marginHorizontal: 12,
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 }, // Softer shadow
    shadowOpacity: 0.08, // Softer shadow
    shadowRadius: 2, // Softer shadow
    elevation: 2,
    flexDirection: 'row',
    alignItems: 'center', // Align items vertically
    overflow: 'hidden',
  },
  completedContainer: {
    backgroundColor: '#f0f0f0', // Lighter completed background
    opacity: 0.9, // Slightly less opaque
  },
  deleteButton: {
    paddingVertical: 8, // Consistent vertical padding
    paddingRight: 12, // Space between delete and info
    justifyContent: 'center',
    alignItems: 'center',
  },
  infoContainer: {
    flex: 1,
    justifyContent: 'center', // Center content vertically if it's shorter
  },
  mainContentContainer: { // New wrapper for text content, to allow completion toggle to be separate
    flex: 1, // takes available space if infoContainer had other siblings horizontally
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4, // Reduced margin
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 6, // Reduced margin
  },
  title: {
    flex: 1,
    fontSize: 17, // Slightly larger title
    fontWeight: '600',
    color: '#2c3e50', // Darker title
    marginRight: 8,
  },
  priority: {
    fontSize: 11, // Smaller priority text
    fontWeight: 'bold',
    color: '#fff',
    backgroundColor: '#3498db', // Example color
    paddingHorizontal: 5,
    paddingVertical: 2,
    borderRadius: 4,
    overflow: 'hidden',
    marginLeft: 4, // Add some space if title is long
  },
  description: {
    fontSize: 14,
    color: '#7f8c8d', // Softer description color
    marginVertical: 2, // Reduced margin
    lineHeight: 18, // Adjusted line height
  },
  dueDate: {
    fontSize: 12,
    color: '#888',
    display: 'flex', // For icon alignment
    alignItems: 'center', // For icon alignment
  },
  completedText: {
    textDecorationLine: 'line-through',
    color: '#bdc3c7', // Lighter completed text
  },
  completionToggle: {
    paddingVertical: 8,
    paddingLeft: 12,
    paddingRight: 8,
    justifyContent: 'center',
    alignItems: 'center',
    // Add a slight touch target expansion
    minWidth: 50,
    minHeight: 50,
  },
  completionRing: {
    width: 32,
    height: 32,
    borderRadius: 16, // Make it circular
    backgroundColor: '#3498db', // Blue color for the ring
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#3498db',
  },
  completedRing: {
    backgroundColor: '#2ecc71', // Green when completed
    borderColor: '#2ecc71',
  },
  checkIcon: {
    // Position the checkmark in the center of the ring
    alignSelf: 'center',
    // Add text shadow for better visibility
    textShadowColor: 'rgba(0,0,0,0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 1,
  },
});

export default TaskItem;
</file>

<file path="mobile-app/src/components/tasks/TaskList.tsx">
/**
 * TaskList.tsx
 *
 * A component responsible for rendering a list of task items.
 * 
 * Features:
 * - Displays tasks in a scrollable FlatList
 * - Handles empty states with appropriate messaging
 * - Supports pull-to-refresh functionality
 * - Implements filtering and sorting options
 * - Uses virtualization for performance with large lists
 * - Connects to Redux store to retrieve task data
 *
 * This component serves as a container for TaskItem components and
 * manages the presentation logic for the entire task list.
 */

import React, { useEffect, useMemo } from 'react';
import { View, Text, FlatList, StyleSheet, SafeAreaView, ActivityIndicator, RefreshControl } from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { AppDispatch } from '../../store/store';
import { selectTasks, selectTasksLoading, selectTasksError } from '../../store/selectors/taskSelectors';
import { fetchTasks } from '../../store/actions/taskActions';
import { Task } from '../../types/task';
import TaskItem from './TaskItem';
import { TaskFilter } from './TaskFilterBar';

interface TaskListProps {
  activeFilter: TaskFilter;
}

const TaskList: React.FC<TaskListProps> = ({ activeFilter }) => {
  const dispatch: AppDispatch = useDispatch();
  const allTasks = useSelector(selectTasks);
  const isLoading = useSelector(selectTasksLoading);
  const error = useSelector(selectTasksError);

  useEffect(() => {
    dispatch(fetchTasks());
  }, [dispatch]);

  const filteredTasks = useMemo(() => {
    console.log('Filtering tasks with filter:', activeFilter);
    if (activeFilter === 'active') {
      return allTasks.filter(task => !task.completed);
    } else if (activeFilter === 'completedToday') {
      const today = new Date();
      today.setHours(0, 0, 0, 0); // Start of today
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1); // Start of tomorrow

      return allTasks.filter(task => {
        if (!task.completed || !task.completionDate) return false;
        const completionDate = new Date(task.completionDate);
        return completionDate >= today && completionDate < tomorrow;
      });
    }
    return allTasks; // Should not happen if activeFilter is always valid
  }, [allTasks, activeFilter]);

  const renderItem = ({ item }: { item: Task }) => (
    <TaskItem 
      task={item} 
      showCheckmark={activeFilter === 'active'}
    />
  );

  const onRefresh = () => {
    dispatch(fetchTasks());
  };

  if (isLoading && allTasks.length === 0) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" />
        <Text style={styles.loadingText}>Loading tasks...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>Error loading tasks: {error}</Text>
        <Text style={styles.retryText} onPress={onRefresh}>
          Tap to retry
        </Text>
      </View>
    );
  }

  if (filteredTasks.length === 0) {
    let emptyMessage = 'No tasks yet. Add one!';
    if (activeFilter === 'active') {
      emptyMessage = 'No active tasks. Great job, or add a new one!';
    } else if (activeFilter === 'completedToday') {
      emptyMessage = 'No tasks completed today. Keep going!';
    }
    return (
      <View style={styles.centered}>
        <Text style={styles.emptyText}>{emptyMessage}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={filteredTasks}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContentContainer}
        refreshControl={
          <RefreshControl refreshing={isLoading} onRefresh={onRefresh} />
        }
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 10,
    color: '#666',
  },
  errorText: {
    color: '#d32f2f',
    marginBottom: 15,
    textAlign: 'center',
    paddingHorizontal: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
  },
  retryText: {
    color: '#1976d2',
    marginTop: 10,
    padding: 8,
    textDecorationLine: 'underline',
  },
  itemContainer: {
    backgroundColor: '#fff',
    padding: 15,
    borderRadius: 8,
    marginBottom: 10,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.22,
    shadowRadius: 2.22,
    elevation: 3,
  },
  itemTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  listContentContainer: {
    paddingBottom: 20, // Ensure space for the last item and Add button
  },
});

export default TaskList;
</file>

<file path="mobile-app/src/config/api.ts">
// src/config/api.ts
// Base URL for API requests - update this to match your backend server URL
export const API_BASE_URL = 'http://localhost:3000';
</file>

<file path="mobile-app/src/hooks/useAuth.ts">
import { useSelector } from 'react-redux';
import { RootState } from '../store/rootReducer';

export const useAuth = () => {
  const { user, isAuthenticated, isLoading } = useSelector(
    (state: RootState) => state.auth
  );

  return {
    user,
    isAuthenticated,
    isLoading,
  };
};
</file>

<file path="mobile-app/src/navigation/AppNavigator.tsx">
/**
 * AppNavigator.tsx
 * 
 * This file contains the main navigation structure for the Coach Ally application.
 * It defines the bottom tab navigator and routes to the main screens:
 * Tasks, Chat, Tamagotchi, and Settings.
 * 
 * The navigator handles transitions between screens and maintains navigation state.
 */

import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';

import TasksScreen from '../screens/TasksScreen';
import ChatStackNavigator from './ChatStackNavigator'; // Changed from ChatScreen
import TamagotchiScreen from '../screens/Tamagotchi/TamagotchiScreen';
import SettingsScreen from '../screens/Settings/SettingsScreen';

import { BottomTabParamList } from './types';

const Tab = createBottomTabNavigator<BottomTabParamList>();

const AppNavigator = () => {
  return (
    <Tab.Navigator
      initialRouteName="Tasks"
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';

          if (route.name === 'Tasks') {
            iconName = focused ? 'check-all' : 'check-all';
          } else if (route.name === 'Chat') {
            iconName = focused ? 'chat' : 'chat-outline';
          } else if (route.name === 'Tamagotchi') {
            iconName = focused ? 'paw' : 'paw-outline';
          } else if (route.name === 'Settings') {
            iconName = focused ? 'cog' : 'cog-outline';
          }

          // You can return any component that you like here!
          return <MaterialCommunityIcons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: 'tomato', // Example active color
        tabBarInactiveTintColor: 'gray',   // Example inactive color
        headerShown: true, // Show header for screens, can be customized per screen
      })}
    >
      <Tab.Screen name="Tasks" component={TasksScreen} />
      <Tab.Screen 
        name="Chat" 
        component={ChatStackNavigator} 
        options={{ headerShown: false }} // Hide TabNavigator header for Chat stack
      />
      <Tab.Screen name="Tamagotchi" component={TamagotchiScreen} />
      <Tab.Screen name="Settings" component={SettingsScreen} />
    </Tab.Navigator>
  );
};

export default AppNavigator;
</file>

<file path="mobile-app/src/navigation/ChatStackNavigator.tsx">
// src/navigation/ChatStackNavigator.tsx
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import ChatScreen from '../screens/Chat/ChatScreen'; // Path confirmed earlier
import WebScreen from '../screens/WebScreen';      // Path to the WebView screen
import { ChatStackParamList } from './types';     // Import the new param list

const Stack = createNativeStackNavigator<ChatStackParamList>();

const ChatStackNavigator = () => {
  return (
    <Stack.Navigator
      initialRouteName="ChatHome"
      // You can define default screen options for this stack here if needed
      // screenOptions={{ }}
    >
      <Stack.Screen
        name="ChatHome"
        component={ChatScreen}
        options={{ headerShown: false }} // Hiding this stack's header as the TabNavigator likely has one
      />
      <Stack.Screen
        name="WebAppViewer"
        component={WebScreen}
        options={{ title: 'Coach Ally Web' }} // Set a title for the WebScreen header
      />
    </Stack.Navigator>
  );
};

export default ChatStackNavigator;
</file>

<file path="mobile-app/src/navigation/types.ts">
/**
 * types.ts
 * 
 * This file defines TypeScript type definitions for the navigation system.
 * It includes:
 * - Route parameter lists for each screen
 * - Navigation prop types
 * - Screen option types
 * - Navigation state types
 * 
 * These types ensure type safety throughout the navigation system.
 */

// types.ts - Navigation types will go here

// Define the parameter list for each screen in the bottom tab navigator
export type BottomTabParamList = {
  Tasks: undefined; // No parameters expected for Tasks screen
  Chat: undefined; // No parameters expected for Chat screen
  Tamagotchi: undefined; // No parameters expected for Tamagotchi screen
  Settings: undefined; // No parameters expected for Settings screen
};

// Define the parameter list for the Chat Stack Navigator
export type ChatStackParamList = {
  ChatHome: undefined; // Main chat screen, will render ChatScreen.tsx
  WebAppViewer: undefined; // Screen to display the web app via WebView
};

// You can extend this with types for other navigators (e.g., StackNavigator)
// For example:
// export type AuthStackParamList = {
//   Login: undefined;
//   Register: undefined;
// };

// export type AppStackParamList = {
//   Home: NavigatorScreenParams<BottomTabParamList>;
//   Profile: { userId: string };
// };

// Helper types for screen props
// import { BottomTabScreenProps } from '@react-navigation/bottom-tabs';
// import { CompositeScreenProps, NavigatorScreenParams } from '@react-navigation/native';
// import { NativeStackScreenProps } from '@react-navigation/native-stack';

// export type TasksScreenProps = BottomTabScreenProps<BottomTabParamList, 'Tasks'>;
// export type ChatScreenProps = BottomTabScreenProps<BottomTabParamList, 'Chat'>;
// export type TamagotchiScreenProps = BottomTabScreenProps<BottomTabParamList, 'Tamagotchi'>;
// export type SettingsScreenProps = BottomTabScreenProps<BottomTabParamList, 'Settings'>;
</file>

<file path="mobile-app/src/screens/Chat/ChatScreen.tsx">
// src/screens/Chat/ChatScreen.tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  FlatList,
  SafeAreaView,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import apiClient, {
  getOrCreateConversation,
  sendMessage,
  getMessages,
  login, // Assuming you have a login function for testing
} from '../../services/apiService'; // Adjust path if necessary
import socketService, { SocketMessage } from '../../services/socketService';

// Type for messages as they come from the backend API
interface BackendMessage {
  id: string;
  content: string;
  UserId: string; // Assuming this is how the backend sends sender ID
  createdAt: string; // Assuming ISO string timestamp
  // Add any other properties your backend message object has
}

// Type for messages used in the frontend state
type Message = {
  id: string;
  content: string; // Changed from 'text' to match backend
  senderId: string; // Assuming backend provides senderId
  senderType: 'user' | 'ai'; // Differentiate for styling
  timestamp: string; // Assuming backend provides ISO string
  // Add other message properties as needed from your backend
};

// Test user ID - use the ID returned from registration
const MOCK_USER_ID = '97950981-4184-492b-99a6-7f6227e806b7'; // test@example.com
// AI Coach user ID - using the actual ID of our registered AI coach user
const AI_COACH_USER_ID = 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e'; // ai_coach@example.com

const ChatScreen = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [conversationId, setConversationId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const flatListRef = useRef<FlatList>(null);

  // Simulate Auth and Initialize Conversation
  useEffect(() => {
    const initializeChat = async () => {
      setIsLoading(true);
      setError(null);
      try {
        // 1. Simulate login to get a token (replace with your actual auth flow)
        //    For a real app, this token would come from your auth context/storage
        const authData = await login({ email: 'test@example.com', password: 'testpassword123' }); // Using our test user
        if (!authData.token) {
          throw new Error('Authentication failed');
        }
        apiClient.setAuthToken(authData.token); // Sets token for all subsequent apiClient requests
        
        // Initialize socket connection with the auth token
        socketService.init(authData.token);

        // 2. Get or create a conversation with the AI coach
        //    The participantUserIds should contain the AI's user ID.
        const conv = await getOrCreateConversation([AI_COACH_USER_ID], 'direct');
        if (!conv || !conv.id) {
          throw new Error('Could not establish conversation.');
        }
        setConversationId(conv.id);

        // 3. Load initial messages for this conversation
        const initialMessagesData = await getMessages(conv.id);
        // Map backend messages to frontend Message type
        const formattedMessages = initialMessagesData.messages.map((msg: BackendMessage) => ({
          id: msg.id,
          content: msg.content,
          senderId: msg.UserId, // Or however your backend structures sender
          senderType: msg.UserId === MOCK_USER_ID ? 'user' : 'ai', // Adjust MOCK_USER_ID
          timestamp: msg.createdAt, // Or 'timestamp'
        }));
        setMessages(formattedMessages.reverse()); // Assuming messages are newest first from backend
        
      } catch (err) {
        console.error('Initialization error:', err);
        setError('Failed to initialize chat. Please try again.');
        Alert.alert('Error', 'Failed to initialize chat. Check console for details.');
      } finally {
        setIsLoading(false);
      }
    };

    initializeChat();
    
    // Clean up socket connection when component unmounts
    return () => {
      socketService.disconnect();
    };
  }, []);
  
  useEffect(() => {
    if (flatListRef.current && messages.length > 0) {
      // Timeout to ensure layout is complete before scrolling
      setTimeout(() => flatListRef.current?.scrollToEnd({ animated: true }), 100);
    }
  }, [messages]);
  
  // WebSocket listener for new messages
  useEffect(() => {
    if (!conversationId) return;
    
    // Handle new message from WebSocket
    const handleNewMessage = (newMessage: SocketMessage) => {
      if (newMessage.conversationId === conversationId) { // Ensure message is for current conversation
        setMessages(prevMessages => {
          // Determine sender type based on user ID
          const senderType: 'user' | 'ai' = newMessage.UserId === MOCK_USER_ID ? 'user' : 'ai';
          
          // Prevent duplicates if message was already added optimistically
          // or if it's the user's own confirmed message
          if (prevMessages.find(msg => msg.id === newMessage.id)) {
            return prevMessages.map(msg => msg.id === newMessage.id ? {
              id: newMessage.id,
              content: newMessage.content,
              senderId: newMessage.UserId,
              senderType: senderType,
              timestamp: newMessage.createdAt,
            } : msg);
          }
          
          // Add new message
          const messageToAdd: Message = {
            id: newMessage.id,
            content: newMessage.content,
            senderId: newMessage.UserId,
            senderType: senderType,
            timestamp: newMessage.createdAt,
          };
          
          return [...prevMessages, messageToAdd].sort((a, b) => 
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        });
      }
    };

    // Subscribe to newMessage event
    socketService.on('newMessage', handleNewMessage);
    
    // Cleanup function to unsubscribe
    return () => {
      socketService.off('newMessage', handleNewMessage);
    };
  }, [conversationId, MOCK_USER_ID]);


  const handleSend = async () => {
    if (inputText.trim() === '' || !conversationId || isSending) return;

    setIsSending(true);
    setError(null);

    const userMessageContent = inputText;
    setInputText(''); // Clear input immediately

    // Optimistically add user message to UI
    const optimisticUserMessage: Message = {
      id: `temp-${Date.now()}`,
      content: userMessageContent,
      senderId: MOCK_USER_ID, 
      senderType: 'user',
      timestamp: new Date().toISOString(),
    };
    setMessages(prevMessages => [...prevMessages, optimisticUserMessage]);

    try {
      // Send message via HTTP API
      const sentMessageData = await sendMessage(conversationId, userMessageContent);
      
      // Update optimistic message with confirmed one
      setMessages(prevMessages => {
        // Create properly typed confirmed message
        const confirmedMessage: Message = {
          id: sentMessageData.id,
          content: sentMessageData.content,
          senderId: sentMessageData.UserId,
          senderType: 'user',
          timestamp: sentMessageData.createdAt,
        };
        
        return prevMessages.map(msg =>
          msg.id === optimisticUserMessage.id ? confirmedMessage : msg
        ).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      });
      
      // No need to poll for AI response - the WebSocket listener will handle it
      // The backend will process the user message and send the AI response via WebSocket
      
    } catch (err) {
      console.error('Send message error:', err);
      setError('Failed to send message.');
      // Revert optimistic update if send fails
      setMessages(prevMessages => prevMessages.filter(msg => msg.id !== optimisticUserMessage.id));
      setInputText(userMessageContent); // Restore input
      Alert.alert('Error', 'Failed to send message. Please try again.');
    } finally {
      setIsSending(false);
    }
  };

  const renderMessageItem = ({ item }: { item: Message }): React.ReactElement => (
    <View
      style={[
        styles.messageBubble,
        item.senderType === 'user' ? styles.userMessageBubble : styles.aiMessageBubble,
      ]}
    >
      <Text style={item.senderType === 'user' ? styles.userMessageText : styles.aiMessageText}>
        {item.content}
      </Text>
      <Text style={styles.timestampText}>
        {new Date(item.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
      </Text>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color="#007AFF" />
        <Text>Loading chat...</Text>
      </View>
    );
  }

  if (error && !messages.length) { // Show error prominently if initial load fails
    return (
        <View style={styles.centered}>
            <Text style={styles.errorText}>{error}</Text>
            {/* Optionally add a retry button here */}
        </View>
    );
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.container}
        keyboardVerticalOffset={Platform.OS === "ios" ? 60 : 0} 
      >
        <FlatList
          ref={flatListRef}
          data={messages}
          renderItem={renderMessageItem}
          keyExtractor={item => item.id}
          contentContainerStyle={styles.messagesListContent}
          ListEmptyComponent={!isLoading && !error ? <Text style={styles.emptyChatText}>No messages yet. Start the conversation!</Text> : null}
        />
        {error && <Text style={styles.errorTextSmall}>{error}</Text>}
        <View style={styles.inputArea}>
          <TextInput
            style={styles.textInput}
            value={inputText}
            onChangeText={setInputText}
            placeholder="Type your message..."
            placeholderTextColor="#A9A9A9"
            multiline
            editable={!isSending && !!conversationId} // Disable while sending or if no conversation
          />
          <TouchableOpacity 
            style={[styles.sendIconContainer, (isSending || !inputText.trim()) && styles.disabledSendButton]} 
            onPress={handleSend} 
            disabled={isSending || !inputText.trim() || !conversationId}
          >
            {isSending ? (
              <ActivityIndicator size="small" color="#007AFF" />
            ) : (
              <Ionicons name="send" size={24} color={(inputText.trim() && conversationId) ? "#007AFF" : "#B0B0B0"} />
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  container: {
    flex: 1,
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    color: 'red',
    fontSize: 16,
    textAlign: 'center',
  },
  errorTextSmall: {
    color: 'red',
    fontSize: 12,
    textAlign: 'center',
    paddingBottom: 5,
  },
  messagesListContent: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    flexGrow: 1, // Ensures content pushes input to bottom
  },
  messageBubble: {
    maxWidth: '80%',
    padding: 12,
    borderRadius: 20,
    marginVertical: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1.00,
    elevation: 1,
  },
  userMessageBubble: {
    alignSelf: 'flex-end',
    backgroundColor: '#007AFF',
    borderBottomRightRadius: 5,
  },
  aiMessageBubble: {
    alignSelf: 'flex-start',
    backgroundColor: '#E5E5EA',
    borderBottomLeftRadius: 5,
  },
  userMessageText: {
    fontSize: 16,
    color: '#FFFFFF',
  },
  aiMessageText: {
    fontSize: 16,
    color: '#000000',
  },
  timestampText: {
    fontSize: 10,
    color: '#9E9E9E',
    alignSelf: 'flex-end',
    marginTop: 4,
  },
  inputArea: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderTopWidth: 1,
    borderTopColor: '#DCDCDC',
    backgroundColor: '#F8F8F8',
  },
  textInput: {
    flex: 1,
    minHeight: 40,
    maxHeight: 120,
    backgroundColor: '#FFFFFF',
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: Platform.OS === 'ios' ? 10 : 8, // Adjust padding for Android
    fontSize: 16,
    marginRight: 8,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  sendIconContainer: {
    padding: 8,
  },
  disabledSendButton: {
    opacity: 0.5,
  },
  emptyChatText: {
    textAlign: 'center',
    marginTop: 20,
    color: '#A9A9A9',
    fontSize: 16,
  }
});

export default ChatScreen;
</file>

<file path="mobile-app/src/screens/Chat/ChatScreen.tsx.new">
// src/screens/Chat/ChatScreen.tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  FlatList,
  SafeAreaView,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  setAuthToken,
  getOrCreateConversation,
  sendMessage,
  getMessages,
  login, // Assuming you have a login function for testing
} from '../../services/apiService'; // Adjust path if necessary
import socketService, { SocketMessage } from '../../services/socketService';

// Type for messages as they come from the backend API
interface BackendMessage {
  id: string;
  content: string;
  UserId: string; // Assuming this is how the backend sends sender ID
  createdAt: string; // Assuming ISO string timestamp
  // Add any other properties your backend message object has
}

// Type for messages used in the frontend state
type Message = {
  id: string;
  content: string; // Changed from 'text' to match backend
  senderId: string; // Assuming backend provides senderId
  senderType: 'user' | 'ai'; // Differentiate for styling
  timestamp: string; // Assuming backend provides ISO string
  // Add other message properties as needed from your backend
};

// Test user ID - use the ID returned from registration
const MOCK_USER_ID = '97950981-4184-492b-99a6-7f6227e806b7'; // test@example.com
// AI Coach user ID - using the actual ID of our registered AI coach user
const AI_COACH_USER_ID = 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e'; // ai_coach@example.com

const ChatScreen = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [conversationId, setConversationId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const flatListRef = useRef<FlatList>(null);

  // Simulate Auth and Initialize Conversation
  useEffect(() => {
    const initializeChat = async () => {
      setIsLoading(true);
      setError(null);
      try {
        // 1. Simulate login to get a token (replace with your actual auth flow)
        //    For a real app, this token would come from your auth context/storage
        const authData = await login({ email: 'test@example.com', password: 'testpassword123' }); // Using our test user
        if (!authData.token) {
          throw new Error('Authentication failed');
        }
        setAuthToken(authData.token); // Sets token for all subsequent apiClient requests
        
        // Initialize socket connection with the auth token
        socketService.init(authData.token);

        // 2. Get or create a conversation with the AI coach
        //    The participantUserIds should contain the AI's user ID.
        const conv = await getOrCreateConversation([AI_COACH_USER_ID], 'direct');
        if (!conv || !conv.id) {
          throw new Error('Could not establish conversation.');
        }
        setConversationId(conv.id);

        // 3. Load initial messages for this conversation
        const initialMessagesData = await getMessages(conv.id);
        // Map backend messages to frontend Message type
        const formattedMessages = initialMessagesData.messages.map((msg: BackendMessage) => ({
          id: msg.id,
          content: msg.content,
          senderId: msg.UserId, // Or however your backend structures sender
          senderType: msg.UserId === MOCK_USER_ID ? 'user' : 'ai', // Adjust MOCK_USER_ID
          timestamp: msg.createdAt, // Or 'timestamp'
        }));
        setMessages(formattedMessages.reverse()); // Assuming messages are newest first from backend
        
      } catch (err) {
        console.error('Initialization error:', err);
        setError('Failed to initialize chat. Please try again.');
        Alert.alert('Error', 'Failed to initialize chat. Check console for details.');
      } finally {
        setIsLoading(false);
      }
    };

    initializeChat();
    
    // Clean up socket connection when component unmounts
    return () => {
      socketService.disconnect();
    };
  }, []);
  
  useEffect(() => {
    if (flatListRef.current && messages.length > 0) {
      // Timeout to ensure layout is complete before scrolling
      setTimeout(() => flatListRef.current?.scrollToEnd({ animated: true }), 100);
    }
  }, [messages]);
  
  // WebSocket listener for new messages
  useEffect(() => {
    if (!conversationId) return;
    
    // Handle new message from WebSocket
    const handleNewMessage = (newMessage: SocketMessage) => {
      if (newMessage.conversationId === conversationId) { // Ensure message is for current conversation
        setMessages(prevMessages => {
          // Determine sender type based on user ID
          const senderType: 'user' | 'ai' = newMessage.UserId === MOCK_USER_ID ? 'user' : 'ai';
          
          // Prevent duplicates if message was already added optimistically
          // or if it's the user's own confirmed message
          if (prevMessages.find(msg => msg.id === newMessage.id)) {
            return prevMessages.map(msg => msg.id === newMessage.id ? {
              id: newMessage.id,
              content: newMessage.content,
              senderId: newMessage.UserId,
              senderType: senderType,
              timestamp: newMessage.createdAt,
            } : msg);
          }
          
          // Add new message
          const messageToAdd: Message = {
            id: newMessage.id,
            content: newMessage.content,
            senderId: newMessage.UserId,
            senderType: senderType,
            timestamp: newMessage.createdAt,
          };
          
          return [...prevMessages, messageToAdd].sort((a, b) => 
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        });
      }
    };

    // Subscribe to newMessage event
    socketService.on('newMessage', handleNewMessage);
    
    // Cleanup function to unsubscribe
    return () => {
      socketService.off('newMessage', handleNewMessage);
    };
  }, [conversationId, MOCK_USER_ID]);


  const handleSend = async () => {
    if (inputText.trim() === '' || !conversationId || isSending) return;

    setIsSending(true);
    setError(null);

    const userMessageContent = inputText;
    setInputText(''); // Clear input immediately

    // Optimistically add user message to UI
    const optimisticUserMessage: Message = {
      id: `temp-${Date.now()}`,
      content: userMessageContent,
      senderId: MOCK_USER_ID, 
      senderType: 'user',
      timestamp: new Date().toISOString(),
    };
    setMessages(prevMessages => [...prevMessages, optimisticUserMessage]);

    try {
      // Send message via HTTP API
      const sentMessageData = await sendMessage(conversationId, userMessageContent);
      
      // Update optimistic message with confirmed one
      setMessages(prevMessages => {
        // Create properly typed confirmed message
        const confirmedMessage: Message = {
          id: sentMessageData.id,
          content: sentMessageData.content,
          senderId: sentMessageData.UserId,
          senderType: 'user',
          timestamp: sentMessageData.createdAt,
        };
        
        return prevMessages.map(msg =>
          msg.id === optimisticUserMessage.id ? confirmedMessage : msg
        ).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      });
      
      // No need to poll for AI response - the WebSocket listener will handle it
      // The backend will process the user message and send the AI response via WebSocket
      
    } catch (err) {
      console.error('Send message error:', err);
      setError('Failed to send message.');
      // Revert optimistic update if send fails
      setMessages(prevMessages => prevMessages.filter(msg => msg.id !== optimisticUserMessage.id));
      setInputText(userMessageContent); // Restore input
      Alert.alert('Error', 'Failed to send message. Please try again.');
    } finally {
      setIsSending(false);
    }
  };

  const renderMessageItem = ({ item }: { item: Message }): React.ReactElement => (
    <View
      style={[
        styles.messageBubble,
        item.senderType === 'user' ? styles.userMessageBubble : styles.aiMessageBubble,
      ]}
    >
      <Text style={item.senderType === 'user' ? styles.userMessageText : styles.aiMessageText}>
        {item.content}
      </Text>
      <Text style={styles.timestampText}>
        {new Date(item.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
      </Text>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color="#007AFF" />
        <Text>Loading chat...</Text>
      </View>
    );
  }

  if (error && !messages.length) { // Show error prominently if initial load fails
    return (
        <View style={styles.centered}>
            <Text style={styles.errorText}>{error}</Text>
            {/* Optionally add a retry button here */}
        </View>
    );
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.container}
        keyboardVerticalOffset={Platform.OS === "ios" ? 60 : 0} 
      >
        <FlatList
          ref={flatListRef}
          data={messages}
          renderItem={renderMessageItem}
          keyExtractor={item => item.id}
          contentContainerStyle={styles.messagesListContent}
          ListEmptyComponent={!isLoading && !error ? <Text style={styles.emptyChatText}>No messages yet. Start the conversation!</Text> : null}
        />
        {error && <Text style={styles.errorTextSmall}>{error}</Text>}
        <View style={styles.inputArea}>
          <TextInput
            style={styles.textInput}
            value={inputText}
            onChangeText={setInputText}
            placeholder="Type your message..."
            placeholderTextColor="#A9A9A9"
            multiline
            editable={!isSending && !!conversationId} // Disable while sending or if no conversation
          />
          <TouchableOpacity 
            style={[styles.sendIconContainer, (isSending || !inputText.trim()) && styles.disabledSendButton]} 
            onPress={handleSend} 
            disabled={isSending || !inputText.trim() || !conversationId}
          >
            {isSending ? (
              <ActivityIndicator size="small" color="#007AFF" />
            ) : (
              <Ionicons name="send" size={24} color={(inputText.trim() && conversationId) ? "#007AFF" : "#B0B0B0"} />
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  container: {
    flex: 1,
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    color: 'red',
    fontSize: 16,
    textAlign: 'center',
  },
  errorTextSmall: {
    color: 'red',
    fontSize: 12,
    textAlign: 'center',
    paddingBottom: 5,
  },
  messagesListContent: {
    paddingHorizontal: 10,
    paddingVertical: 8,
    flexGrow: 1, // Ensures content pushes input to bottom
  },
  messageBubble: {
    maxWidth: '80%',
    padding: 12,
    borderRadius: 20,
    marginVertical: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1.00,
    elevation: 1,
  },
  userMessageBubble: {
    alignSelf: 'flex-end',
    backgroundColor: '#007AFF',
    borderBottomRightRadius: 5,
  },
  aiMessageBubble: {
    alignSelf: 'flex-start',
    backgroundColor: '#E5E5EA',
    borderBottomLeftRadius: 5,
  },
  userMessageText: {
    fontSize: 16,
    color: '#FFFFFF',
  },
  aiMessageText: {
    fontSize: 16,
    color: '#000000',
  },
  timestampText: {
    fontSize: 10,
    color: '#9E9E9E',
    alignSelf: 'flex-end',
    marginTop: 4,
  },
  inputArea: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderTopWidth: 1,
    borderTopColor: '#DCDCDC',
    backgroundColor: '#F8F8F8',
  },
  textInput: {
    flex: 1,
    minHeight: 40,
    maxHeight: 120,
    backgroundColor: '#FFFFFF',
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: Platform.OS === 'ios' ? 10 : 8, // Adjust padding for Android
    fontSize: 16,
    marginRight: 8,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  sendIconContainer: {
    padding: 8,
  },
  disabledSendButton: {
    opacity: 0.5,
  },
  emptyChatText: {
    textAlign: 'center',
    marginTop: 20,
    color: '#A9A9A9',
    fontSize: 16,
  }
});

export default ChatScreen;
</file>

<file path="mobile-app/src/screens/Settings/SettingsScreen.tsx">
/**
 * SettingsScreen.tsx
 * 
 * This screen allows users to customize their Coach Ally experience:
 * - Toggle between light and dark themes
 * - Adjust notification preferences
 * - Set user profile information
 * - Configure app behavior settings
 * - View app information and version
 * - Access help resources
 * 
 * The screen uses the settings from the Redux store and
 * persists changes to local storage for a consistent experience.
 */

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const SettingsScreen = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Settings Screen</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
});

export default SettingsScreen;
</file>

<file path="mobile-app/src/screens/Tamagotchi/TamagotchiScreen.tsx">
/**
 * TamagotchiScreen.tsx
 * 
 * This screen implements the gamification element of Coach Ally through a virtual pet:
 * - Displays a goldfish tamagotchi with a mood indicator
 * - Visualizes the pet's mood based on user engagement (happy when tasks completed, sad when neglected)
 * - Allows users to interact with and care for the pet
 * - Provides options to improve the pet's enclosure and give treats
 * - Shows positive feedback and animations from the pet
 * - Displays streaks and points earned from task completion
 * 
 * The screen connects to the tamagotchi Redux slice for state management
 * and uses animations for an engaging user experience.
 */

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const TamagotchiScreen = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Tamagotchi Screen</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
});

export default TamagotchiScreen;
</file>

<file path="mobile-app/src/screens/TasksScreen.tsx">
import React from 'react';
import { View, Text, StyleSheet, Modal, TouchableOpacity, FlatList } from 'react-native';
import { Feather } from '@expo/vector-icons';
import TaskForm from '../components/tasks/TaskForm';

interface Task {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  dueDate?: Date;
  priority: 'low' | 'medium' | 'high';
}

const TasksScreen = () => {
  const [modalVisible, setModalVisible] = React.useState(false);
  const [tasks, setTasks] = React.useState<Task[]>([
    {
      id: '1',
      title: 'Example Task',
      description: 'This is an example task',
      completed: false,
      dueDate: new Date(),
      priority: 'medium'
    }
  ]);

  const handleModalVisibility = () => {
    setModalVisible(!modalVisible);
  };

  return (
    <View style={styles.container}>
      <Modal
        visible={modalVisible}
        transparent={true}
        onRequestClose={handleModalVisibility}
      >
        <TouchableOpacity
          style={styles.modalContent}
          onPress={handleModalVisibility}
        >
          <View style={styles.modalCard}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Task Details</Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={handleModalVisibility}
              >
                <Feather name="x" size={24} color="#333" />
              </TouchableOpacity>
            </View>
            <View style={styles.formContainer}>
              <TaskForm 
                onSuccess={() => {
                  // Handle task creation success
                  setModalVisible(false);
                }}
                onDismiss={() => setModalVisible(false)}
                submitButtonText="Create Task"
              />
            </View>
          </View>
        </TouchableOpacity>
      </Modal>

      <FlatList
        data={tasks}
        renderItem={({ item }) => (
          <View style={styles.taskItem}>
            <Text style={styles.taskTitle}>{item.title}</Text>
            {item.description && (
              <Text style={styles.taskDescription}>{item.description}</Text>
            )}
            <View style={styles.taskMeta}>
              <Text style={styles.taskPriority}>
                Priority: {item.priority}
              </Text>
              {item.dueDate && (
                <Text style={styles.taskDueDate}>
                  Due: {item.dueDate.toLocaleDateString()}
                </Text>
              )}
            </View>
          </View>
        )}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        ListEmptyComponent={
          <View style={styles.emptyState}>
            <Text style={styles.emptyStateText}>No tasks yet</Text>
            <Text style={styles.emptyStateSubtext}>Tap + to add a new task</Text>
          </View>
        }
      />

      <TouchableOpacity
        style={styles.fab}
        onPress={handleModalVisibility}
      >
        <Feather name="plus" size={24} color="#fff" />
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  fab: {
    position: 'absolute',
    right: 20,
    bottom: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: '#3498db',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    zIndex: 10,
  },
  modalContent: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
  },
  modalCard: {
    width: '100%',
    height: '85%',
    backgroundColor: '#fff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    overflow: 'hidden',
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingTop: 24,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#333',
  },
  closeButton: {
    padding: 8,
    borderRadius: 20,
    backgroundColor: '#f5f5f5',
  },
  formContainer: {
    flex: 1,
    paddingHorizontal: 20,
    paddingBottom: 30,
  },
  listContent: {
    flexGrow: 1,
    padding: 16,
  },
  taskItem: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  taskTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  taskDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
  },
  taskMeta: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  taskPriority: {
    fontSize: 12,
    color: '#666',
  },
  taskDueDate: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyStateText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#666',
    marginBottom: 8,
  },
  emptyStateSubtext: {
    fontSize: 14,
    color: '#999',
    textAlign: 'center',
  },
});

export default TasksScreen;
</file>

<file path="mobile-app/src/screens/WebScreen.js">
// mobile-app/src/screens/WebScreen.js
import React from 'react'; // Added React import
import { View, StyleSheet } from 'react-native';
import { WebView } from 'react-native-webview';

const WebScreen = () => {
  // IMPORTANT: Replace 'YOUR_LOCAL_IP' with your computer's local IP address
  // For example: 'http://192.168.1.10:3000'
  const webAppUrl = 'http://YOUR_LOCAL_IP:3000';

  return (
    <View style={styles.container}>
      <WebView
        source={{ uri: webAppUrl }}
        style={styles.webview}
        startInLoadingState={true} // Show a loading indicator
        javaScriptEnabled={true}   // Enable JavaScript in the WebView
        domStorageEnabled={true}   // Enable DOM Storage
        onError={(syntheticEvent) => {
          const { nativeEvent } = syntheticEvent;
          console.warn('WebView error: ', nativeEvent);
        }}
        onHttpError={(syntheticEvent) => {
          const { nativeEvent } = syntheticEvent;
          console.warn(
            'WebView HTTP error: ',
            nativeEvent.url,
            nativeEvent.statusCode,
            nativeEvent.description
          );
        }}
        onLoadProgress={({ nativeEvent }) => {
          console.log('WebView loading progress: ', nativeEvent.progress);
        }}
        onLoadEnd={() => {
          console.log('WebView finished loading');
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  webview: {
    flex: 1,
  },
});

export default WebScreen;
</file>

<file path="mobile-app/src/services/apiService.ts">
// src/services/apiService.ts
import axios, { AxiosInstance } from 'axios';
// Remove direct import of store to break the circular dependency
// import { store } from '../store/store';

// Multiple options for connecting based on device/environment
// 1. For development on actual device - use computer's public IP
const API_BASE_URL = 'http://69.120.124.150:5000/api';

// If you have connection issues, try one of these alternatives:
// For emulator/simulator: const API_BASE_URL = 'http://10.0.2.2:5000/api';
// For local testing: const API_BASE_URL = 'http://localhost:5000/api';

// Extend the AxiosInstance type to include our custom methods
interface ExtendedAxiosInstance extends AxiosInstance {
  setAuthToken: (token: string | null) => void;
}

// Declare a module augmentation for axios to recognize our custom properties
declare module 'axios' {
  interface AxiosInstance {
    setAuthToken: (token: string | null) => void;
  }
}

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer test-token', // Auto-authenticate with test token
  },
});

// Function to get auth token, will be set by store.ts after store creation
let getAuthTokenCallback: () => string | null = () => null;

// Export function to set the callback from store.ts
export const setGetAuthTokenCallback = (callback: () => string | null) => {
  getAuthTokenCallback = callback;
  console.log('API CLIENT: Auth token callback set');
};

// Add a request interceptor to include the auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = getAuthTokenCallback(); // Use the callback instead of direct store access
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
      console.log('AXIOS INTERCEPTOR: Attaching token via callback:', token.substring(0, 10) + '...'); // Added logging with truncated token
    } else {
      console.log('AXIOS INTERCEPTOR: No token from callback.'); // Added logging
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Function to set the authorization token for subsequent requests
const setAuthToken = (token: string | null) => {
  if (token) {
    apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    console.log('API CLIENT: Setting auth token:', token);
  } else {
    delete apiClient.defaults.headers.common['Authorization'];
    console.log('API CLIENT: Cleared auth token');
  }
};

// Add the setAuthToken method to the apiClient object
(apiClient as ExtendedAxiosInstance).setAuthToken = setAuthToken;

/**
 * Creates a new conversation or returns an existing direct conversation.
 * @param participantUserIds - Array of user IDs for the conversation. For direct, should be one other user's ID.
 * @param type - 'direct' or 'group'.
 * @param name - Name for group conversations.
 * @returns The conversation object.
 */
export const getOrCreateConversation = async (
  participantUserIdsArg: string[], // Array of participant user IDs
  type: 'direct' | 'group' = 'direct',
  name?: string | null
) => {
  try {
    console.log(`Creating conversation with participants: ${JSON.stringify(participantUserIdsArg)}`);
    
    const response = await apiClient.post('/conversations', {
      participantUserIds: participantUserIdsArg, // Send the array directly
      type,
      name: type === 'group' ? name : null,
    });

    console.log('Conversation created/retrieved successfully:', response.data);
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      console.error('Error in getOrCreateConversation:', error.response?.data || error.message);
    } else {
      console.error('Error in getOrCreateConversation: An unexpected error occurred', error);
    }
    throw error;
  }
};

/**
 * Sends a message to a specific conversation.
 * @param conversationId - The ID of the conversation.
 * @param content - The text content of the message.
 * @returns The newly created message object (which should include AI's response if processed by backend).
 */
export const sendMessage = async (conversationId: string, content: string) => {
  try {
    const response = await apiClient.post(`/conversations/${conversationId}/messages`, {
      content,
    });
    return response.data; // This should be the message object returned by the backend
  } catch (error) {
    if (axios.isAxiosError(error)) {
      console.error('Error in sendMessage:', error.response?.data || error.message);
    } else {
      console.error('Error in sendMessage: An unexpected error occurred', error);
    }
    throw error;
  }
};

/**
 * Fetches messages for a specific conversation.
 * @param conversationId - The ID of the conversation.
 * @param page - Page number for pagination (optional).
 * @param limit - Number of messages per page (optional).
 * @returns An object containing messages and pagination info.
 */
export const getMessages = async (conversationId: string, page = 1, limit = 20) => {
    try {
        const response = await apiClient.get(`/conversations/${conversationId}/messages`, {
            params: { page, limit },
        });
        return response.data; // Expects { messages: [], totalPages, currentPage }
    } catch (error) {
        if (axios.isAxiosError(error)) {
            console.error('Error in getMessages:', error.response?.data || error.message);
        } else {
            console.error('Error in getMessages: An unexpected error occurred', error);
        }
        throw error;
    }
};


// --- Authentication Related (Example - Adapt to your backend's auth) ---
/**
 * Example login function.
 * @param credentials - User's email and password.
 * @returns User data and token.
 */
export const login = async (credentials: { email: string; password: string }) => {
  try {
    const response = await apiClient.post('/auth/login', credentials);
    // Backend returns { accessToken, user } instead of { token, user }
    const { accessToken, user } = response.data;
    if (accessToken) {
      apiClient.setAuthToken(accessToken);
    }
    return { token: accessToken, user }; // Convert to expected format for backward compatibility
  } catch (error) {
    if (axios.isAxiosError(error)) {
      console.error('Error in login:', error.response?.data || error.message);
    } else {
      console.error('Error in login: An unexpected error occurred', error);
    }
    throw error;
  }
};

export default apiClient as ExtendedAxiosInstance;
</file>

<file path="mobile-app/src/services/socketService.ts">
// src/services/socketService.ts
import * as SocketIOClient from 'socket.io-client';

// Use the same base URL as your API service but without the /api path
const SOCKET_URL = 'http://69.120.124.150:5000';

// For emulator/simulator: const SOCKET_URL = 'http://10.0.2.2:5000';
// For local testing: const SOCKET_URL = 'http://localhost:5000';

// Define types for socket events
export interface SocketMessage {
  id: string;
  content: string;
  conversationId: string;
  UserId: string;
  createdAt: string;
  // Add other properties as needed
}

class SocketService {
  private socket: any = null;
  private token: string | null = null;

  // Initialize socket connection
  public init(token: string): void {
    if (this.socket) {
      this.disconnect();
    }

    this.token = token;
    console.log('SOCKET SERVICE: Initializing socket connection with token:', token);
    
    // Connect to the socket server with auth token
    this.socket = SocketIOClient.connect(SOCKET_URL, {
      auth: { token }, // Send token in auth object
      transports: ['websocket'], // Good for mobile
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    // Setup connection event handlers
    this.socket.on('connect', this.onConnect);
    this.socket.on('disconnect', this.onDisconnect);
    this.socket.on('connect_error', this.onConnectError);
  }

  // Event handlers
  private onConnect = (): void => {
    console.log('SOCKET SERVICE: Socket connected successfully');
  };

  private onDisconnect = (reason: string): void => {
    console.log(`SOCKET SERVICE: Socket disconnected: ${reason}`);
  };

  private onConnectError = (error: Error): void => {
    console.error('SOCKET SERVICE: Socket connection error:', error);
    console.error('SOCKET SERVICE: Check if token is valid and server is running');
  };

  // Subscribe to events
  public on(event: string, callback: (data: any) => void): void {
    if (!this.socket) {
      console.error('Socket not initialized. Call init() first.');
      return;
    }
    this.socket.on(event, callback);
  }

  // Unsubscribe from events
  public off(event: string, callback?: (data: any) => void): void {
    if (!this.socket) {
      console.error('Socket not initialized. Call init() first.');
      return;
    }
    
    if (callback) {
      this.socket.off(event, callback);
    } else {
      this.socket.off(event);
    }
  }

  // Emit events
  public emit(event: string, data: any): void {
    if (!this.socket) {
      console.error('Socket not initialized. Call init() first.');
      return;
    }
    this.socket.emit(event, data);
  }

  // Disconnect socket
  public disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }

  // Get connection status
  public isConnected(): boolean {
    return this.socket?.connected || false;
  }

  // Update auth token (e.g., after token refresh)
  public updateToken(token: string): void {
    this.token = token;
    if (this.socket) {
      this.disconnect();
      this.init(token);
    }
  }
}

// Create a singleton instance
const socketService = new SocketService();
export default socketService;
</file>

<file path="mobile-app/src/store/actions/taskActions.ts">
/**
 * taskActions.ts
 *
 * This file contains Redux action creators for task management.
 * 
 * Features:
 * - Defines action types and async thunks for task operations
 * - Implements CRUD operations (Create, Read, Update, Delete)
 * - Includes error handling for failed operations
 * - Manages loading states during async operations
 *
 * These actions use Redux Toolkit's createAsyncThunk for consistent
 * handling of async operations and are used by the tasks slice to update state.
 */

import { Task, NewTask } from '../../types/task'; 
import { createAsyncThunk } from '@reduxjs/toolkit';

// Add a new task (simulating API call)
export const addTask = createAsyncThunk<Task, NewTask>(
  'tasks/addTask',
  async (newTaskData, { rejectWithValue }) => {
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      const newTask: Task = {
        ...newTaskData,
        id: Math.random().toString(36).substr(2, 9),
        completed: newTaskData.completed || false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      return newTask;
    } catch (error) {
      return rejectWithValue('Failed to add task');
    }
  }
);

// Toggle task completion (simulating API call)
export const toggleTask = createAsyncThunk<Partial<Task>, { taskId: string; completed: boolean }>(
  'tasks/toggleTask',
  async ({ taskId, completed }, { rejectWithValue }) => {
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 300));
      
      const now = new Date().toISOString();
      // Return the updated task data, including completionDate
      return {
        id: taskId,
        completed,
        updatedAt: now,
        completionDate: completed ? now : undefined, // Set or clear completionDate
      } as Partial<Task>; // Return Partial<Task> as we're only updating some fields
    } catch (error) {
      return rejectWithValue('Failed to toggle task status');
    }
  }
);

// Load initial tasks (simulating API call)
export const fetchTasks = createAsyncThunk<Task[]>(
  'tasks/fetchTasks',
  async (_, { rejectWithValue }) => {
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Mock data - in a real app, this would come from an API
      const mockTasks: Task[] = [
        {
          id: '1',
          title: 'Complete project setup',
          description: 'Set up the project structure and dependencies',
          dueDate: new Date(Date.now() + 86400000).toISOString(),
          priority: 'high',
          completed: false,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
        {
          id: '2',
          title: 'Design UI components',
          description: 'Create mockups for the main screens',
          dueDate: new Date(Date.now() + 172800000).toISOString(),
          priority: 'medium',
          completed: true,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
      ];
      
      return mockTasks;
    } catch (error) {
      return rejectWithValue('Failed to load tasks');
    }
  }
);

// Delete a task (simulating API call)
export const deleteTask = createAsyncThunk<string, string>(
  'tasks/deleteTask',
  async (taskId, { rejectWithValue }) => {
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 300));
      return taskId;
    } catch (error) {
      return rejectWithValue('Failed to delete task');
    }
  }
);
</file>

<file path="mobile-app/src/store/rootReducer.ts">
import { combineReducers } from '@reduxjs/toolkit';
import tasksReducer from './slices/tasksSlice'; 
import authReducer from './slices/authSlice';
import { TasksState } from '../types/task'; 

// Define the auth state type
export interface AuthState {
  user: {
    id: string;
    email: string;
    username: string;
  } | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

// This will be our initial state shape
export interface RootState {
  app: {
    initialized: boolean;
  };
  tasks: TasksState;
  auth: AuthState;
}

// A simple initial reducer (can be expanded or replaced later)
const appReducer = (state = { initialized: true }, _action: any) => {
  return state;
};

// Combine all reducers
export const rootReducer = combineReducers({
  app: appReducer,
  tasks: tasksReducer,
  auth: authReducer,
});

export default rootReducer;
</file>

<file path="mobile-app/src/store/selectors/taskSelectors.ts">
/**
 * taskSelectors.ts
 *
 * This file contains selector functions to efficiently retrieve and derive data from the Redux store.
 * 
 * Features:
 * - Provides memoized selectors for performance optimization
 * - Implements reusable selector functions for common data needs
 * - Includes derived selectors for filtered and sorted task views
 * - Creates selectors for statistics (completion rate, overdue tasks)
 * - Supports type safety with TypeScript for reliable data access
 *
 * These selectors follow the selector pattern recommended by Redux,
 * using memoization to prevent unnecessary calculations when state hasn't changed.
 */

import { createSelector } from '@reduxjs/toolkit'; // or 'reselect' if preferred
import { RootState } from '../rootReducer';
import { Task } from '../../types/task';

// Selector for the entire tasks slice of the state
const selectTasksState = (state: RootState) => state.tasks;

// Selector for the list of tasks
export const selectTasks = createSelector(
  [selectTasksState],
  (tasksState) => tasksState.tasks
);

// Selector for the loading state of tasks
export const selectTasksLoading = createSelector(
  [selectTasksState],
  (tasksState) => tasksState.loading
);

// Selector for any error related to tasks
export const selectTasksError = createSelector(
  [selectTasksState],
  (tasksState) => tasksState.error
);

// Selector for the count of tasks completed today
export const selectCompletedTodayCount = createSelector(
  [selectTasks], // Input selector: all tasks
  (tasks) => {
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Start of today
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1); // Start of tomorrow

    return tasks.filter(task => {
      if (!task.completed || !task.completionDate) return false;
      const completionDate = new Date(task.completionDate);
      return completionDate >= today && completionDate < tomorrow;
    }).length;
  }
);

// Example of a more complex selector (e.g., select completed tasks)
// This can be added later as needed.
// export const selectCompletedTasks = createSelector(
//   [selectTasks],
//   (tasks) => tasks.filter(task => task.completed)
// );
</file>

<file path="mobile-app/src/store/slices/authSlice.ts">
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import AsyncStorage from '@react-native-async-storage/async-storage';
import apiClient from '../../services/apiService';

interface AuthState {
  user: {
    id: string;
    email: string;
    username: string;
  } | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  loading: boolean;
}

// Test user credentials
const TEST_USER = {
  id: 'test-user-id', // This should match the ID from your backend
  email: 'test@example.com',
  username: 'testuser',
};

const initialState: AuthState = {
  user: null,
  token: null,
  isAuthenticated: false,
  isLoading: false,
  error: null,
  loading: true, // Start with loading true to show loading indicator initially
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // We'll keep these reducers in case we need them later
    loginSuccess: (state, action: PayloadAction<{ user: any; token: string }>) => {
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.isAuthenticated = true;
      state.isLoading = false;
    },
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(checkAuthState.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(checkAuthState.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload.user;
        state.token = action.payload.token;
        state.isAuthenticated = !!action.payload.token;
      })
      .addCase(checkAuthState.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Authentication check failed';
        state.isAuthenticated = false;
        state.user = null;
        state.token = null;
      });
  },
});

// Async thunk to check if user is already authenticated
export const checkAuthState = createAsyncThunk(
  'auth/checkAuthState',
  async (_, { dispatch }) => {
    try {
      // Get token from AsyncStorage
      const token = await AsyncStorage.getItem('token');
      const userJson = await AsyncStorage.getItem('user');
      
      if (token && userJson) {
        const user = JSON.parse(userJson);
        
        // Set the token in the API client
        apiClient.setAuthToken(token);
        
        // Return the user and token
        return { user, token };
      }
      
      // For development, use test user if no stored credentials
      if (process.env.NODE_ENV === 'development') {
        console.log('DEV MODE: Using test user credentials');
        const testToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImRkZmIxZTM4LTMyODMtMTFmMC1iZWI5LWQ4YmJjMTEzMTkzZiIsInJvbGUiOiJ1c2VyIiwiaWF0IjoxNzQ3NDM4NjExLCJleHAiOjE3NDc0NDIyMTF9.v9fsjE8l11ytZhfuM_7St7O12ydjboBlipRdHpd2DG8';
        
        // Set the test token in the API client
        apiClient.setAuthToken(testToken);
        
        return { 
          user: TEST_USER,
          token: testToken
        };
      }
      
      return { user: null, token: null };
    } catch (error) {
      console.error('Error checking auth state:', error);
      return { user: null, token: null };
    }
  }
);

export const { loginSuccess, logout } = authSlice.actions;
export const selectAuth = (state: { auth: AuthState }) => state.auth;

export default authSlice.reducer;
</file>

<file path="mobile-app/src/store/slices/chatSlice.ts">
/**
 * chatSlice.ts
 * 
 * Redux slice for chat and AI coaching functionality:
 * - Defines the chat state interface and initial state
 * - Implements reducers for:
 *   - Adding user and AI messages
 *   - Storing conversation history
 *   - Tracking AI coaching style preferences
 *   - Managing offline mode state
 * - Exports action creators and the reducer
 * - Includes selectors for accessing chat state
 * 
 * This slice works with the chat service to manage AI interactions
 * and persists conversations to SQLite for history tracking.
 */

// chatSlice.ts - Chat slice will go here
</file>

<file path="mobile-app/src/store/slices/tamagotchiSlice.ts">
/**
 * tamagotchiSlice.ts
 * 
 * Redux slice for the virtual pet gamification system:
 * - Defines the pet state interface (mood, level, environment upgrades)
 * - Implements reducers for:
 *   - Updating pet mood based on user task completion
 *   - Managing pet interaction features
 *   - Tracking environment upgrades and treats
 *   - Calculating and storing streak data
 * - Exports action creators and the reducer
 * - Includes selectors for accessing pet state
 * 
 * This slice integrates with the task management system to update the pet state
 * based on user engagement and persists data to SQLite.
 */

// tamagotchiSlice.ts - Tamagotchi slice will go here
</file>

<file path="mobile-app/src/store/slices/tasksSlice.ts">
/**
 * tasksSlice.ts
 * 
 * Redux slice for task management functionality:
 * - Defines the task state interface and initial state
 * - Implements reducers for CRUD operations on tasks:
 *   - Adding new tasks
 *   - Updating existing tasks
 *   - Marking tasks as complete/incomplete
 *   - Deleting tasks
 *   - Setting recurring tasks
 *   - Filtering and sorting tasks
 * - Exports action creators and the reducer
 * - Includes selectors for accessing task state
 * 
 * This slice integrates with the SQLite service for data persistence.
 */
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { Task, TaskPriority, NewTask } from '../../types/task';
import { fetchTasks, addTask, toggleTask, deleteTask } from '../actions/taskActions';

interface TasksState {
  tasks: Task[];
  loading: boolean;
  error: string | null;
}

const initialState: TasksState = {
  tasks: [],
  loading: false,
  error: null,
};

const tasksSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    // Handle fetchTasks
    builder.addCase(fetchTasks.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchTasks.fulfilled, (state, action: PayloadAction<Task[]>) => {
      state.tasks = action.payload;
      state.loading = false;
    });
    builder.addCase(fetchTasks.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string || 'Failed to load tasks';
    });

    // Handle addTask
    builder.addCase(addTask.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(addTask.fulfilled, (state, action: PayloadAction<Task>) => {
      state.tasks.push(action.payload);
      state.loading = false;
    });
    builder.addCase(addTask.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string || 'Failed to add task';
    });

    // Handle toggleTask
    builder.addCase(toggleTask.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(toggleTask.fulfilled, (state, action: PayloadAction<Partial<Task>>) => {
      const updatedFields = action.payload;
      const taskIndex = state.tasks.findIndex(task => task.id === updatedFields.id);
      if (taskIndex !== -1) {
        // Merge the updated fields into the existing task
        state.tasks[taskIndex] = { ...state.tasks[taskIndex], ...updatedFields };
      }
      state.loading = false;
    });
    builder.addCase(toggleTask.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string || 'Failed to toggle task';
    });

    // Handle deleteTask
    builder.addCase(deleteTask.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(deleteTask.fulfilled, (state, action: PayloadAction<string>) => {
      state.tasks = state.tasks.filter(task => task.id !== action.payload);
      state.loading = false;
    });
    builder.addCase(deleteTask.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string || 'Failed to delete task';
    });
  },
});

export default tasksSlice.reducer;
</file>

<file path="mobile-app/src/store/store.ts">
import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';
import { useDispatch } from 'react-redux';
import rootReducer from './rootReducer';
import { setGetAuthTokenCallback } from '../services/apiService';

export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false, // Disabled for React Native compatibility
      immutableCheck: false, // Optional: Disable immutable check for better performance
    }),
  devTools: process.env.NODE_ENV !== 'production', // Enable Redux DevTools in development
});

// Set up the callback to get the auth token from the store
// This breaks the circular dependency between store and apiService
setGetAuthTokenCallback(() => {
  const state = store.getState();
  return state.auth.token;
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof rootReducer>;
export type AppDispatch = typeof store.dispatch;

// Export a hook that can be reused to resolve types
export const useAppDispatch = () => useDispatch<AppDispatch>();

// Define a standard Thunk type
export type AppThunk<ReturnType = void> = ThunkAction<
  ReturnType,
  RootState,
  unknown,
  Action<string>
>;
</file>

<file path="mobile-app/src/theme/index.ts">
import { MD3LightTheme, MD3DarkTheme } from 'react-native-paper';

export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    primary: '#6200ee', // Example primary color
    accent: '#03dac6',  // Example accent color (might be 'secondary' in MD3)
    // You can customize other colors here
  },
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    primary: '#bb86fc', // Example primary color for dark theme
    accent: '#03dac6',  // Example accent color for dark theme
    // You can customize other colors here
  },
};

// Default theme can be set here, or dynamically chosen later
// For now, let's keep it simple and assume App.tsx will pick one.
</file>

<file path="mobile-app/src/types/task.ts">
/**
 * task.ts
 *
 * This file defines TypeScript interfaces and types for tasks in the Coach Ally app.
 * It includes:
 * - Task interface: Main data structure for individual tasks
 * - TaskPriority type: Enumeration of possible priority levels
 * - TaskState interface: Structure for the tasks slice of the Redux store
 *
 * These types ensure consistency in data handling throughout the application
 * and provide type safety for task-related operations.
 */

export interface Task {
  id: string; // Unique identifier for the task
  title: string; // Main title or name of the task
  description?: string; // Optional detailed description of the task
  completed: boolean; // Status of whether the task is completed
  dueDate?: string | null; // Optional due date for the task (ISO string format)
  priority: 'low' | 'medium' | 'high'; // Priority level of the task
  createdAt: string; // Timestamp of when the task was created (ISO string format)
  updatedAt: string; // Timestamp of the last update (ISO string format)
  completionDate?: string; // Timestamp of when the task was completed (ISO string format)
  // Future enhancements could include:
  // subtasks: Task[];
  // recurring: boolean;
  // recurrenceRule: string; // e.g., RRule string
  // tags: string[];
}

export type TaskPriority = Task['priority'];

export interface TasksState {
  tasks: Task[]; // Array of task objects
  loading: boolean; // Indicates if tasks are currently being loaded or modified
  error: string | null; // Stores any error message related to task operations
}

export const TASK_PRIORITIES: TaskPriority[] = ['low', 'medium', 'high'];

// Example of a new task object structure, useful for creation forms
export interface NewTask {
  title: string;
  description?: string;
  priority: TaskPriority;
  dueDate?: string;
  completed?: boolean;
  projectId?: string;
}
</file>

<file path="mobile-app/tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
</file>

<file path="backend/__tests__/__factories__/conversationFactory.js">
/**
 * Factory for creating test conversation instances.
 * Provides methods to generate mock conversation data with various states for testing.
 */
</file>

<file path="backend/__tests__/__factories__/messageFactory.js">
/**
 * Factory for creating test message instances.
 * Provides methods to generate mock message data with various content types and states.
 */
</file>

<file path="backend/__tests__/__factories__/userFactory.js">
/**
 * Factory for creating test user instances.
 * Provides methods to generate mock user data for testing purposes.
 */
</file>

<file path="backend/__tests__/__helpers__/testSetup.js">
/**
 * Test setup and teardown utilities.
 * Handles database connection, test environment configuration, and cleanup routines.
 */
</file>

<file path="backend/__tests__/__helpers__/testUtils.js">
/**
 * Common test utilities and helper functions.
 * Contains shared test assertions, mocks, and utility functions used across test suites.
 */
</file>

<file path="backend/__tests__/integration/api/conversations.test.js">
/**
 * Integration tests for /api/conversations endpoints
 * Tests the complete flow of conversation-related API endpoints including request/response cycles.
 */
</file>

<file path="backend/__tests__/integration/api/messages.test.js">
/**
 * Integration tests for /api/conversations/:conversationId/messages endpoints
 * Tests the complete flow of message-related API endpoints and their interactions with the database.
 */
</file>

<file path="backend/__tests__/integration/api/participants.test.js">
/**
 * Integration tests for /api/conversations/:conversationId/participants endpoints
 * Tests the complete flow of participant management API endpoints and their database interactions.
 */
</file>

<file path="backend/__tests__/unit/middleware/validators/conversationValidator.test.js">
/**
 * Unit tests for conversationValidator.js
 * Tests request validation for conversation-related endpoints including request body and parameter validation.
 */
</file>

<file path="backend/__tests__/unit/middleware/validators/messageValidator.test.js">
/**
 * Unit tests for messageValidator.js
 * Tests request validation for message-related endpoints including message content and query parameters.
 */
</file>

<file path="backend/__tests__/unit/middleware/validators/participantValidator.test.js">
/**
 * Unit tests for participantValidator.js
 * Tests request validation for participant management endpoints including add/remove operations.
 */
</file>

<file path="backend/__tests__/unit/services/conversationService.test.js">
/**
 * Unit tests for conversationService.js
 * Tests core conversation business logic including creation, retrieval, and management of conversations.
 */
</file>

<file path="backend/__tests__/unit/services/messageService.test.js">
/**
 * Unit tests for messageService.js
 * Tests core message handling logic including sending, retrieving, and managing message statuses.
 */
</file>

<file path="backend/__tests__/unit/services/participantService.test.js">
/**
 * Unit tests for participantService.js
 * Tests participant management logic including adding and removing participants from conversations.
 */
</file>

<file path="backend/.sequelizerc">
const path = require('path');

module.exports = {
  'config': path.resolve('config', 'config.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('seeders'),
  'migrations-path': path.resolve('migrations')
};
</file>

<file path="backend/config/passport.js">
/**
 * Passport.js configuration for authentication strategies.
 * 
 * This module sets up JWT and Local authentication strategies using Passport.js.
 * It handles user authentication, token verification, and session management.
 * 
 * @module config/passport
 * @requires passport
 * @requires passport-jwt
 * @requires passport-local
 * @requires jsonwebtoken
 * @requires ../models/User
 * @requires ./config
 */

// File will be implemented with:
// 1. JWT Strategy for token-based authentication
// 2. Local Strategy for username/password login
// 3. Helper functions for token generation and verification
// 4. Serialization/deserialization of users

// Implementation details will be added when developing the authentication system
</file>

<file path="backend/controllers/authController.js">
/**
 * Authentication Controller
 * 
 * Handles user authentication including registration, login, token refresh, and logout.
 * Manages JWT token generation and refresh token rotation.
 * 
 * @module controllers/authController
 * @requires jsonwebtoken
 * @requires bcryptjs
 * @requires ../models/User
 * @requires ../utils/logger
 * @requires ../utils/validators
 * @requires ../config/config
 * 
 * @example
 * // Example routes that use this controller:
 * POST /api/auth/register - Register a new user
 * POST /api/auth/login - User login
 * POST /api/auth/refresh-token - Refresh access token
 * POST /api/auth/logout - Invalidate refresh token
 */

const authService = require('../services/authService');
const logger = require('../utils/logger');
const httpStatusCodes = require('http-status-codes');
const config = require('../config/config'); // For cookie options

// Helper to set refresh token cookie
const setRefreshTokenCookie = (res, refreshToken) => {
  res.cookie('refreshToken', refreshToken, {
    ...config.jwt.cookieOptions,
    maxAge: config.jwt.refreshExpirationDays * 24 * 60 * 60 * 1000, // in milliseconds
  });
};

/**
 * @desc    Register a new user
 * @route   POST /api/auth/register
 * @access  Public
 */
const register = async (req, res, next) => {
  try {
    const { username, email, password, first_name, last_name } = req.body; // Using snake_case to match request body
    // Basic validation - more robust validation should be in middleware
    if (!username || !email || !password) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Username, email, and password are required.' });
    }

    const user = await authService.registerUser({ 
      username, 
      email, 
      password, 
      first_name, 
      last_name 
    });
    
    // Optionally, log the user in immediately and send tokens
    // For now, just return the created user, client can then proceed to login
    logger.info(`User registered: ${user.email}`);
    res.status(httpStatusCodes.CREATED).json(user); // User object is sanitized by toJSON in model
  } catch (error) {
    // Errors from authService (like BadRequestError for existing user) will be caught here
    // The global errorHandler middleware should handle ApiError instances
    next(error); 
  }
};

/**
 * @desc    Authenticate user & get token
 * @route   POST /api/auth/login
 * @access  Public
 */
const login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Email and password are required.' });
    }

    const { user, tokens } = await authService.loginUser(email, password);

    setRefreshTokenCookie(res, tokens.refreshToken);

    logger.info(`User logged in: ${user.email}`);
    res.status(httpStatusCodes.OK).json({
      accessToken: tokens.accessToken,
      user: user, // User object is sanitized by toJSON in model
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Refresh access token
 * @route   POST /api/auth/refresh-token
 * @access  Public (requires valid refresh token cookie)
 */
const refreshToken = async (req, res, next) => {
  try {
    const oldRefreshToken = req.cookies?.refreshToken;
    if (!oldRefreshToken) {
      return res.status(httpStatusCodes.UNAUTHORIZED).json({ message: 'Refresh token not found.' });
    }

    const newTokens = await authService.refreshAuthTokens(oldRefreshToken);

    setRefreshTokenCookie(res, newTokens.refreshToken);

    logger.info('Access token refreshed successfully.');
    res.status(httpStatusCodes.OK).json({
      accessToken: newTokens.accessToken,
    });
  } catch (error) {
    // If refresh token is invalid/expired, authService throws UnauthorizedError
    // Clear the cookie if the refresh token is bad
    if (error.statusCode === httpStatusCodes.UNAUTHORIZED || error.statusCode === httpStatusCodes.BAD_REQUEST) {
      res.clearCookie('refreshToken', config.jwt.cookieOptions);
    }
    next(error);
  }
};

/**
 * @desc    Logout user (invalidate refresh token)
 * @route   POST /api/auth/logout
 * @access  Private (requires authentication)
 */
const logout = async (req, res, next) => {
  try {
    // req.user.id should be available if a protect middleware has run
    const userId = req.user?.id; 
    if (!userId) {
      // This case should ideally not be hit if route is protected properly
      logger.warn('Logout attempt without authenticated user ID.');
      return res.status(httpStatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated for logout.' });
    }

    await authService.logoutUser(userId);

    res.clearCookie('refreshToken', config.jwt.cookieOptions);
    
    logger.info(`User logged out: ${userId}`);
    res.status(httpStatusCodes.OK).json({ message: 'Logged out successfully.' });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Request password reset (generates token and sends email - simulated)
 * @route   POST /api/auth/request-password-reset
 * @access  Public
 */
const requestPasswordReset = async (req, res, next) => {
  try {
    const { email } = req.body;
    if (!email) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Email is required.' });
    }

    const resetToken = await authService.requestPasswordReset(email);

    // In a real app, an email would be sent here with the resetToken.
    // For now, we'll just log it and send a success response.
    // The actual token is not sent back to the client for security reasons (it's in the email link).
    logger.info(`Password reset requested for email: ${email}. Token (for email link): ${resetToken}`);
    res.status(httpStatusCodes.OK).json({ message: 'If your email is registered, you will receive a password reset link shortly.' });
  } catch (error) {
    // To prevent email enumeration, we might want to always return a generic success message
    // even if the email is not found. The service throws NotFoundError if email doesn't exist.
    // For this implementation, if a NotFoundError is specifically for the user, we return the generic message.
    if (error.name === 'NotFoundError' && error.message.includes('User with this email not found')) {
        logger.warn(`Password reset attempt for non-existent email: ${req.body.email} - returning generic success`);
        return res.status(httpStatusCodes.OK).json({ message: 'If your email is registered, you will receive a password reset link shortly.' });
    }
    next(error);
  }
};

/**
 * @desc    Reset password using token
 * @route   POST /api/auth/reset-password/:token
 * @access  Public
 */
const resetPassword = async (req, res, next) => {
  try {
    const { token } = req.params;
    const { newPassword } = req.body;

    if (!token || !newPassword) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Token and new password are required.' });
    }

    await authService.resetPassword(token, newPassword);

    logger.info('Password has been reset successfully.');
    res.status(httpStatusCodes.OK).json({ message: 'Password has been reset successfully. You can now login with your new password.' });
  } catch (error) {
    // Handles invalid/expired token errors from the service
    next(error);
  }
};

/**
 * @desc    Request email verification link (simulated email sending)
 * @route   POST /api/auth/request-email-verification
 * @access  Private (requires authentication)
 */
const requestEmailVerification = async (req, res, next) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      // Should be caught by protect middleware, but as a safeguard:
      return res.status(httpStatusCodes.UNAUTHORIZED).json({ message: 'User not authenticated.' });
    }

    const verificationToken = await authService.requestEmailVerification(userId);

    // In a real app, an email would be sent here with the verificationToken.
    logger.info(`Email verification requested for user: ${userId}. Token (for email link): ${verificationToken}`);
    res.status(httpStatusCodes.OK).json({ message: 'A new verification link has been sent to your email address (simulated).' });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Verify email using token
 * @route   GET /api/auth/verify-email/:token  (GET is common for clicking a link)
 * @access  Public
 */
const verifyEmail = async (req, res, next) => {
  try {
    const { token } = req.params;
    if (!token) {
      return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Verification token is required.' });
    }

    await authService.verifyEmail(token);

    logger.info('Email verified successfully.');
    // In a real app, you might redirect to a 'verified successfully' page or login.
    res.status(httpStatusCodes.OK).json({ message: 'Email has been verified successfully. You can now login.' });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  register,
  login,
  refreshToken,
  logout,
  requestPasswordReset,
  resetPassword,
  requestEmailVerification,
  verifyEmail,
};
</file>

<file path="backend/controllers/conversationController.js">
// Handles HTTP requests related to conversations and delegates to conversationService
const conversationService = require('../services/conversationService');
const logger = require('../utils/logger'); // Assuming a logger utility

/**
 * @description Create a new conversation or return an existing direct conversation.
 * @route POST /api/conversations
 * @access Private
 */
const createConversationHandler = async (req, res) => {
    // Assuming auth middleware adds user object to request, containing id
    const creatorId = req.user.id;
    const { participantUserIds, type = 'direct', name = null } = req.body;

    if (!participantUserIds || !Array.isArray(participantUserIds) || (type === 'direct' && participantUserIds.length !== 1)) {
        // For direct, participantUserIds should contain the *other* user's ID.
        // The service layer will combine creatorId and this single participantId for a direct chat.
        // Or, if participantUserIds is meant to be an array of all participants *excluding* creator, adjust accordingly.
        // For this implementation, let's assume participantUserIds = [otherUserId] for direct chat.
        let message = 'ParticipantUserIds array is required.';
        if (type === 'direct' && (!participantUserIds || participantUserIds.length !== 1)) {
            message = 'For direct conversations, participantUserIds must be an array containing exactly one other user ID.';
        }
        return res.status(400).json({ message });
    }
    
    // The service expects a list of *all* participants for a direct chat (creator + other)
    // So, if client sends only the other user, we add the creatorId here.
    // If client sends all participants already, ensure creator is one of them (service also does this).
    let allParticipantIdsForService = [];
    if (type === 'direct') {
        allParticipantIdsForService = [creatorId, participantUserIds[0]];
    } else {
        allParticipantIdsForService = Array.from(new Set([creatorId, ...participantUserIds]));
    }

    try {
        const conversation = await conversationService.createConversation(creatorId, allParticipantIdsForService, type, name);
        // Check if it's a newly created conversation or an existing one returned
        // Sequelize's isNewRecord is true only if it was just created. If an existing direct chat was found, it's false.
        const statusCode = conversation.isNewRecord === false ? 200 : 201; 
        res.status(statusCode).json(conversation);
    } catch (error) {
        logger.error('Error in createConversationHandler:', error);
        if (error.message.includes('must have exactly two participants') || error.message.includes('must have a name')) {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to create conversation', error: error.message });
    }
};

/**
 * @description Get all conversations for the logged-in user.
 * @route GET /api/conversations
 * @access Private
 */
const getUserConversationsHandler = async (req, res) => {
    const userId = req.user.id;
    const { page = 1, limit = 20 } = req.query;

    try {
        const result = await conversationService.getUserConversations(userId, { 
            page: parseInt(page, 10),
            limit: parseInt(limit, 10) 
        });
        res.status(200).json(result);
    } catch (error) {
        logger.error('Error in getUserConversationsHandler:', error);
        res.status(500).json({ message: 'Failed to retrieve conversations', error: error.message });
    }
};

/**
 * @description Get a specific conversation by ID.
 * @route GET /api/conversations/:id
 * @access Private (User must be a participant)
 */
const getConversationByIdHandler = async (req, res) => {
    const userId = req.user.id;
    const { id: conversationId } = req.params;

    try {
        const conversation = await conversationService.getConversationById(conversationId, userId);
        if (!conversation) {
            return res.status(404).json({ message: 'Conversation not found.' });
        }
        res.status(200).json(conversation);
    } catch (error) {
        logger.error(`Error in getConversationByIdHandler for conversation ${conversationId}:`, error);
        if (error.status === 403) {
            return res.status(403).json({ message: error.message }); // Access denied message from service
        }
        if (error.message.includes('not found')) { // Catch generic not found if not handled by service's null return
             return res.status(404).json({ message: 'Conversation not found.' });
        }
        res.status(500).json({ message: 'Failed to retrieve conversation', error: error.message });
    }
};

module.exports = {
    createConversationHandler,
    getUserConversationsHandler,
    getConversationByIdHandler,
};
</file>

<file path="backend/controllers/participantController.js">
// Handles HTTP requests for participant management and delegates to participantService
const participantService = require('../services/participantService');
const logger = require('../utils/logger');

/**
 * @description Add participants to a group conversation.
 * @route POST /api/conversations/:conversationId/participants
 * @access Private (Typically, only creator or authorized users)
 */
const addParticipantsHandler = async (req, res) => {
    const requesterId = req.user.id;
    const { conversationId } = req.params;
    const { userIdsToAdd } = req.body;

    if (!userIdsToAdd || !Array.isArray(userIdsToAdd) || userIdsToAdd.length === 0) {
        return res.status(400).json({ message: 'userIdsToAdd must be a non-empty array.' });
    }

    try {
        const updatedConversation = await participantService.addParticipants(requesterId, conversationId, userIdsToAdd);
        // TODO: Emit WebSocket event to notify existing participants and newly added ones.
        // Example: req.io.to(conversationId).emit('participantsAdded', { conversationId, addedUserIds: userIdsToAdd, updatedConversation });
        // Notify each newly added user individually as well so their client can join the room/update UI
        // userIdsToAdd.forEach(uid => req.io.to(uid).emit('addedToConversation', updatedConversation));
        res.status(200).json(updatedConversation);
    } catch (error) {
        logger.error(`Error in addParticipantsHandler for conversation ${conversationId}:`, error);
        if (error.status === 403) {
            return res.status(403).json({ message: error.message });
        }
        if (error.message.includes('not found') || error.message.includes('do not exist')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message.includes('only be added to group') || error.message.includes('already in conversation')) {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to add participants', error: error.message });
    }
};

/**
 * @description Remove a participant from a group conversation.
 * @route DELETE /api/conversations/:conversationId/participants/:userId
 * @access Private (Creator can remove others; user can remove themselves)
 */
const removeParticipantHandler = async (req, res) => {
    const requesterId = req.user.id;
    const { conversationId, userId: userIdToRemove } = req.params;

    if (!userIdToRemove) {
        return res.status(400).json({ message: 'User ID to remove is required in the path.' });
    }

    try {
        const result = await participantService.removeParticipant(requesterId, conversationId, userIdToRemove);
        // TODO: Emit WebSocket event to notify remaining participants and the removed user.
        // Example: req.io.to(conversationId).emit('participantRemoved', { conversationId, removedUserId: userIdToRemove, updatedConversation: result.conversation });
        // Notify the removed user so their client can leave the room/update UI
        // req.io.to(userIdToRemove).emit('removedFromConversation', { conversationId });
        res.status(200).json(result); // result contains { message, conversation }
    } catch (error) {
        logger.error(`Error in removeParticipantHandler for conversation ${conversationId}, user ${userIdToRemove}:`, error);
        if (error.status === 403) {
            return res.status(403).json({ message: error.message });
        }
        if (error.message.includes('not found') || error.message.includes('not a participant')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message.includes('only be removed from group') || error.message.includes('Cannot remove the last participant')) {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to remove participant', error: error.message });
    }
};

module.exports = {
    addParticipantsHandler,
    removeParticipantHandler,
};
</file>

<file path="backend/controllers/userController.js">
/**
 * User Controller
 * 
 * Handles user-related operations such as profile management and user data retrieval.
 * Provides endpoints for CRUD operations on user accounts.
 * 
 * @module controllers/userController
 * @requires jsonwebtoken
 * @requires ../models/User
 * @requires ../utils/logger
 * @requires ../middleware/auth
 * 
 * @example
 * // Example routes that use this controller:
 * GET    /api/users/me - Get current user profile
 * PUT    /api/users/me - Update current user
 * GET    /api/users/:userId - Get user by ID (admin only)
 * DELETE /api/users/:userId - Delete user (admin only)
 */

// File will be implemented with:
// 1. Get current user profile
// 2. Update user profile
// 3. Change password
// 4. Admin-only user management endpoints
// 5. User search and filtering

// Implementation will include proper authorization checks and validation
</file>

<file path="backend/docs/api-specification.yml">
# OpenAPI/Swagger specification for the chat API
</file>

<file path="backend/middleware/authValidators.js">
const Joi = require('joi');
const httpStatusCodes = require('http-status-codes');
const { BadRequestError } = require('../utils/errors'); // Path adjusted to .. from middleware directory

// Middleware to handle Joi validation
const validate = (schema, property = 'body') => {
  return (req, res, next) => {
    const dataToValidate = req[property];
    const { error, value } = schema.validate(dataToValidate, { abortEarly: false });

    if (error) {
      const errorMessage = error.details.map((detail) => detail.message).join(', ');
      return next(new BadRequestError(errorMessage));
    }
    req[property] = value; 
    next();
  };
};

// --- Individual Validation Schemas ---

const registrationSchema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(8).required()
    .messages({
      'string.min': 'Password must be at least 8 characters long.',
    }),
  first_name: Joi.string().min(1).max(50).optional().allow('').default(''),
  last_name: Joi.string().min(1).max(50).optional().allow('').default(''),
});

const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required(),
});

const emailSchema = Joi.object({
  email: Joi.string().email().required(),
});

const passwordResetSchemaBody = Joi.object({
  newPassword: Joi.string().min(8).required()
    .messages({
      'string.min': 'New password must be at least 8 characters long.',
    }),
});
const passwordResetSchemaParams = Joi.object({
    token: Joi.string().hex().length(64).required(), 
});

const tokenSchemaParams = Joi.object({
  token: Joi.string().hex().length(64).required(), 
});


module.exports = {
  validateRegistration: validate(registrationSchema, 'body'),
  validateLogin: validate(loginSchema, 'body'),
  validateEmail: validate(emailSchema, 'body'), 
  validatePasswordReset: [
    validate(passwordResetSchemaParams, 'params'), 
    validate(passwordResetSchemaBody, 'body')
  ],
  validateToken: validate(tokenSchemaParams, 'params'), 
};
</file>

<file path="backend/middleware/errorHandler.js">
/**
 * Error Handling Middleware
 * 
 * Centralized error handling for the application.
 * Catches and processes errors, returning appropriate HTTP responses.
 * 
 * @module middleware/errorHandler
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // In your Express app:
 * const { errorHandler } = require('./middleware/errorHandler');
 * 
 * // After all routes:
 * app.use(errorHandler);
 */

// File will be implemented with:
// 1. Error classification (validation, authentication, not found, etc.)
// 2. Error logging with appropriate context
// 3. User-friendly error responses in development/production
// 4. Standardized error format
// 5. Handling of unhandled promise rejections

// Implementation will include proper error serialization and status codes
</file>

<file path="backend/middleware/validation.js">
/**
 * Validation Middleware
 * 
 * Middleware for validating request payloads using Joi schemas.
 * Ensures data integrity before processing requests.
 * 
 * @module middleware/validation
 * @requires joi
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Define a validation schema
 * const userSchema = {
 *   body: Joi.object({
 *     username: Joi.string().required(),
 *     email: Joi.string().email().required(),
 *     password: Joi.string().min(8).required()
 *   })
 * };
 * 
 * // Apply to route
 * router.post('/users', validate(userSchema), userController.createUser);
 */

// File will be implemented with:
// 1. Request validation (body, params, query)
// 2. Custom validation rules
// 3. Sanitization of input data
// 4. Detailed validation error messages
// 5. Support for file uploads validation

// Implementation will include proper error formatting
</file>

<file path="backend/middleware/validators/commonValidator.js">
// backend/middleware/validators/commonValidator.js
const { validationResult } = require('express-validator');
const httpStatusCodes = require('http-status-codes');

/**
 * Middleware to handle the result of express-validator validations.
 * If errors exist, sends a 400 response. Otherwise, passes to the next middleware.
 */
const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(httpStatusCodes.BAD_REQUEST).json({ errors: errors.array() });
    }
    next();
};

module.exports = {
    validateRequest
};
</file>

<file path="backend/middleware/validators/conversationValidator.js">
// Request validation for conversation endpoints

// Handles request validation for conversation endpoints
const { body, param, validationResult } = require('express-validator');

const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};

const createConversationRules = () => [
    body('type')
        .optional()
        .isIn(['direct', 'group'])
        .withMessage("Type must be 'direct' or 'group'."),
    body('name')
        .if(body('type').equals('group'))
        .notEmpty()
        .withMessage('Name is required for group conversations.')
        .isString()
        .withMessage('Name must be a string.')
        .optional({ checkFalsy: true }), // Allow it to be absent if type is not 'group'
    body('participantUserIds')
        .isArray({ min: 1 })
        .withMessage('participantUserIds must be an array with at least one user ID.')
        .custom((value, { req }) => {
            if (req.body.type === 'direct' || (!req.body.type && value.length > 0)) { // Default to direct if type not specified
                if (value.length !== 1) {
                    throw new Error('For direct conversations, participantUserIds must contain exactly one user ID.');
                }
            }
            // For group chats, participantUserIds can have multiple IDs (min 1 checked by isArray)
            return true;
        }),
    body('participantUserIds.*') // Validate each element in the array
        .isString() // Or isUUID() if your IDs are UUIDs
        .withMessage('Each participant user ID must be a string (or a valid ID format).')
];

const getConversationByIdRules = () => [
    param('id')
        .notEmpty()
        .withMessage('Conversation ID cannot be empty.')
        .isString() // or .isUUID() if applicable
        .withMessage('Conversation ID must be a valid string (or UUID).')
];

module.exports = {
    validateRequest,
    createConversationRules,
    getConversationByIdRules,
};
</file>

<file path="backend/middleware/validators/messageValidator.js">
// Handles request validation for message endpoints
const { body, param, query, validationResult } = require('express-validator');

const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};

const sendMessageRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    body('content')
        .notEmpty().withMessage('Message content cannot be empty.')
        .isString().withMessage('Content must be a string.'),
    body('type')
        .optional()
        .isString().withMessage('Message type must be a string.')
        .isIn(['text', 'image', 'file', 'audio', 'video', 'system'])
        .withMessage("Invalid message type. Allowed types: 'text', 'image', 'file', 'audio', 'video', 'system'."),
    body('metadata')
        .optional()
        .isObject().withMessage('Metadata must be an object.')
];

const getMessagesRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    query('page')
        .optional()
        .isInt({ min: 1 }).withMessage('Page must be a positive integer.')
        .toInt(),
    query('limit')
        .optional()
        .isInt({ min: 1, max: 100 }).withMessage('Limit must be an integer between 1 and 100.')
        .toInt(),
    query('beforeMessageId')
        .optional()
        .isString().withMessage('beforeMessageId must be a string (or valid ID format).') // Or .isUUID()
        .custom((value, { req }) => {
            if (value && (req.query.page || req.query.afterMessageId)) {
                throw new Error('beforeMessageId cannot be used with page-based pagination or afterMessageId.');
            }
            return true;
        }),
    query('afterMessageId')
        .optional()
        .isString().withMessage('afterMessageId must be a string (or valid ID format).') // Or .isUUID()
        .custom((value, { req }) => {
            if (value && (req.query.page || req.query.beforeMessageId)) {
                throw new Error('afterMessageId cannot be used with page-based pagination or beforeMessageId.');
            }
            return true;
        })
];

const markMessagesAsReadRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    body('lastReadMessageId')
        .optional({ checkFalsy: true }) // Allows null or empty string to be considered 'absent'
        .isString().withMessage('lastReadMessageId must be a string (or valid ID format) if provided.') // Or .isUUID()
];

module.exports = {
    validateRequest,
    sendMessageRules,
    getMessagesRules,
    markMessagesAsReadRules,
};
</file>

<file path="backend/middleware/validators/participantValidator.js">
// Handles request validation for participant management endpoints
const { body, param, validationResult } = require('express-validator');

const validateRequest = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};

const addParticipantsRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    body('userIdsToAdd')
        .isArray({ min: 1 }).withMessage('userIdsToAdd must be an array with at least one user ID.')
        .custom((value) => {
            if (!value.every(id => typeof id === 'string')) { // Or check for UUID format
                throw new Error('All user IDs in userIdsToAdd must be strings (or valid ID format).');
            }
            return true;
        })
];

const removeParticipantRules = () => [
    param('conversationId')
        .notEmpty().withMessage('Conversation ID is required.')
        .isString().withMessage('Conversation ID must be a string (or valid ID format).'), // Or .isUUID()
    param('userId')
        .notEmpty().withMessage('User ID to remove is required.')
        .isString().withMessage('User ID to remove must be a string (or valid ID format).') // Or .isUUID()
];

module.exports = {
    validateRequest,
    addParticipantsRules,
    removeParticipantRules,
};
</file>

<file path="backend/middleware/websocket/errorHandler.js">
/**
 * WebSocket error handling middleware
 * Centralizes error handling for WebSocket events
 * Logs errors and sends appropriate error responses to clients
 */
</file>

<file path="backend/migrations/20250516003134-create-users.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('users', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      username: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true,
      },
      email: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true,
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      first_name: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      last_name: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('users');
  }
};
</file>

<file path="backend/migrations/20250516003411-create-conversations.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('conversations', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('conversations');
  }
};
</file>

<file path="backend/migrations/20250516003459-create-messages.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('messages', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false,
      },
      sender_id: {
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      conversation_id: {
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'conversations',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      is_read: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false,
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW,
      },
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('messages');
  }
};
</file>

<file path="backend/migrations/20250516003800-create-user-conversation.js">
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('UserConversations', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true,
        allowNull: false,
      },
      user_id: {
        type: Sequelize.UUID,
        allowNull: false,
        field: 'user_id',
        references: {
          model: 'Users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      conversation_id: {
        type: Sequelize.UUID,
        allowNull: false,
        field: 'conversation_id',
        references: {
          model: 'Conversations',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        field: 'created_at',
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        field: 'updated_at',
      },
    });

    // Add composite unique index using the correct column names
    await queryInterface.addIndex('UserConversations', ['user_id', 'conversation_id'], {
      unique: true,
      name: 'user_conversation_unique'
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('UserConversations');
  }
};
</file>

<file path="backend/migrations/20250516052212-add-auth-fields-to-user.js">
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('users', 'passwordResetToken', {
      type: Sequelize.STRING,
      allowNull: true
    });

    await queryInterface.addColumn('users', 'passwordResetExpires', {
      type: Sequelize.DATE,
      allowNull: true
    });

    await queryInterface.addColumn('users', 'emailVerificationToken', {
      type: Sequelize.STRING,
      allowNull: true
    });

    await queryInterface.addColumn('users', 'emailVerificationTokenExpires', {
      type: Sequelize.DATE,
      allowNull: true
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('users', 'passwordResetToken');
    await queryInterface.removeColumn('users', 'passwordResetExpires');
    await queryInterface.removeColumn('users', 'emailVerificationToken');
    await queryInterface.removeColumn('users', 'emailVerificationTokenExpires');
  }
};
</file>

<file path="backend/migrations/20250516090000-add-missing-user-columns.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('users', 'role', {
      type: Sequelize.ENUM('user', 'admin'),
      allowNull: false,
      defaultValue: 'user',
    });

    await queryInterface.addColumn('users', 'is_email_verified', {
      type: Sequelize.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    });

    await queryInterface.addColumn('users', 'last_login', {
      type: Sequelize.DATE,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'refresh_token', {
      type: Sequelize.STRING,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'password_reset_token', {
      type: Sequelize.STRING,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'password_reset_expires', {
      type: Sequelize.DATE,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'email_verification_token', {
      type: Sequelize.STRING,
      allowNull: true,
    });

    await queryInterface.addColumn('users', 'email_verification_token_expires', {
      type: Sequelize.DATE,
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('users', 'role');
    await queryInterface.removeColumn('users', 'is_email_verified');
    await queryInterface.removeColumn('users', 'last_login');
    await queryInterface.removeColumn('users', 'refresh_token');
    await queryInterface.removeColumn('users', 'password_reset_token');
    await queryInterface.removeColumn('users', 'password_reset_expires');
    await queryInterface.removeColumn('users', 'email_verification_token');
    await queryInterface.removeColumn('users', 'email_verification_token_expires');
  }
};
</file>

<file path="backend/migrations/20250516090001-update-conversations-table.js">
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Add the 'type' column
    await queryInterface.addColumn('conversations', 'type', {
      type: Sequelize.ENUM('direct', 'group'),
      defaultValue: 'direct',
      allowNull: false
    });

    // Add the 'name' column
    await queryInterface.addColumn('conversations', 'name', {
      type: Sequelize.STRING,
      allowNull: true
    });

    // Add the 'createdBy' column
    await queryInterface.addColumn('conversations', 'createdBy', {
      type: Sequelize.UUID,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE'
    });

    // Add index for better performance
    await queryInterface.addIndex('conversations', ['createdBy']);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('conversations', 'type');
    await queryInterface.removeColumn('conversations', 'name');
    await queryInterface.removeIndex('conversations', ['createdBy']);
    await queryInterface.removeColumn('conversations', 'createdBy');
  }
};
</file>

<file path="backend/migrations/20250516234001-add-parent-message-id-to-messages.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('messages', 'parent_message_id', {
      type: Sequelize.UUID,
      allowNull: true,
      references: {
        model: 'messages', // Self-referencing
        key: 'id',
      },
      onUpdate: 'CASCADE',
      onDelete: 'SET NULL', // Or 'CASCADE' if you want replies deleted with parent
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('messages', 'parent_message_id');
  }
};
</file>

<file path="backend/migrations/20250516234933-add-metadata-to-messages.js">
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('messages', 'metadata', { // Ensure table name 'messages' is correct
      type: Sequelize.JSON, // Use Sequelize.JSON for MySQL compatibility
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('messages', 'metadata');
  }
};
</file>

<file path="backend/models/index.js">
'use strict';

/**
 * Models Index
 * 
 * This file initializes all Sequelize models and their relationships.
 * It automatically imports all model files from this directory and sets up associations.
 * 
 * @module models/index
 * @requires fs
 * @requires path
 * @requires sequelize
 * @requires process
 * @requires ../config/config
 * 
 * @example
 * // Example usage:
 * const { User, Conversation, Message } = require('./models');
 * // Now you can use the models with their associations set up
 */

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];

// Initialize an empty database object to hold all models
const db = {};

// Create Sequelize instance with configuration
let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(
    config.database,
    config.username,
    config.password,
    config
  );
}

// Import all model files from this directory
fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 && // Skip hidden files
      file !== basename && // Skip this file
      file.slice(-3) === '.js' && // Only .js files
      file.indexOf('.test.js') === -1 // Skip test files
    );
  })
  .forEach(file => {
    // Import each model file
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model; // Add model to the db object
  });

// Set up model associations if they exist
Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

// Add Sequelize instance and class to the db object
db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
</file>

<file path="backend/models/Task.js">
'use strict';
const { Model } = require('sequelize');

module.exports = (sequelize, DataTypes) => {
  class Task extends Model {
    static associate(models) {
      // No direct association with User model since it's in a different database
    }
  }

  Task.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    userId: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'Users', // This is a logical reference, not a DB constraint
        key: 'id'
      }
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true,
        len: [1, 255]
      }
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: true
    },
    dueDate: {
      type: DataTypes.DATE,
      allowNull: true
    },
    priority: {
      type: DataTypes.ENUM('low', 'medium', 'high'),
      defaultValue: 'medium'
    },
    completed: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    category: {
      type: DataTypes.STRING,
      allowNull: true
    },
    metadata: {
      type: DataTypes.JSON,
      allowNull: true
    }
  }, {
    sequelize,
    modelName: 'Task',
    tableName: 'tasks',
    timestamps: true,
    underscored: true,
    indexes: [
      {
        fields: ['user_id']
      },
      {
        fields: ['due_date']
      },
      {
        fields: ['completed']
      }
    ]
  });

  return Task;
};
</file>

<file path="backend/README.md">
# Coach Ally Backend

## Project Structure

```
backend/
 config/               # Configuration files
 controllers/          # Request handlers
 middleware/           # Express middleware
 models/               # Sequelize models
 routes/               # API routes
 services/             # Business logic
 utils/                # Utility functions
 .env                  # Environment variables
 .env.example          # Example environment variables
 .sequelizerc          # Sequelize configuration
 server.js             # Application entry point
```

## Getting Started

### Prerequisites

- Node.js (v16+)
- PostgreSQL (v12+)
- npm or yarn

### Installation

1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   ```
3. Copy `.env.example` to `.env` and update the values
4. Create a PostgreSQL database
5. Run migrations:
   ```bash
   npx sequelize-cli db:migrate
   ```
6. Start the development server:
   ```bash
   npm run dev
   ```

### Environment Variables

See `.env.example` for all required environment variables.

## API Documentation

### Authentication

- `POST /api/auth/register` - Register a new user
- `POST /api/auth/login` - Login with email and password
- `POST /api/auth/refresh-token` - Refresh access token
- `POST /api/auth/logout` - Invalidate refresh token

### Users

- `GET /api/users/me` - Get current user profile
- `PUT /api/users/me` - Update current user
- `DELETE /api/users/me` - Delete current user

### Conversations

- `GET /api/conversations` - List user's conversations
- `POST /api/conversations` - Create new conversation
- `GET /api/conversations/:id` - Get conversation details
- `PUT /api/conversations/:id` - Update conversation
- `DELETE /api/conversations/:id` - Delete conversation

### Messages

- `GET /api/messages?conversationId=:id` - Get messages in conversation
- `POST /api/messages` - Send new message
- `PUT /api/messages/:id` - Update message
- `DELETE /api/messages/:id` - Delete message

## Development

### Scripts

- `npm run dev` - Start development server with hot-reload
- `npm test` - Run tests
- `npm run lint` - Lint code
- `npm run format` - Format code
- `npm run db:migrate` - Run database migrations
- `npm run db:seed` - Seed database

### Code Style

This project uses:
- ESLint for code linting
- Prettier for code formatting
- JSDoc for documentation

## Deployment

### Production

1. Set `NODE_ENV=production`
2. Update database and other environment variables
3. Run migrations
4. Start the server with a process manager like PM2

## License

This project is licensed under the MIT License.
</file>

<file path="backend/routes/api/conversations.js">
const express = require('express');
const router = express.Router();
const conversationController = require('../../controllers/conversationController');
const { createConversationRules, getConversationByIdRules, validateRequest } = require('../../middleware/validators/conversationValidator');
const authMiddleware = require('../../middleware/authMiddleware'); // Assuming this path for auth middleware

// @route   POST api/conversations
// @desc    Create a new conversation
// @access  Private
router.post(
    '/', 
    authMiddleware, 
    createConversationRules(), 
    validateRequest, 
    conversationController.createConversationHandler
);

// @route   GET api/conversations
// @desc    Get all conversations for the current user
// @access  Private
router.get(
    '/', 
    authMiddleware, 
    conversationController.getUserConversationsHandler
);

// @route   GET api/conversations/:id
// @desc    Get a specific conversation by its ID
// @access  Private
router.get(
    '/:id', 
    authMiddleware, 
    getConversationByIdRules(), 
    validateRequest, 
    conversationController.getConversationByIdHandler
);

// Mount nested routers for messages and participants
const messageRoutes = require('./messages'); // Assuming messages.js is in the same directory
const participantRoutes = require('./participants'); // Assuming participants.js is in the same directory

router.use('/:conversationId/messages', messageRoutes);
router.use('/:conversationId/participants', participantRoutes);

module.exports = router;
</file>

<file path="backend/routes/api/participants.js">
const express = require('express');
// Ensure mergeParams is true to access :conversationId from parent router
const router = express.Router({ mergeParams: true }); 
const participantController = require('../../controllers/participantController');
const {
    addParticipantsRules,
    removeParticipantRules,
    validateRequest
} = require('../../middleware/validators/participantValidator');
const authMiddleware = require('../../middleware/authMiddleware'); // Assuming this path

// @route   POST /
// @desc    Add participants to a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/participants)
router.post(
    '/',
    authMiddleware,
    addParticipantsRules(),
    validateRequest,
    participantController.addParticipantsHandler
);

// @route   DELETE /:userId
// @desc    Remove a participant from a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/participants/:userId)
router.delete(
    '/:userId',
    authMiddleware,
    removeParticipantRules(),
    validateRequest,
    participantController.removeParticipantHandler
);

module.exports = router;
</file>

<file path="backend/routes/auth.js">
/**
 * Authentication Routes
 * 
 * Defines all authentication-related API endpoints.
 * Handles user registration, login, token refresh, and logout.
 * 
 * @module routes/auth
 * @requires express
 * @requires ../controllers/authController
 * @requires ../middleware/validation
 * @requires ../middleware/auth
 * 
 * @example
 * // Example usage in Express app:
 * const authRoutes = require('./routes/auth');
 * app.use('/api/auth', authRoutes);
 */

// File will be implemented with routes for:
// 1. POST /register - Register a new user
// 2. POST /login - User login with credentials
// 3. POST /refresh-token - Refresh access token
// 4. POST /logout - Invalidate refresh token
// 5. POST /forgot-password - Request password reset
// 6. POST /reset-password - Reset password with token

// Implementation will include proper route validation and error handling
</file>

<file path="backend/routes/authRoutes.js">
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authenticateJWT } = require('../middleware/auth');
const { validateRegistration, validateLogin, validateEmail, validatePasswordReset, validateToken } = require('../middleware/authValidators'); // Assuming these validators will be created

// Public routes
router.post('/register', validateRegistration, authController.register);
router.post('/login', validateLogin, authController.login);
router.post('/refresh-token', authController.refreshToken); // Refresh token is in cookie, no specific validation here for body
router.post('/request-password-reset', validateEmail, authController.requestPasswordReset);
router.post('/reset-password/:token', validatePasswordReset, authController.resetPassword); // Token in URL, newPassword in body
router.get('/verify-email/:token', validateToken, authController.verifyEmail); // Token in URL

// Private routes (require authentication via JWT)
router.post('/logout', authenticateJWT, authController.logout);
router.post('/request-email-verification', authenticateJWT, authController.requestEmailVerification);

module.exports = router;
</file>

<file path="backend/routes/messages.js">
/**
 * Message Routes
 *
 * Defines all message-related API endpoints.
 * Handles sending, retrieving, updating, and deleting messages.
 *
 * @module routes/messages
 * @requires express
 * @requires ../controllers/messageController
 * @requires ../middleware/authMiddleware
 * @requires ../middleware/validation/messageValidation
 * @requires ../middleware/uploadMiddleware
 */

// const messageController = require('../controllers/messageController'); // To be implemented
// const authMiddleware = require('../middleware/authMiddleware'); // To be implemented
// const { validateMessageCreation } = require('../middleware/validation/messageValidation'); // To be implemented
// const upload = require('../middleware/uploadMiddleware'); // To be implemented for attachments

module.exports = function(Router) {
  const router = Router();

  // Placeholder route - GET /api/messages/
  // This will eventually list messages in a conversation
  router.get('/', (req, res) => {
    res.status(200).json({ message: 'Message routes are active. Implementation pending.' });
  });

  // Future routes (examples):
  // router.post('/', authMiddleware, upload.single('attachment'), validateMessageCreation, messageController.sendMessage);
  // router.get('/:id', authMiddleware, messageController.getMessageById);
  // router.put('/:id', authMiddleware, messageController.updateMessage);
  // router.delete('/:id', authMiddleware, messageController.deleteMessage);
  // router.post('/:id/read', authMiddleware, messageController.markAsRead);

  return router;
};
</file>

<file path="backend/routes/participants.js">
/**
 * Routes for managing conversation participants
 */
const express = require('express');
const router = express.Router({ mergeParams: true });
const participantController = require('../controllers/participantController');
const { authenticate } = require('../middleware/authMiddleware');

// Add participant to conversation
router.post('/', authenticate, participantController.addParticipantsHandler);

// Remove participant from conversation
router.delete('/:userId', authenticate, participantController.removeParticipantHandler);

module.exports = router;
</file>

<file path="backend/routes/users.js">
/**
 * User Routes
 *
 * Defines all user-related API endpoints.
 * Handles user profile management and user data retrieval.
 *
 * @module routes/users
 * @requires express
 * @requires ../controllers/userController
 * @requires ../middleware/authMiddleware
 * @requires ../middleware/validation/userValidation
 * @requires ../middleware/uploadMiddleware
 */

// const userController = require('../controllers/userController'); // To be implemented
// const authMiddleware = require('../middleware/authMiddleware'); // To be implemented
// const { validateUserUpdate } = require('../middleware/validation/userValidation'); // To be implemented
// const upload = require('../middleware/uploadMiddleware'); // For profile picture uploads

module.exports = function(Router) {
  const router = Router();

  // Placeholder route - GET /api/users/me
  // This will eventually retrieve the current user's profile
  router.get('/me', (req, res) => {
    res.status(200).json({ message: 'User "me" route active. Implementation pending.' });
  });

  // Future routes (examples):
  // router.put('/me', authMiddleware, upload.single('profilePicture'), validateUserUpdate, userController.updateCurrentUser);
  // router.delete('/me', authMiddleware, userController.deleteCurrentUser);
  // router.get('/:userId', authMiddleware, userController.getUserById); // Admin or specific access

  return router;
};
</file>

<file path="backend/scripts/check-schema.js">
const { Sequelize } = require('sequelize');
const config = require('../config/config');

async function checkSchema() {
  // Use the same config as the rest of the app
  const env = process.env.NODE_ENV || 'development';
  const dbConfig = config[env];
  
  // Create a new connection
  const sequelize = new Sequelize(
    dbConfig.database,
    dbConfig.username,
    dbConfig.password,
    {
      host: dbConfig.host,
      dialect: dbConfig.dialect,
      logging: console.log
    }
  );

  try {
    // Test the connection
    await sequelize.authenticate();
    console.log('Connection has been established successfully.');

    // Check if conversations table exists
    const [tables] = await sequelize.query(
      "SHOW TABLES LIKE 'conversations';"
    );
    
    if (tables.length === 0) {
      console.log('conversations table does not exist');
      return;
    }

    // Describe the conversations table
    const [columns] = await sequelize.query('DESCRIBE conversations;');
    console.log('\nColumns in conversations table:');
    console.table(columns);

    // Check for AI-related columns
    const aiColumns = columns.filter(col => 
      col.Field.toLowerCase().includes('ai') || 
      col.Field.toLowerCase().includes('conversation')
    );
    
    console.log('\nAI-related columns:');
    console.table(aiColumns);

  } catch (error) {
    console.error('Error checking schema:', error);
  } finally {
    await sequelize.close();
  }
}

checkSchema();
</file>

<file path="backend/scripts/checkDbStructure.js">
'use strict';

const { sequelize } = require('../models');
const logger = require('../utils/logger');

/**
 * Checks database structure and logs table names and columns
 */
async function checkDbStructure() {
  try {
    // Check database connection
    await sequelize.authenticate();
    console.log('Database connection has been established successfully.');
    
    // Get all table names
    const [tables] = await sequelize.query("SHOW TABLES");
    console.log('\nTables in database:');
    const tableNames = tables.map(t => Object.values(t)[0]);
    console.log(tableNames);
    
    // For each table, get column information
    for (const tableName of tableNames) {
      console.log(`\nColumns for table '${tableName}':`);
      const [columns] = await sequelize.query(`DESCRIBE \`${tableName}\``);
      columns.forEach(column => {
        console.log(`- ${column.Field} (${column.Type}, ${column.Null === 'YES' ? 'nullable' : 'NOT NULL'}, ${column.Key ? `key: ${column.Key}` : 'no key'})`);
      });
    }
    
    console.log('\nDatabase inspection complete');
  } catch (error) {
    console.error('Error inspecting database:', error);
  } finally {
    await sequelize.close();
  }
}

// Run the function
checkDbStructure().catch(console.error);
</file>

<file path="backend/scripts/createSpecificUser.js">
'use strict';

const { User } = require('../models');
const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');

/**
 * Creates a user with a specific ID that the mobile app is trying to use
 */
const createSpecificUser = async () => {
  // The specific ID that the mobile app is trying to use
  const specificUserId = 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e';
  
  try {
    // Check if the user with this specific ID already exists
    const existingUser = await User.findByPk(specificUserId);
    
    if (existingUser) {
      logger.info(`User with ID ${specificUserId} already exists.`);
      return { 
        success: true, 
        message: 'User already exists', 
        user: existingUser.get({ plain: true }) 
      };
    }
    
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash('password123', salt);
    
    // Create the user with the specific ID
    const newUser = await User.create({
      id: specificUserId,
      username: 'mobileuser',
      email: 'mobile@example.com',
      password: hashedPassword,
      first_name: 'Mobile',
      last_name: 'User',
      role: 'user',
      is_email_verified: true
    });
    
    logger.info(`Created user with specific ID: ${specificUserId}`);
    
    return { 
      success: true, 
      message: 'User created successfully', 
      user: newUser.get({ plain: true }) 
    };
  } catch (error) {
    logger.error('Error creating specific user:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    
    return { 
      success: false, 
      message: 'Failed to create user',
      error: error.message
    };
  }
};

// Run the function if this script is executed directly
if (require.main === module) {
  createSpecificUser()
    .then(result => {
      console.log('Result:', result);
      process.exit(0);
    })
    .catch(error => {
      console.error('Error:', error);
      process.exit(1);
    });
}

module.exports = createSpecificUser;
</file>

<file path="backend/scripts/debugConversationModel.js">
'use strict';

const { Conversation, User, UserConversation, sequelize } = require('../models');
const logger = require('../utils/logger');

/**
 * Debug script to test conversation fetching
 */
async function debugConversationModel() {
  try {
    console.log('Starting Conversation model debugging...');
    
    // Check database connection
    await sequelize.authenticate();
    console.log('Database connection established successfully.');
    
    // Find all conversations
    console.log('\nFetching all conversations:');
    const conversations = await Conversation.findAll({
      raw: true
    });
    console.log(`Found ${conversations.length} conversations:`);
    conversations.forEach(conv => {
      console.log(`ID: ${conv.id}, Type: ${conv.type}, CreatedBy: ${conv.createdBy}`);
    });
    
    if (conversations.length === 0) {
      console.log('No conversations found.');
      return;
    }
    
    // Get the first conversation ID to test
    const testConversationId = conversations[0].id;
    console.log(`\nTesting conversation fetching with ID: ${testConversationId}`);
    
    // Try to fetch a single conversation
    try {
      const singleConversation = await Conversation.findByPk(testConversationId);
      console.log('Conversation found:');
      console.log(JSON.stringify(singleConversation && singleConversation.toJSON(), null, 2));
    } catch (error) {
      console.error('Error fetching conversation by ID:', error.message);
      console.error('SQL Error:', error.sql || 'No SQL available');
    }
    
    // Fetch all participants for the conversation
    try {
      console.log('\nFetching participants for conversation:');
      const participants = await UserConversation.findAll({
        where: { conversation_id: testConversationId },
        raw: true
      });
      console.log(`Found ${participants.length} participants:`);
      console.log(JSON.stringify(participants, null, 2));
      
      // Get user details for each participant
      if (participants.length > 0) {
        const userIds = participants.map(p => p.user_id);
        const users = await User.findAll({
          where: { id: userIds },
          attributes: ['id', 'username', 'email'],
          raw: true
        });
        console.log('\nUser details:');
        console.log(JSON.stringify(users, null, 2));
      }
    } catch (error) {
      console.error('Error fetching participants:', error.message);
    }
    
    console.log('\nDebug complete');
  } catch (error) {
    console.error('Error in debug script:', error);
  } finally {
    await sequelize.close();
  }
}

// Run the debug function
debugConversationModel().catch(console.error);
</file>

<file path="backend/scripts/update-test-user-email.js">
'use strict';

const { sequelize } = require('../models');
const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');

async function ensureTestUser() {
  const transaction = await sequelize.transaction();
  
  try {
    // Check if test user exists
    const [users] = await sequelize.query(
      `SELECT id, username, email FROM users WHERE username = 'testuser' OR email = 'test@example.com'`,
      { transaction }
    );

    if (users.length > 0) {
      // Update existing user
      const [updated] = await sequelize.query(
        `UPDATE users SET 
          email = 'test@example.com', 
          username = 'testuser',
          password = ?,
          updated_at = NOW()
        WHERE id = ?`,
        {
          replacements: [await bcrypt.hash('testpassword123', 10), users[0].id],
          transaction
        }
      );
      logger.info('Updated existing test user');
    } else {
      // Create new test user
      await sequelize.query(
        `INSERT INTO users 
        (id, username, email, password, created_at, updated_at)
        VALUES (?, ?, ?, ?, NOW(), NOW())`,
        {
          replacements: [
            '11111111-1111-1111-1111-111111111111',
            'testuser',
            'test@example.com',
            await bcrypt.hash('testpassword123', 10)
          ],
          transaction
        }
      );
      logger.info('Created new test user');
    }

    // Verify the user exists
    const [updatedUsers] = await sequelize.query(
      `SELECT id, username, email FROM users WHERE username = 'testuser'`,
      { transaction }
    );
    
    logger.info('Current test user data:', updatedUsers[0]);
    
    await transaction.commit();
    return updatedUsers[0];
    
  } catch (error) {
    await transaction.rollback();
    logger.error('Error ensuring test user:', error);
    throw error;
  }
}

async function run() {
  try {
    await ensureTestUser();
    logger.info('Test user setup completed successfully');
  } catch (error) {
    logger.error('Failed to setup test user:', error);
  } finally {
    await sequelize.close();
    process.exit(0);
  }
}

run();
</file>

<file path="backend/seeders/20250516164510-add-test-user.js">
'use strict';
const bcrypt = require('bcryptjs');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    const hashedPassword = await bcrypt.hash('testpassword123', 10);
    
    // Check if test user already exists
    const [existingUser] = await queryInterface.sequelize.query(
      `SELECT id FROM users WHERE email = 'test@example.com' OR username = 'testuser'`,
      { type: Sequelize.QueryTypes.SELECT }
    );

    if (!existingUser) {
      await queryInterface.bulkInsert('users', [{
        id: '11111111-1111-1111-1111-111111111111',
        username: 'testuser',
        email: 'test@example.com',
        password: hashedPassword,
        first_name: 'Test',
        last_name: 'User',
        created_at: new Date(),
        updated_at: new Date()
      }]);
    }
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', {
      email: 'test@example.com'
    });
  }
};
</file>

<file path="backend/seeders/20250516164600-add-test-user-seed.js">
'use strict';
const bcrypt = require('bcryptjs');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    const hashedPassword = await bcrypt.hash('testpassword123', 10);
    
    // Check if test user already exists
    const [existingUser] = await queryInterface.sequelize.query(
      `SELECT id FROM users WHERE email = 'test@example.com' OR username = 'testuser'`,
      { type: Sequelize.QueryTypes.SELECT }
    );

    if (!existingUser) {
      await queryInterface.bulkInsert('users', [{
        id: '11111111-1111-1111-1111-111111111111',
        username: 'testuser',
        email: 'test@example.com',
        password: hashedPassword,
        first_name: 'Test',
        last_name: 'User',
        created_at: new Date(),
        updated_at: new Date()
      }]);
    }
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', {
      email: 'test@example.com'
    });
  }
};
</file>

<file path="backend/seeders/createTestUser.js">
'use strict';

const { User, sequelize } = require('../models');
const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');
const { v4: uuidv4 } = require('uuid');
const { Op } = require('sequelize');

/**
 * Creates a test user if it doesn't exist
 * @returns {Promise<{success: boolean, message: string, user?: object}>}
 */
const createTestUser = async () => {
  const testUserData = {
    id: uuidv4(),
    username: 'testuser',
    email: 'test@example.com',
    password: 'testpassword123',
    first_name: 'Test',
    last_name: 'User',
    role: 'user',
    is_email_verified: true
  };

  const transaction = await sequelize.transaction();
  
  try {
    logger.info('Starting test user creation...', { email: testUserData.email });
    
    // Log database connection status
    try {
      await sequelize.authenticate();
      logger.info('Database connection established successfully');
    } catch (dbError) {
      logger.error('Database connection error:', dbError);
      throw new Error(`Database connection failed: ${dbError.message}`);
    }
    
    // Check if users table exists
    const [tables] = await sequelize.query("SHOW TABLES LIKE 'users'");
    if (tables.length === 0) {
      throw new Error('Users table does not exist');
    }
    
    // Check if test user already exists
    logger.info('Checking for existing test user...');
    const existingUser = await User.findOne({
      where: {
        [Op.or]: [
          { email: testUserData.email },
          { username: testUserData.username }
        ]
      },
      transaction,
      raw: true
    });

    if (existingUser) {
      logger.info('Test user already exists', { 
        userId: existingUser.id,
        email: existingUser.email 
      });
      await transaction.commit();
      return { 
        success: true, 
        message: 'Test user already exists',
        user: existingUser
      };
    }

    logger.info('Creating test user...', { 
      userId: testUserData.id,
      email: testUserData.email 
    });
    
    try {
      // Create user using the model to ensure all hooks and validations run
      const user = await User.create(testUserData, { transaction });
      await transaction.commit();
      
      logger.info('Test user created successfully', { 
        userId: user.id,
        email: user.email 
      });
      
      return { 
        success: true, 
        message: 'Test user created successfully',
        user: user.get({ plain: true })
      };
    } catch (createError) {
      await transaction.rollback();
      throw createError; // Re-throw to be caught by the outer catch
    }
    
  } catch (error) {
    await transaction.rollback();
    
    // Log detailed error information
    logger.error('Error in createTestUser:', {
      message: error.message,
      name: error.name,
      stack: error.stack,
      ...(error.errors && { 
        validationErrors: error.errors.map(e => ({
          path: e.path,
          message: e.message,
          type: e.type,
          value: e.value
        }))
      })
    });
    
    // For unique constraint errors
    if (error.name === 'SequelizeUniqueConstraintError') {
      return { 
        success: false, 
        message: 'A user with this email or username already exists',
        error: 'DUPLICATE_ENTRY'
      };
    }
    
    // For validation errors
    if (error.name === 'SequelizeValidationError') {
      return { 
        success: false, 
        message: 'Validation error creating test user',
        error: 'VALIDATION_ERROR',
        details: error.errors.map(e => ({
          field: e.path,
          message: e.message
        }))
      };
    }
    
    // For all other errors
    return { 
      success: false, 
      message: 'Failed to create test user',
      error: error.message,
      errorType: error.name
    };
  }
};

// If this file is run directly, execute the function
if (require.main === module) {
  createTestUser()
    .then(result => {
      console.log(result);
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('Fatal error:', error);
      process.exit(1);
    });
}

module.exports = createTestUser;
</file>

<file path="backend/services/aiChatService.js">
const { Op } = require('sequelize');
const { Conversation, Message, User } = require('../models');
const logger = require('../utils/logger');
const aiService = require('./aiService');

class AIChatService {
  /**
   * Get or create an AI conversation for a user
   * @param {string} userId - The ID of the user
   * @returns {Promise<Object>} The AI conversation
   */
  static async getOrCreateAIConversation(userId) {
    try {
      // Check if user already has an AI conversation
      const existingConversation = await Conversation.findOne({
        where: {
          type: 'direct',
          name: 'AI Coach',
          '$participants.id$': userId
        },
        include: [{
          model: User,
          as: 'participants',
          where: { id: userId },
          attributes: ['id'],
          through: { attributes: [] }
        }]
      });

      if (existingConversation) {
        return existingConversation;
      }

      // Create a new AI conversation
      const conversation = await Conversation.create({
        type: 'direct',
        name: 'AI Coach',
        createdBy: userId,
        isAIConversation: true
      });

      // Add the user to the conversation
      await conversation.addParticipant(userId);

      // Add a welcome message from the AI
      await Message.create({
        content: 'Hello! I\'m your AI Coach. How can I assist you today?',
        senderId: '00000000-0000-0000-0000-000000000000', // System AI user ID
        conversationId: conversation.id,
        isFromAI: true
      });

      return conversation;
    } catch (error) {
      logger.error('Error in getOrCreateAIConversation:', error);
      throw new Error('Failed to get or create AI conversation');
    }
  }

  /**
   * Send a message to the AI coach and get a response
   * @param {string} userId - The ID of the user sending the message
   * @param {string} content - The message content
   * @returns {Promise<Object>} The AI's response message
   */
  static async sendMessageToAI(userId, content) {
    const transaction = await sequelize.transaction();
    
    try {
      // Get or create the AI conversation
      const conversation = await this.getOrCreateAIConversation(userId);
      
      // Save the user's message
      const userMessage = await Message.create({
        content,
        senderId: userId,
        conversationId: conversation.id,
        isFromAI: false
      }, { transaction });

      // Get conversation history (last 10 messages for context)
      const messages = await Message.findAll({
        where: { conversationId: conversation.id },
        order: [['createdAt', 'ASC']],
        limit: 10,
        transaction
      });

      // Format messages for the AI
      const formattedMessages = messages.map(msg => ({
        role: msg.isFromAI ? 'assistant' : 'user',
        content: msg.content
      }));

      // Get AI response
      const aiResponse = await aiService.generateResponse(formattedMessages, userId);

      // Save the AI's response
      const aiMessage = await Message.create({
        content: aiResponse,
        senderId: '00000000-0000-0000-0000-000000000000', // System AI user ID
        conversationId: conversation.id,
        isFromAI: true
      }, { transaction });

      await transaction.commit();
      
      return aiMessage;
    } catch (error) {
      await transaction.rollback();
      logger.error('Error in sendMessageToAI:', error);
      throw new Error('Failed to send message to AI');
    }
  }

  /**
   * Get AI conversation history for a user
   * @param {string} userId - The ID of the user
   * @param {number} limit - Maximum number of messages to return
   * @param {number} offset - Offset for pagination
   * @returns {Promise<Object>} Conversation and messages
   */
  static async getAIConversation(userId, limit = 20, offset = 0) {
    try {
      const conversation = await this.getOrCreateAIConversation(userId);
      
      const { count, rows: messages } = await Message.findAndCountAll({
        where: { conversationId: conversation.id },
        order: [['createdAt', 'DESC']],
        limit,
        offset,
        include: [
          {
            model: User,
            as: 'sender',
            attributes: ['id', 'username', 'email']
          }
        ]
      });

      return {
        conversation: {
          id: conversation.id,
          name: conversation.name,
          type: conversation.type,
          createdAt: conversation.createdAt,
          updatedAt: conversation.updatedAt
        },
        messages: messages.reverse(), // Return in chronological order
        total: count,
        hasMore: offset + messages.length < count
      };
    } catch (error) {
      logger.error('Error in getAIConversation:', error);
      throw new Error('Failed to get AI conversation');
    }
  }
}

module.exports = AIChatService;
</file>

<file path="backend/services/chatService.js">
/**
 * Chat Service
 * 
 * Handles business logic for chat operations including conversation management,
 * message handling, and real-time updates.
 * 
 * @module services/chatService
 * @requires ../models/Conversation
 * @requires ../models/Message
 * @requires ../models/User
 * @requires ../services/socketService
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { createConversation, sendMessage } = require('../services/chatService');
 * const conversation = await createConversation(creatorId, participants);
 * const message = await sendMessage(senderId, conversationId, content);
 */

// File will be implemented with:
// 1. Conversation creation and management
// 2. Message sending and retrieval
// 3. Real-time message delivery via WebSocket
// 4. Message status updates (sent, delivered, read)
// 5. Typing indicators and online status

// Implementation will include proper error handling and data validation
</file>

<file path="backend/services/participantService.js">
// Contains business logic and data access for participant management
const { Op } = require('sequelize');
const { Conversation, User, UserConversation, sequelize } = require('../models'); // Adjust path if your models are elsewhere
const logger = require('../utils/logger'); // Adjust path for your logger

/**
 * Adds participants to a group conversation.
 * @param {string} requesterId - The ID of the user making the request.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string[]} userIdsToAdd - An array of user IDs to add to the conversation.
 * @returns {Promise<Conversation>} The updated conversation object with all participants.
 * @throws {Error} If validation or permission checks fail.
 */
const addParticipants = async (requesterId, conversationId, userIdsToAdd) => {
    logger.info(`Adding participants to conversation ${conversationId}: requesterId=${requesterId}, usersToAdd=${userIdsToAdd.join(',')}`);

    if (!requesterId || !conversationId || !userIdsToAdd || userIdsToAdd.length === 0) {
        throw new Error('Requester ID, Conversation ID, and at least one User ID to add are required.');
    }

    const transaction = await sequelize.transaction();
    try {
        const conversation = await Conversation.findByPk(conversationId, {
            include: [
                { model: User, as: 'participants', attributes: ['id'] },
                { model: User, as: 'creator', attributes: ['id'] }
            ],
            transaction
        });

        if (!conversation) {
            throw new Error(`Conversation with ID ${conversationId} not found.`);
        }

        if (conversation.type !== 'group') {
            throw new Error('Participants can only be added to group conversations.');
        }

        if (conversation.creatorId !== requesterId) {
            const authError = new Error('Only the conversation creator can add participants.');
            authError.status = 403; // Forbidden
            throw authError;
        }

        const existingParticipantIds = new Set(conversation.participants.map(p => p.id));
        const newParticipantIds = userIdsToAdd.filter(id => !existingParticipantIds.has(id) && id !== requesterId); // Ensure creator isn't re-added if somehow in list

        if (newParticipantIds.length === 0) {
            logger.info('No new participants to add (all users already in conversation or invalid).');
            // Fetch and return the current state of the conversation with full participant details
            await transaction.commit(); // Commit as no changes were made to UserConversation, but we did read.
            return Conversation.findByPk(conversationId, {
                include: [
                    { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                    { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
                ]
            });
        }

        // Verify that all userIdsToAdd correspond to actual users
        const usersToAddExist = await User.count({ where: { id: { [Op.in]: newParticipantIds } } });
        if (usersToAddExist !== newParticipantIds.length) {
            throw new Error('One or more users to add do not exist.');
        }

        const userConversationEntries = newParticipantIds.map(userId => ({
            userId,
            conversationId: conversation.id,
        }));

        await UserConversation.bulkCreate(userConversationEntries, { transaction });
        
        // Update conversation's updatedAt timestamp
        await conversation.update({ updatedAt: new Date() }, { transaction });

        await transaction.commit();

        logger.info(`Successfully added ${newParticipantIds.length} participants to conversation ${conversationId}.`);
        // Fetch the conversation again with full participant details
        return Conversation.findByPk(conversationId, {
            include: [
                { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
            ]
        });

    } catch (error) {
        await transaction.rollback();
        logger.error('Error adding participants:', error);
        if (!error.status) error.status = 500;
        throw error;
    }
};

/**
 * Removes a participant from a group conversation.
 * @param {string} requesterId - The ID of the user making the request.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userIdToRemove - The ID of the user to remove.
 * @returns {Promise<object>} A success message or the updated conversation.
 * @throws {Error} If validation or permission checks fail.
 */
const removeParticipant = async (requesterId, conversationId, userIdToRemove) => {
    logger.info(`Removing participant ${userIdToRemove} from conversation ${conversationId}: requesterId=${requesterId}`);

    if (!requesterId || !conversationId || !userIdToRemove) {
        throw new Error('Requester ID, Conversation ID, and User ID to remove are required.');
    }

    const transaction = await sequelize.transaction();
    try {
        const conversation = await Conversation.findByPk(conversationId, {
            include: [
                { model: User, as: 'participants', attributes: ['id'] },
                { model: User, as: 'creator', attributes: ['id'] }
            ],
            transaction
        });

        if (!conversation) {
            throw new Error(`Conversation with ID ${conversationId} not found.`);
        }

        if (conversation.type !== 'group') {
            throw new Error('Participants can only be removed from group conversations.');
        }

        const isParticipantToRemoveInConversation = conversation.participants.some(p => p.id === userIdToRemove);
        if (!isParticipantToRemoveInConversation) {
            throw new Error(`User ${userIdToRemove} is not a participant in conversation ${conversationId}.`);
        }

        // Permission checks
        const isRequesterCreator = conversation.creatorId === requesterId;
        const isRequesterRemovingThemselves = requesterId === userIdToRemove;

        if (!isRequesterCreator && !isRequesterRemovingThemselves) {
            const authError = new Error('Only the conversation creator can remove other participants, or a user can remove themselves.');
            authError.status = 403; // Forbidden
            throw authError;
        }
        
        // Prevent creator from being removed by someone else (this case should be caught above, but as a safeguard)
        if (userIdToRemove === conversation.creatorId && !isRequesterRemovingThemselves) {
             const authError = new Error('The conversation creator cannot be removed by another user.');
             authError.status = 403;
             throw authError;
        }

        // Prevent removing the last participant
        if (conversation.participants.length <= 1 && isParticipantToRemoveInConversation) {
            // If the one to remove is indeed one of the (or the only) participant
            throw new Error('Cannot remove the last participant from a group conversation. Consider deleting the conversation instead.');
        }

        const result = await UserConversation.destroy({
            where: {
                userId: userIdToRemove,
                conversationId: conversation.id,
            },
            transaction
        });

        if (result === 0) {
            // Should have been caught by `isParticipantToRemoveInConversation` check, but good to have.
            throw new Error(`Failed to remove participant ${userIdToRemove}. User may not have been a participant or an issue occurred.`);
        }

        // Update conversation's updatedAt timestamp
        await conversation.update({ updatedAt: new Date() }, { transaction });

        await transaction.commit();

        logger.info(`Successfully removed participant ${userIdToRemove} from conversation ${conversationId}.`);
        
        // If the user removed themselves, and they were the creator, specific logic might be needed (e.g., assign new creator or archive chat)
        // For now, we'll just return a success message or the updated conversation without the removed participant.
        // Fetching the updated conversation is good practice.
        const updatedConversation = await Conversation.findByPk(conversationId, {
             include: [
                { model: User, as: 'participants', attributes: ['id', 'username', 'email'], through: { attributes: [] } },
                { model: User, as: 'creator', attributes: ['id', 'username', 'email'] }
            ]
        });

        return {
            message: `Participant ${userIdToRemove} removed successfully.`,
            conversation: updatedConversation
        };

    } catch (error) {
        await transaction.rollback();
        logger.error('Error removing participant:', error);
        if (!error.status) error.status = 500;
        throw error;
    }
};

module.exports = {
    addParticipants,
    removeParticipant,
};
</file>

<file path="backend/services/socketService.js">
/**
 * Socket Service
 * 
 * Manages WebSocket connections and real-time event broadcasting.
 * Handles user connections, disconnections, and room management.
 * 
 * @module services/socketService
 * @requires socket.io
 * @requires ../models/User
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { initSocket, emitToUser } = require('../services/socketService');
 * const io = initSocket(server);
 * emitToUser(userId, 'new_message', messageData);
 */

// File will be implemented with:
// 1. WebSocket server initialization
// 2. Connection and disconnection handling
// 3. Room management for conversations
// 4. Event broadcasting to users/rooms
// 5. Online status tracking

// Implementation will include proper error handling and connection state management
</file>

<file path="backend/services/taskService.js">
const { Task } = require('../models');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class TaskService {
  static async createTask(userId, taskData) {
    try {
      const task = await Task.create({
        ...taskData,
        userId,
      });
      return task;
    } catch (error) {
      logger.error('Error creating task:', error);
      throw new Error('Failed to create task');
    }
  }

  static async getTasks(userId, { status, limit = 10, offset = 0 }) {
    try {
      const where = { userId };
      
      if (status === 'completed') {
        where.completed = true;
      } else if (status === 'pending') {
        where.completed = false;
      }

      const { count, rows } = await Task.findAndCountAll({
        where,
        order: [['dueDate', 'ASC']],
        limit: parseInt(limit),
        offset: parseInt(offset),
      });

      return {
        tasks: rows,
        total: count,
        hasMore: offset + rows.length < count,
      };
    } catch (error) {
      logger.error('Error fetching tasks:', error);
      throw new Error('Failed to fetch tasks');
    }
  }

  static async getTaskById(userId, taskId) {
    try {
      const task = await Task.findOne({
        where: {
          id: taskId,
          userId,
        },
      });

      if (!task) {
        throw new Error('Task not found');
      }

      return task;
    } catch (error) {
      logger.error('Error fetching task:', error);
      throw error;
    }
  }

  static async updateTask(userId, taskId, updateData) {
    try {
      const [updated] = await Task.update(updateData, {
        where: {
          id: taskId,
          userId,
        },
        returning: true,
      });

      if (!updated) {
        throw new Error('Task not found or not authorized');
      }

      return await Task.findByPk(taskId);
    } catch (error) {
      logger.error('Error updating task:', error);
      throw error;
    }
  }

  static async deleteTask(userId, taskId) {
    try {
      const deleted = await Task.destroy({
        where: {
          id: taskId,
          userId,
        },
      });

      if (!deleted) {
        throw new Error('Task not found or not authorized');
      }

      return { success: true };
    } catch (error) {
      logger.error('Error deleting task:', error);
      throw error;
    }
  }

  static async getUpcomingTasks(userId, days = 7) {
    try {
      const startDate = new Date();
      const endDate = new Date();
      endDate.setDate(startDate.getDate() + parseInt(days));

      return await Task.findAll({
        where: {
          userId,
          completed: false,
          dueDate: {
            [Op.between]: [startDate, endDate],
          },
        },
        order: [['dueDate', 'ASC']],
      });
    } catch (error) {
      logger.error('Error fetching upcoming tasks:', error);
      throw new Error('Failed to fetch upcoming tasks');
    }
  }
}

module.exports = TaskService;
</file>

<file path="backend/socket/events.js">
/**
 * Socket.IO event handlers for real-time communication
 */
const logger = require('../utils/logger');
const messageService = require('../services/messageService');

/**
 * Initialize socket event handlers for a connected client
 * @param {Object} io - Socket.IO server instance
 * @param {Object} socket - Socket.IO client socket
 */
const initializeSocketEventHandlers = (io, socket) => {
  const userId = socket.user.id;
  const username = socket.user.username;

  // Join user to their own room for direct messages
  socket.join(userId.toString());

  // Handle joining conversation rooms
  socket.on('joinConversation', (conversationId) => {
    if (!conversationId) return;
    
    logger.info(`User ${username} (${userId}) joining conversation room: ${conversationId}`);
    socket.join(conversationId.toString());
  });

  // Handle leaving conversation rooms
  socket.on('leaveConversation', (conversationId) => {
    if (!conversationId) return;
    
    logger.info(`User ${username} (${userId}) leaving conversation room: ${conversationId}`);
    socket.leave(conversationId.toString());
  });

  // Handle new message from client
  socket.on('sendMessage', async (data) => {
    try {
      const { conversationId, content, type = 'text', metadata = null } = data;
      
      if (!conversationId || !content) {
        logger.warn(`Invalid message data from user ${username}: missing conversationId or content`);
        socket.emit('messageError', { error: 'Conversation ID and content are required' });
        return;
      }

      logger.info(`SOCKET: Processing message from user ${userId} in conversation ${conversationId}`);
      
      // Send message and get both user message and AI response
      const { userMessage, aiMessage } = await messageService.sendMessage(
        userId,
        conversationId,
        content,
        type,
        metadata
      );

      // Broadcast user message to all participants in the conversation
      logger.info(`SOCKET: Broadcasting user message ${userMessage.id} to conversation ${conversationId}`);
      io.to(conversationId.toString()).emit('newMessage', userMessage);

      // Broadcast AI message with slight delay to simulate thinking
      if (aiMessage) {
        logger.info(`SOCKET: Broadcasting AI message ${aiMessage.id} to conversation ${conversationId}`);
        setTimeout(() => {
          io.to(conversationId.toString()).emit('newMessage', aiMessage);
        }, 500); // 500ms delay
      }
    } catch (error) {
      logger.error(`Error processing message from user ${username}:`, error);
      socket.emit('messageError', { 
        error: 'Failed to process message', 
        details: error.message 
      });
    }
  });

  // Handle typing indicators
  socket.on('typing', (data) => {
    const { conversationId } = data;
    if (!conversationId) return;
    
    logger.debug(`User ${username} is typing in conversation ${conversationId}`);
    
    // Broadcast typing event to all participants except sender
    socket.to(conversationId.toString()).emit('userTyping', {
      userId,
      username,
      conversationId
    });
  });

  // Handle read receipts
  socket.on('markAsRead', async (data) => {
    try {
      const { conversationId, lastReadMessageId } = data;
      
      if (!conversationId || !lastReadMessageId) {
        logger.warn(`Invalid read receipt data from user ${username}`);
        return;
      }
      
      logger.info(`User ${username} marked messages as read up to ${lastReadMessageId} in conversation ${conversationId}`);
      
      // Update read status in database
      await messageService.markMessagesAsRead(conversationId, userId, lastReadMessageId);
      
      // Broadcast read receipt to all participants
      io.to(conversationId.toString()).emit('messagesRead', {
        userId,
        username,
        conversationId,
        lastReadMessageId
      });
    } catch (error) {
      logger.error(`Error processing read receipt from user ${username}:`, error);
    }
  });
};

module.exports = initializeSocketEventHandlers;
</file>

<file path="backend/socket/events/index.js">
/**
 * Centralized event handlers for WebSocket connections.
 * This function is called when a new authenticated client connects.
 * It registers various event handlers (for messages, user status, etc.) for that client's socket.
 */
const messageHandlers = require('./messageHandlers');
const userHandlers = require('./userHandlers');
const logger = require('../../utils/logger'); // Assuming logger is in 'backend/utils/logger.js'

const onConnection = (io, socket) => {
    // This function is called for each authenticated socket connection
    logger.info(`Setting up event handlers for connected user: ${socket.user.username} (Socket ID: ${socket.id})`);

    // Register message-related event handlers from messageHandlers.js
    messageHandlers(io, socket);

    // Register user-related event handlers (e.g., typing, online status) from userHandlers.js
    userHandlers(io, socket);

    // Example: Generic error handler for this specific socket, if not handled by global io error handler
    // socket.on('error', (error) => {
    //     logger.error(`Socket-specific error for user ${socket.user.username} (Socket ID: ${socket.id}):`, error);
    // });

    // You can also register other general purpose handlers here if needed
    // For example, a custom ping/pong for keep-alive or latency checks
    socket.on('custom_ping', (callback) => {
        logger.debug(`Received custom_ping from ${socket.user.username}, sending custom_pong.`);
        if (typeof callback === 'function') {
            callback({ status: 'ok', timestamp: new Date().toISOString(), fromServer: true });
        }
    });

    // Note: The main 'disconnect' event is typically handled where the 'connection' event is defined (e.g., server.js)
    // to ensure it's always attached. However, specific cleanup related to these handlers can be done here if needed.
};

module.exports = onConnection;
</file>

<file path="backend/socket/events/messageHandlers.js">
/**
 * Handles all message-related WebSocket events.
 * Processes incoming messages, saves them to the database, and broadcasts to recipients.
 * Manages message status updates (e.g., sent, delivered, read).
 */
const { Message, Conversation, User } = require('../../models'); // Assuming models are in backend/models
const logger = require('../../utils/logger'); // Assuming logger is in backend/utils/logger
// const { Op } = require('sequelize'); // Uncomment if needed for complex queries

module.exports = (io, socket) => {
    /**
     * Handles incoming messages from clients.
     * @param {object} data - The message data from the client.
     * Expected structure: { conversationId: string, content: string }
     * @param {function} callback - Acknowledgment callback to the client.
     * Called with { status: 'ok', messageId: string, sentAt: Date } or { status: 'error', message: string }.
     */
    const sendMessage = async (data, callback) => {
        try {
            const { conversationId, content } = data;
            const senderId = socket.user.id; // User ID from authenticated socket (socket.user set by auth middleware)

            if (!conversationId || !content || String(content).trim() === '') {
                logger.warn(`sendMessage: Missing conversationId or content from user ${senderId}. Data: ${JSON.stringify(data)}`);
                if (typeof callback === 'function') callback({ status: 'error', message: 'Conversation ID and content are required.' });
                return;
            }

            // 1. Verify the conversation exists and the user is a participant.
            // This check is crucial for security and data integrity.
            const conversation = await Conversation.findByPk(conversationId, {
                include: [{
                    model: User,
                    as: 'participants',
                    attributes: ['id'],
                    through: { attributes: [] } // We only need to know if the user is a participant.
                }]
            });

            if (!conversation) {
                logger.warn(`sendMessage: Conversation ${conversationId} not found. Attempt by user ${senderId}.`);
                if (typeof callback === 'function') callback({ status: 'error', message: 'Conversation not found.' });
                return;
            }

            const isParticipant = conversation.participants.some(p => p.id === senderId);
            if (!isParticipant) {
                logger.warn(`sendMessage: User ${senderId} (${socket.user.username}) is not a participant of conversation ${conversationId}.`);
                if (typeof callback === 'function') callback({ status: 'error', message: 'Access denied: You are not a participant of this conversation.' });
                return;
            }

            // 2. Create and save the message to the database.
            const message = await Message.create({
                content: String(content).trim(), // Ensure content is a string and trimmed
                senderId,
                conversationId,
                // timestamp: new Date() // Sequelize automatically adds createdAt and updatedAt
            });

            // 3. Fetch the newly created message along with sender details to broadcast.
            // This ensures the broadcasted message has all necessary info for clients to render it.
            const messageWithSender = await Message.findByPk(message.id, {
                include: [{
                    model: User,
                    as: 'sender', // Make sure this alias matches your Message model association
                    attributes: ['id', 'username', 'email'] // Send only necessary, non-sensitive sender info
                }]
            });

            // 4. Broadcast the new message to all clients in the specific conversation room.
            // It's assumed that clients join a room named after the conversationId when they select a conversation.
            const roomName = conversationId.toString();
            io.to(roomName).emit('newMessage', messageWithSender);
            logger.info(`Message from ${socket.user.username} (ID: ${senderId}) sent to conversation ${conversationId}: "${message.content.substring(0, 50)}..."`);

            // 5. Send an acknowledgment callback to the sender.
            if (typeof callback === 'function') {
                callback({ 
                    status: 'ok', 
                    messageId: message.id, 
                    tempId: data.tempId, // Optionally echo back a temporary client-side ID for UI updates
                    sentAt: message.createdAt 
                });
            }

        } catch (error) {
            logger.error(`sendMessage error for user ${socket.user?.id} in conversation ${data?.conversationId}:`, error);
            if (typeof callback === 'function') {
                callback({ status: 'error', message: 'Failed to send message due to a server error.' });
            }
        }
    };

    /**
     * Handles requests to mark messages as read within a conversation.
     * @param {object} data - Data from the client.
     * Expected structure: { conversationId: string, messageId: string (optional, for specific message) or lastReadTimestamp: Date (optional) }
     * @param {function} callback - Acknowledgment callback.
     */
    const markAsRead = async (data, callback) => {
        // Placeholder for 'mark as read' functionality.
        // This would typically involve:
        // 1. Identifying which messages to mark as read (e.g., all messages up to messageId or timestamp).
        // 2. Updating database records (e.g., a 'readBy' field in Message or a separate ReadReceipts table).
        // 3. Broadcasting an event like 'messagesRead' to participants in the conversation,
        //    so their UIs can update read statuses.
        logger.info(`markAsRead event received from ${socket.user.username} for conversation ${data?.conversationId}`, data);
        // Example: io.to(data.conversationId.toString()).emit('messagesRead', { conversationId: data.conversationId, readerId: socket.user.id, messageId: data.messageId });
        if (typeof callback === 'function') callback({ status: 'info', message: 'Read status handling is under development.' });
    };

    // Register event listeners for this socket connection
    socket.on('sendMessage', sendMessage);
    socket.on('markAsRead', markAsRead);

    // TODO: Add handlers for other message-related events such as:
    // socket.on('editMessage', editMessageHandler);
    // socket.on('deleteMessage', deleteMessageHandler);
    // socket.on('messageDelivered', messageDeliveredHandler); // If implementing custom delivery receipts
};
</file>

<file path="backend/socket/events/userHandlers.js">
/**
 * Handles user-related WebSocket events such as typing indicators and presence.
 */
const logger = require('../../utils/logger'); // Assuming logger is in backend/utils/logger

// Store typing users: { conversationId: { userId: socketId, ... } }
// This is a simple in-memory store. For a distributed system, use Redis or similar.
const typingUsersByConversation = {}; 

module.exports = (io, socket) => {
    const userId = socket.user.id;
    const username = socket.user.username;

    /**
     * Handles 'typing_start' event from a client.
     * @param {object} data - Data from the client.
     * Expected structure: { conversationId: string }
     */
    const handleUserTypingStart = (data) => {
        const { conversationId } = data;
        if (!conversationId) {
            logger.warn(`User ${username} (ID: ${userId}) sent 'typing_start' without conversationId.`);
            return;
        }

        // Add user to typing list for this conversation
        if (!typingUsersByConversation[conversationId]) {
            typingUsersByConversation[conversationId] = {};
        }
        typingUsersByConversation[conversationId][userId] = socket.id; // Store socket.id if needed for multi-device scenarios

        // Broadcast to other users in the conversation room that this user is typing.
        // The client sending 'typing_start' should not receive this event back from the server.
        socket.to(conversationId.toString()).emit('userTyping', {
            conversationId,
            userId,
            username,
            isTyping: true
        });
        logger.debug(`User ${username} (ID: ${userId}) started typing in conversation ${conversationId}`);
    };

    /**
     * Handles 'typing_stop' event from a client.
     * @param {object} data - Data from the client.
     * Expected structure: { conversationId: string }
     */
    const handleUserTypingStop = (data) => {
        const { conversationId } = data;
        if (!conversationId) {
            logger.warn(`User ${username} (ID: ${userId}) sent 'typing_stop' without conversationId.`);
            return;
        }

        // Remove user from typing list
        if (typingUsersByConversation[conversationId]) {
            delete typingUsersByConversation[conversationId][userId];
            if (Object.keys(typingUsersByConversation[conversationId]).length === 0) {
                delete typingUsersByConversation[conversationId]; // Clean up empty conversation entry
            }
        }

        // Broadcast to other users in the conversation room that this user stopped typing.
        socket.to(conversationId.toString()).emit('userTyping', {
            conversationId,
            userId,
            username,
            isTyping: false
        });
        logger.debug(`User ${username} (ID: ${userId}) stopped typing in conversation ${conversationId}`);
    };

    /**
     * Placeholder for handling user explicitly setting their status (e.g., 'online', 'away', 'offline').
     * This is distinct from basic WebSocket connection/disconnection presence.
     * @param {object} data - Data from the client, e.g., { status: 'away' }
     */
    const handleUserSetStatus = (data) => {
        const { status } = data;
        logger.info(`User ${username} (ID: ${userId}) set status to: ${status}`);
        // TODO: Update user's status in a presence system (e.g., Redis, database)
        // and broadcast this status change to relevant users (e.g., friends, contacts).
        // io.emit('userStatusChanged', { userId, username, status }); // Example broadcast to all
    };

    // Register event listeners for this socket connection
    socket.on('typing_start', handleUserTypingStart);
    socket.on('typing_stop', handleUserTypingStop);
    socket.on('set_user_status', handleUserSetStatus); // Example for explicit status setting

    // Cleanup logic when this specific socket disconnects.
    // This is in addition to the generic 'disconnect' logger in server.js.
    socket.on('disconnect', (reason) => {
        logger.debug(`User handlers: ${username} (ID: ${userId}, Socket ID: ${socket.id}) disconnected. Reason: ${reason}`);
        // If the user was typing in any conversation, emit 'typing_stop' for them.
        for (const conversationId in typingUsersByConversation) {
            if (typingUsersByConversation[conversationId][userId] === socket.id) {
                delete typingUsersByConversation[conversationId][userId];
                 if (Object.keys(typingUsersByConversation[conversationId]).length === 0) {
                    delete typingUsersByConversation[conversationId];
                }
                socket.to(conversationId.toString()).emit('userTyping', {
                    conversationId,
                    userId,
                    username,
                    isTyping: false
                });
                logger.debug(`Auto-stopped typing for ${username} in ${conversationId} due to disconnect.`);
            }
        }
        // TODO: Add more sophisticated presence management if needed (e.g., user has other active sockets).
        // For a simple setup, you might broadcast 'user_offline' to relevant rooms/users.
    });
};
</file>

<file path="backend/socket/index.js">
/**
 * Main WebSocket server configuration and initialization
 * Handles real-time communication between clients using Socket.IO
 * Manages connection events, authentication, and message broadcasting
 */
</file>

<file path="backend/utils/errorHandler.js">
// Custom error handling middleware for API routes
</file>

<file path="backend/utils/errors.js">
/**
 * Custom Error Classes
 * 
 * Defines custom error classes for different types of application errors.
 * Provides consistent error handling and formatting.
 * 
 * @module utils/errors
 * @requires http-status-codes
 * 
 * @example
 * // Example usage:
 * const { NotFoundError, ValidationError, BadRequestError } = require('../utils/errors');
 * throw new NotFoundError('User not found');
 * throw new ValidationError('Invalid input', { field: 'email' });
 * throw new BadRequestError('Invalid request');
 */

// File implemented with custom error classes:
// 1. ApiError - Base error class
// 2. NotFoundError - 404 errors
// 3. ValidationError - 400 errors
// 4. UnauthorizedError - 401 errors
// 5. ForbiddenError - 403 errors
// 6. ConflictError - 409 errors
// 7. BadRequestError - 400 errors

// Implementation includes proper error serialization and status codes

const httpStatus = require('http-status-codes');

/**
 * Base API Error class that all other error classes extend.
 * Sets up common properties for all API errors.
 */
class ApiError extends Error {
  constructor(
    message = 'An error occurred',
    statusCode = httpStatus.INTERNAL_SERVER_ERROR,
    isOperational = true,
    stack = ''
  ) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = isOperational;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * 400 Bad Request Error
 * Used when the server cannot process the request due to client error.
 */
class BadRequestError extends ApiError {
  constructor(message = 'Bad Request') {
    super(message, httpStatus.BAD_REQUEST);
  }
}

/**
 * 401 Unauthorized Error
 * Used when authentication is required but has failed or not been provided.
 */
class UnauthorizedError extends ApiError {
  constructor(message = 'Unauthorized') {
    super(message, httpStatus.UNAUTHORIZED);
  }
}

/**
 * 403 Forbidden Error
 * Used when the user doesn't have permission to access a resource.
 */
class ForbiddenError extends ApiError {
  constructor(message = 'Forbidden') {
    super(message, httpStatus.FORBIDDEN);
  }
}

/**
 * 404 Not Found Error
 * Used when a requested resource is not found.
 */
class NotFoundError extends ApiError {
  constructor(message = 'Resource not found') {
    super(message, httpStatus.NOT_FOUND);
  }
}

/**
 * 409 Conflict Error
 * Used when a request conflicts with the current state of the server.
 */
class ConflictError extends ApiError {
  constructor(message = 'Conflict') {
    super(message, httpStatus.CONFLICT);
  }
}

/**
 * 422 Validation Error
 * Used when request data fails validation.
 */
class ValidationError extends ApiError {
  constructor(message = 'Validation Error', errors = []) {
    super(message, httpStatus.UNPROCESSABLE_ENTITY);
    this.errors = errors;
  }
}

module.exports = {
  ApiError,
  BadRequestError,
  UnauthorizedError,
  ForbiddenError,
  NotFoundError,
  ConflictError,
  ValidationError
};
</file>

<file path="backend/utils/logger.js">
/**
 * Logger Utility
 *
 * Centralized logging service for the application.
 * Supports different log levels and transports (console, file, etc.).
 *
 * @module utils/logger
 * @requires winston
 * @requires winston-daily-rotate-file
 */

const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const path = require('path');

const { combine, timestamp, printf, colorize, align, json } = winston.format;

// Define the log directory
const logDirectory = path.join(__dirname, '../logs');

// Custom log format
const logFormat = printf(({ level, message, timestamp: ts, stack }) => {
  return `${ts} ${level}: ${stack || message}`;
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info', // Default to 'info'
  format: combine(
    colorize({ all: true }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    align(),
    logFormat
  ),
  transports: [
    new winston.transports.Console(),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'application-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m', // Max size of each log file
      maxFiles: '14d', // Keep logs for 14 days
      format: combine(timestamp(), json()), // File logs in JSON format
      level: 'debug', // Log debug and above to file
    }),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: combine(timestamp(), json()),
      level: 'error', // Log only errors to this file
    }),
  ],
  exceptionHandlers: [
    new winston.transports.Console({
      format: combine(colorize(), timestamp(), align(), logFormat),
    }),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'exceptions-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: combine(timestamp(), json()),
    }),
  ],
  rejectionHandlers: [ // Handle unhandled promise rejections
    new winston.transports.Console({
      format: combine(colorize(), timestamp(), align(), logFormat),
    }),
    new DailyRotateFile({
      filename: path.join(logDirectory, 'rejections-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
      format: combine(timestamp(), json()),
    }),
  ],
  exitOnError: false, // Do not exit on handled exceptions
});

// Create a stream object with a 'write' function that will be used by morgan
logger.stream = {
  write: function(message, encoding) {
    // use the 'info' log level so the output will be picked up by both transports
    logger.info(message.trim());
  },
};

module.exports = logger;
</file>

<file path="backend/utils/socketUtils.js">
// Helper functions for WebSocket operations and room management
</file>

<file path="backend/utils/validators.js">
/**
 * Validation Utilities
 * 
 * Centralized validation schemas and helper functions.
 * Uses Joi for schema validation and custom validation logic.
 * 
 * @module utils/validators
 * @requires joi
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { validateEmail, userSchema } = require('../utils/validators');
 * await validateEmail(email);
 * const { error, value } = userSchema.validate(userData);
 */

// File will be implemented with:
// 1. Common validation schemas (email, password, etc.)
// 2. Custom validation functions
// 3. Schema validation middleware
// 4. Request parameter validation
// 5. Error message formatting

// Implementation will include proper error handling and schema definitions
</file>

<file path="frontend/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Coach Ally - Your AI Coaching Companion"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Coach Ally</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="frontend/src/components/chat/ChatWindow.js">
/**
 * Main chat interface component
 * Displays messages and provides input for sending new messages
 * Handles message rendering, scrolling, and input submission
 */
</file>

<file path="frontend/src/components/chat/ConversationList.js">
/**
 * Displays the list of conversations
 * Shows unread counts, last messages, and online status
 * Handles conversation selection and search/filtering
 */
</file>

<file path="frontend/src/components/chat/Message.js">
/**
 * Individual message component
 * Renders message content, timestamp, and status
 * Handles different message types (text, image, file, etc.)
 */
</file>

<file path="frontend/src/components/chat/MessageInput.js">
/**
 * Input component for composing and sending messages
 * Handles text input, emoji picker, and file attachments
 * Manages typing indicators and message submission
 */
</file>

<file path="frontend/src/components/chat/MessageList.js">
/**
 * Component for displaying a list of messages
 * Handles infinite scrolling and message grouping
 * Manages read receipts and message status updates
 */
</file>

<file path="frontend/src/components/chat/TypingIndicator.js">
/**
 * Displays typing indicators for active conversations
 * Shows which users are currently typing
 * Handles animation and display of multiple typers
 */
</file>

<file path="frontend/src/components/common/Button.jsx">
import React from 'react';

const Button = ({
  children,
  variant = 'primary',
  size = 'md',
  type = 'button',
  onClick,
  disabled = false,
  loading = false,
  fullWidth = false,
  className = '',
  ...props
}) => {
  // Base styles
  const baseStyles = 'inline-flex items-center justify-center font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-200';
  
  // Variants
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 focus:ring-gray-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
    success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500',
    outline: 'bg-transparent border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-blue-500',
    ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 focus:ring-blue-500',
  };

  // Sizes
  const sizes = {
    sm: 'px-3 py-1.5 text-xs',
    md: 'px-4 py-2 text-sm',
    lg: 'px-6 py-3 text-base',
  };

  // Disabled state
  const disabledStyles = 'opacity-50 cursor-not-allowed';
  
  // Loading state
  const loadingStyles = 'relative';
  const loadingSpinner = (
    <span className="absolute inset-0 flex items-center justify-center">
      <svg className="animate-spin h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </span>
  );

  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled || loading}
      className={`
        ${baseStyles}
        ${variants[variant] || variants.primary}
        ${sizes[size] || sizes.md}
        ${fullWidth ? 'w-full' : ''}
        ${disabled || loading ? disabledStyles : ''}
        ${loading ? loadingStyles : ''}
        ${className}
      `}
      {...props}
    >
      {loading ? (
        <span className="opacity-0">{children}</span>
      ) : (
        children
      )}
      {loading && loadingSpinner}
    </button>
  );
};

export default Button;
</file>

<file path="frontend/src/components/common/Input.jsx">
import React from 'react';

const Input = ({
  label,
  id,
  name,
  type = 'text',
  value,
  onChange,
  placeholder = '',
  error = '',
  disabled = false,
  required = false,
  className = '',
  ...props
}) => {
  const inputId = id || `input-${name || Math.random().toString(36).substr(2, 9)}`;
  
  return (
    <div className={className}>
      {label && (
        <label
          htmlFor={inputId}
          className="block text-sm font-medium text-gray-700 mb-1"
        >
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </label>
      )}
      <div className="mt-1 relative rounded-md shadow-sm">
        <input
          id={inputId}
          name={name}
          type={type}
          value={value}
          onChange={onChange}
          placeholder={placeholder}
          disabled={disabled}
          className={`block w-full px-3 py-2 border ${
            error
              ? 'border-red-300 text-red-900 placeholder-red-300 focus:outline-none focus:ring-red-500 focus:border-red-500'
              : 'border-gray-300 placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500'
          } rounded-md shadow-sm sm:text-sm ${disabled ? 'bg-gray-100' : ''}`}
          {...props}
        />
      </div>
      {error && (
        <p className="mt-1 text-sm text-red-600" id={`${inputId}-error`}>
          {error}
        </p>
      )}
    </div>
  );
};

export default Input;
</file>

<file path="frontend/src/components/common/Navbar.js">
/**
 * Navbar Component
 * Displays the main navigation bar with links and user controls
 * Shows user information and logout button when authenticated
 * Handles navigation between different sections of the app
 */
</file>

<file path="frontend/src/components/common/PrivateRoute.js">
/**
 * PrivateRoute Component
 * Protects routes that require authentication
 * Redirects to login if user is not authenticated
 * Renders the protected component when user is authenticated
 */

import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const PrivateRoute = () => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    // You can render a loading spinner here
    return <div>Loading...</div>;
  }

  return isAuthenticated ? (
    <Outlet />
  ) : (
    <Navigate to="/login" state={{ from: location }} replace />
  );
};

export default PrivateRoute;
</file>

<file path="frontend/src/components/layout/Header.jsx">
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const Header = () => {
  const { isAuthenticated, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  return (
    <header className="bg-white shadow">
      <nav className="container mx-auto px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="text-xl font-semibold text-gray-800">
            <Link to="/">CoachAlly</Link>
          </div>
          
          <div className="flex items-center space-x-4">
            {isAuthenticated ? (
              <>
                <Link to="/dashboard" className="text-gray-600 hover:text-gray-800">
                  Dashboard
                </Link>
                <button
                  onClick={handleLogout}
                  className="px-4 py-2 text-sm text-white bg-red-500 rounded hover:bg-red-600"
                >
                  Logout
                </button>
              </>
            ) : (
              <>
                <Link to="/login" className="text-gray-600 hover:text-gray-800">
                  Login
                </Link>
                <Link
                  to="/register"
                  className="px-4 py-2 text-sm text-white bg-blue-500 rounded hover:bg-blue-600"
                >
                  Sign Up
                </Link>
              </>
            )}
          </div>
        </div>
      </nav>
    </header>
  );
};

export default Header;
</file>

<file path="frontend/src/components/layout/Layout.jsx">
import React from 'react';
import { Outlet } from 'react-router-dom';
import Header from './Header';

const Layout = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-50">
      <Header />
      <main className="container mx-auto px-4 py-8">
        {children || <Outlet />}
      </main>
    </div>
  );
};

export default Layout;
</file>

<file path="frontend/src/config/constants.js">
// API Endpoints
export const API_ENDPOINTS = {
  AUTH: {
    LOGIN: '/auth/login',
    REGISTER: '/auth/register',
    LOGOUT: '/auth/logout',
    ME: '/auth/me',
    REFRESH_TOKEN: '/auth/refresh-token',
    FORGOT_PASSWORD: '/auth/forgot-password',
    RESET_PASSWORD: '/auth/reset-password',
    VERIFY_EMAIL: '/auth/verify-email',
    CHANGE_PASSWORD: '/auth/change-password',
  },
  USERS: {
    BASE: '/users',
    PROFILE: '/users/profile',
    AVATAR: '/users/avatar',
  },
  // Add more API endpoints as needed
};

// Local Storage Keys
export const STORAGE_KEYS = {
  AUTH_TOKEN: 'token',
  REFRESH_TOKEN: 'refreshToken',
  USER: 'user',
  THEME: 'theme',
  LANG: 'i18nextLng',
};

// Theme Configuration
export const THEME = {
  LIGHT: 'light',
  DARK: 'dark',
  SYSTEM: 'system',
  DEFAULT: 'light',
};

// App Constants
export const APP = {
  NAME: 'CoachAlly',
  DESCRIPTION: 'Your coaching companion app',
  VERSION: '1.0.0',
  ENV: process.env.NODE_ENV || 'development',
};

// Date & Time Formats
export const DATE_FORMATS = {
  DATE: 'MM/DD/YYYY',
  DATE_TIME: 'MM/DD/YYYY hh:mm A',
  TIME: 'hh:mm A',
  API_DATE: 'YYYY-MM-DD',
  API_DATE_TIME: 'YYYY-MM-DDTHH:mm:ssZ',
};

// Pagination Defaults
export const PAGINATION = {
  DEFAULT_PAGE: 1,
  DEFAULT_PAGE_SIZE: 10,
  PAGE_SIZES: [5, 10, 25, 50, 100],
};

// Form Validation Defaults
export const VALIDATION = {
  PASSWORD: {
    MIN_LENGTH: 8,
    MAX_LENGTH: 100,
  },
  EMAIL: {
    MAX_LENGTH: 255,
  },
  NAME: {
    MIN_LENGTH: 2,
    MAX_LENGTH: 100,
  },
};

// Error Messages
export const ERROR_MESSAGES = {
  REQUIRED: 'This field is required',
  INVALID_EMAIL: 'Please enter a valid email address',
  PASSWORD_TOO_SHORT: `Password must be at least ${VALIDATION.PASSWORD.MIN_LENGTH} characters`,
  PASSWORD_TOO_LONG: `Password must be no more than ${VALIDATION.PASSWORD.MAX_LENGTH} characters`,
  PASSWORDS_DONT_MATCH: 'Passwords do not match',
  SOMETHING_WENT_WRONG: 'Something went wrong. Please try again later.',
  NETWORK_ERROR: 'Network error. Please check your connection and try again.',
};

// Success Messages
export const SUCCESS_MESSAGES = {
  PROFILE_UPDATED: 'Profile updated successfully',
  PASSWORD_CHANGED: 'Password changed successfully',
  ACCOUNT_CREATED: 'Account created successfully',
  LOGGED_IN: 'Logged in successfully',
  LOGGED_OUT: 'Logged out successfully',
};

// Export all constants as default
export default {
  API_ENDPOINTS,
  STORAGE_KEYS,
  THEME,
  APP,
  DATE_FORMATS,
  PAGINATION,
  VALIDATION,
  ERROR_MESSAGES,
  SUCCESS_MESSAGES,
};
</file>

<file path="frontend/src/context/AuthContext.jsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import apiService from '../services/apiService';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  // Check for existing session on initial load
  useEffect(() => {
    const checkAuth = async () => {
      try {
        const token = localStorage.getItem('token');
        if (token) {
          const userData = await apiService.get('/auth/me');
          setUser(userData);
        }
      } catch (err) {
        console.error('Auth check failed:', err);
        localStorage.removeItem('token');
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email, password) => {
    try {
      setError(null);
      const { token, user } = await apiService.post('/auth/login', { email, password });
      apiService.setAuthToken(token);
      setUser(user);
      navigate('/dashboard');
      return { success: true };
    } catch (err) {
      const errorMessage = err.message || 'Login failed';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  const register = async (userData) => {
    try {
      setError(null);
      const { token, user } = await apiService.post('/auth/register', userData);
      apiService.setAuthToken(token);
      setUser(user);
      navigate('/dashboard');
      return { success: true };
    } catch (err) {
      const errorMessage = err.message || 'Registration failed';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  const logout = () => {
    apiService.setAuthToken(null);
    setUser(null);
    navigate('/login');
  };

  const updateProfile = async (userData) => {
    try {
      setError(null);
      const updatedUser = await apiService.put('/auth/me', userData);
      setUser(updatedUser);
      return { success: true };
    } catch (err) {
      const errorMessage = err.message || 'Failed to update profile';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  const changePassword = async (currentPassword, newPassword) => {
    try {
      setError(null);
      await apiService.post('/auth/change-password', { currentPassword, newPassword });
      return { success: true };
    } catch (err) {
      const errorMessage = err.message || 'Failed to change password';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  };

  const value = {
    user,
    loading,
    error,
    isAuthenticated: !!user,
    login,
    register,
    logout,
    updateProfile,
    changePassword,
    setError,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export default AuthContext;
</file>

<file path="frontend/src/contexts/ChatContext.js">
/**
 * React Context for managing chat state
 * Provides global access to chat data and actions
 * Handles WebSocket events and updates UI state accordingly
 */
</file>

<file path="frontend/src/hooks/useChat.js">
/**
 * Custom hook for chat functionality
 * Manages WebSocket connection, message sending, and state updates
 * Handles reconnections and error states
 */
</file>

<file path="frontend/src/index.js">
/**
 * Application Entry Point
 * Renders the root React component
 * Sets up the app with necessary providers
 * Initializes global styles and error boundaries
 */
</file>

<file path="frontend/src/pages/auth/Login.jsx">
import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import Input from '../../components/common/Input';
import Button from '../../components/common/Button';
import { API_ENDPOINTS, STORAGE_KEYS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../../config/constants';
import { validators, composeValidators } from '../../utils/validators';

const Login = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    rememberMe: false,
  });
  
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [authError, setAuthError] = useState('');
  
  const { login, loading: authLoading } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  // Redirect if already logged in
  useEffect(() => {
    const token = localStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);
    if (token) {
      navigate(location.state?.from?.pathname || '/dashboard', { replace: true });
    }
  }, [navigate, location]);

  // Form validation
  const validateForm = () => {
    const newErrors = {};
    
    // Email validation
    const emailError = composeValidators(
      validators.required,
      validators.email
    )(formData.email);
    
    if (emailError) newErrors.email = emailError;
    
    // Password validation
    const passwordError = composeValidators(
      validators.required,
      validators.minLength(8)
    )(formData.password);
    
    if (passwordError) newErrors.password = passwordError;
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error when user types
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
    
    if (authError) setAuthError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    try {
      setIsSubmitting(true);
      setAuthError('');
      
      const { email, password, rememberMe } = formData;
      await login(email, password);
      
      // Handle remember me
      if (rememberMe) {
        // Set longer expiration for remember me
        // This would be handled by the backend with refresh tokens
        console.log('Remember me enabled');
      }
      
      // Show success message
      // You can use a toast notification here
      console.log(SUCCESS_MESSAGES.LOGGED_IN);
      
      // Redirect to intended page or dashboard
      const from = location.state?.from?.pathname || '/dashboard';
      navigate(from, { replace: true });
      
    } catch (error) {
      console.error('Login error:', error);
      setAuthError(error.message || ERROR_MESSAGES.SOMETHING_WENT_WRONG);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-xl shadow-md">
        <div className="text-center">
          <h2 className="mt-6 text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
          <p className="mt-2 text-sm text-gray-600">
            Or{' '}
            <Link
              to="/register"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              create a new account
            </Link>
          </p>
        </div>

        {authError && (
          <div className="rounded-md bg-red-50 p-4 mb-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg
                  className="h-5 w-5 text-red-400"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                  aria-hidden="true"
                >
                  <path
                    fillRule="evenodd"
                    d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  {authError}
                </h3>
              </div>
            </div>
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="rounded-md shadow-sm space-y-4">
            <div>
              <label htmlFor="email" className="sr-only">
                Email address
              </label>
              <Input
                id="email"
                name="email"
                type="email"
                autoComplete="email"
                required
                label="Email address"
                value={formData.email}
                onChange={handleChange}
                error={errors.email}
                placeholder="Email address"
                disabled={isSubmitting || authLoading}
              />
            </div>

            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <Input
                id="password"
                name="password"
                type="password"
                autoComplete="current-password"
                required
                label="Password"
                value={formData.password}
                onChange={handleChange}
                error={errors.password}
                placeholder="Password"
                disabled={isSubmitting || authLoading}
              />
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                name="rememberMe"
                type="checkbox"
                checked={formData.rememberMe}
                onChange={handleChange}
                className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                disabled={isSubmitting || authLoading}
              />
              <label
                htmlFor="remember-me"
                className="ml-2 block text-sm text-gray-900"
              >
                Remember me
              </label>
            </div>

            <div className="text-sm">
              <Link
                to="/forgot-password"
                className="font-medium text-indigo-600 hover:text-indigo-500"
              >
                Forgot your password?
              </Link>
            </div>
          </div>

          <div>
            <Button
              type="submit"
              variant="primary"
              size="lg"
              fullWidth
              loading={isSubmitting || authLoading}
              disabled={isSubmitting || authLoading}
            >
              {isSubmitting || authLoading ? 'Signing in...' : 'Sign in'}
            </Button>
          </div>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">
                Or continue with
              </span>
            </div>
          </div>

          <div className="mt-6 grid grid-cols-2 gap-3">
            <div>
              <a
                href={`${API_ENDPOINTS.AUTH.BASE}/google`}
                className="w-full inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-500 hover:bg-gray-50"
              >
                <span className="sr-only">Sign in with Google</span>
                <svg
                  className="w-5 h-5"
                  aria-hidden="true"
                  fill="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z" />
                </svg>
              </a>
            </div>

            <div>
              <a
                href={`${API_ENDPOINTS.AUTH.BASE}/github`}
                className="w-full inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-500 hover:bg-gray-50"
              >
                <span className="sr-only">Sign in with GitHub</span>
                <svg
                  className="w-5 h-5"
                  aria-hidden="true"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path
                    fillRule="evenodd"
                    d="M10 0C4.477 0 0 4.484 0 10.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0110 4.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.203 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.942.359.31.678.921.678 1.856 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0020 10.017C20 4.484 15.522 0 10 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"
                    clipRule="evenodd"
                  />
                </svg>
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Login;
</file>

<file path="frontend/src/pages/auth/Register.jsx">
import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import Input from '../../components/common/Input';
import Button from '../../components/common/Button';
import { API_ENDPOINTS, STORAGE_KEYS, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../../config/constants';
import { validators, composeValidators } from '../../utils/validators';

const Register = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: '',
    acceptTerms: false,
  });
  
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [apiError, setApiError] = useState('');
  
  const { register, loading: authLoading } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  // Redirect if already logged in
  useEffect(() => {
    const token = localStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);
    if (token) {
      navigate(location.state?.from?.pathname || '/dashboard', { replace: true });
    }
  }, [navigate, location]);

  // Form validation
  const validateForm = () => {
    const newErrors = {};
    
    // Name validation
    const nameError = composeValidators(
      validators.required,
      validators.minLength(2),
      validators.maxLength(50)
    )(formData.name);
    if (nameError) newErrors.name = nameError;
    
    // Email validation
    const emailError = composeValidators(
      validators.required,
      validators.email
    )(formData.email);
    if (emailError) newErrors.email = emailError;
    
    // Password validation
    const passwordError = composeValidators(
      validators.required,
      validators.minLength(8),
      validators.password
    )(formData.password);
    if (passwordError) newErrors.password = passwordError;
    
    // Confirm password validation
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    // Terms acceptance validation
    if (!formData.acceptTerms) {
      newErrors.acceptTerms = 'You must accept the terms and conditions';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error when user types
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
    
    if (apiError) setApiError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    try {
      setIsSubmitting(true);
      setApiError('');
      
      const { name, email, password } = formData;
      await register({ name, email, password });
      
      // Show success message
      // You can use a toast notification here
      console.log(SUCCESS_MESSAGES.ACCOUNT_CREATED);
      
      // Redirect to dashboard or intended page
      const from = location.state?.from?.pathname || '/dashboard';
      navigate(from, { replace: true });
      
    } catch (error) {
      console.error('Registration error:', error);
      setApiError(error.message || ERROR_MESSAGES.SOMETHING_WENT_WRONG);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-xl shadow-md">
        <div className="text-center">
          <h2 className="mt-6 text-3xl font-extrabold text-gray-900">
            Create your account
          </h2>
          <p className="mt-2 text-sm text-gray-600">
            Or{' '}
            <Link
              to="/login"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              sign in to your account
            </Link>
          </p>
        </div>

        {apiError && (
          <div className="rounded-md bg-red-50 p-4 mb-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg
                  className="h-5 w-5 text-red-400"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                  aria-hidden="true"
                >
                  <path
                    fillRule="evenodd"
                    d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  {apiError}
                </h3>
              </div>
            </div>
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSubmit} noValidate>
          <div className="rounded-md shadow-sm space-y-4">
            <div>
              <Input
                id="name"
                name="name"
                type="text"
                autoComplete="name"
                required
                label="Full name"
                value={formData.name}
                onChange={handleChange}
                error={errors.name}
                placeholder="John Doe"
                disabled={isSubmitting || authLoading}
              />
            </div>

            <div>
              <Input
                id="email"
                name="email"
                type="email"
                autoComplete="email"
                required
                label="Email address"
                value={formData.email}
                onChange={handleChange}
                error={errors.email}
                placeholder="you@example.com"
                disabled={isSubmitting || authLoading}
              />
            </div>

            <div>
              <Input
                id="password"
                name="password"
                type="password"
                autoComplete="new-password"
                required
                label="Password"
                value={formData.password}
                onChange={handleChange}
                error={errors.password}
                placeholder=""
                disabled={isSubmitting || authLoading}
                helpText="Use 8 or more characters with a mix of letters, numbers & symbols"
              />
            </div>

            <div>
              <Input
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                autoComplete="new-password"
                required
                label="Confirm Password"
                value={formData.confirmPassword}
                onChange={handleChange}
                error={errors.confirmPassword}
                placeholder=""
                disabled={isSubmitting || authLoading}
              />
            </div>
          </div>

          <div className="flex items-start">
            <div className="flex items-center h-5">
              <input
                id="acceptTerms"
                name="acceptTerms"
                type="checkbox"
                checked={formData.acceptTerms}
                onChange={handleChange}
                className="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-300 rounded"
                disabled={isSubmitting || authLoading}
              />
            </div>
            <div className="ml-3 text-sm">
              <label htmlFor="acceptTerms" className="font-medium text-gray-700">
                I agree to the{' '}
                <a href="/terms" className="text-indigo-600 hover:text-indigo-500">
                  Terms of Service
                </a>{' '}
                and{' '}
                <a href="/privacy" className="text-indigo-600 hover:text-indigo-500">
                  Privacy Policy
                </a>
                {errors.acceptTerms && (
                  <p className="mt-1 text-sm text-red-600">{errors.acceptTerms}</p>
                )}
              </label>
            </div>
          </div>

          <div>
            <Button
              type="submit"
              variant="primary"
              size="lg"
              fullWidth
              loading={isSubmitting || authLoading}
              disabled={isSubmitting || authLoading}
            >
              {isSubmitting || authLoading ? 'Creating account...' : 'Create account'}
            </Button>
          </div>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">
                Or continue with
              </span>
            </div>
          </div>

          <div className="mt-6 grid grid-cols-2 gap-3">
            <div>
              <a
                href={`${API_ENDPOINTS.AUTH.BASE}/google`}
                className="w-full inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-500 hover:bg-gray-50"
              >
                <span className="sr-only">Sign up with Google</span>
                <svg
                  className="w-5 h-5"
                  aria-hidden="true"
                  fill="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z" />
                </svg>
              </a>
            </div>

            <div>
              <a
                href={`${API_ENDPOINTS.AUTH.BASE}/github`}
                className="w-full inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-500 hover:bg-gray-50"
              >
                <span className="sr-only">Sign up with GitHub</span>
                <svg
                  className="w-5 h-5"
                  aria-hidden="true"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path
                    fillRule="evenodd"
                    d="M10 0C4.477 0 0 4.484 0 10.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0110 4.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.203 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.942.359.31.678.921.678 1.856 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0020 10.017C20 4.484 15.522 0 10 0z"
                    clipRule="evenodd"
                  />
                </svg>
              </a>
            </div>
          </div>
        </div>

        <div className="mt-6 text-center">
          <p className="text-sm text-gray-600">
            Already have an account?{' '}
            <Link
              to="/login"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              Sign in
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default Register;
</file>

<file path="frontend/src/pages/ChatPage.js">
/**
 * ChatPage Component
 * Main chat interface container
 * Combines ConversationList and ChatWindow components
 * Manages active conversation state and message history
 */
</file>

<file path="frontend/src/pages/dashboard/Dashboard.jsx">
import React, { useEffect, useState } from 'react';
import { useAuth } from '../../context/AuthContext';

const Dashboard = () => {
  const { user, logout } = useAuth();
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate loading data
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 1000);

    return () => clearTimeout(timer);
  }, []);

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div className="py-8">
        <div className="pb-5 border-b border-gray-200">
          <h1 className="text-3xl font-bold text-gray-900">Dashboard</h1>
          <p className="mt-2 text-sm text-gray-500">Welcome back, {user?.name || 'User'}!</p>
        </div>

        <div className="mt-8 grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-3">
          {/* Stats Cards */}
          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="px-4 py-5 sm:p-6">
              <div className="flex items-center">
                <div className="flex-shrink-0 bg-blue-500 rounded-md p-3">
                  <svg className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                  </svg>
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">Total Users</dt>
                    <dd className="flex items-baseline">
                      <div className="text-2xl font-semibold text-gray-900">1,234</div>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="px-4 py-5 sm:p-6">
              <div className="flex items-center">
                <div className="flex-shrink-0 bg-green-500 rounded-md p-3">
                  <svg className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                  </svg>
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">Total Projects</dt>
                    <dd className="flex items-baseline">
                      <div className="text-2xl font-semibold text-gray-900">24</div>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="px-4 py-5 sm:p-6">
              <div className="flex items-center">
                <div className="flex-shrink-0 bg-yellow-500 rounded-md p-3">
                  <svg className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">Active Sessions</dt>
                    <dd className="flex items-baseline">
                      <div className="text-2xl font-semibold text-gray-900">3</div>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div className="mt-8 bg-white shadow overflow-hidden sm:rounded-lg">
          <div className="px-4 py-5 sm:px-6">
            <h3 className="text-lg leading-6 font-medium text-gray-900">Your Profile</h3>
            <p className="mt-1 max-w-2xl text-sm text-gray-500">Personal details and information.</p>
          </div>
          <div className="border-t border-gray-200 px-4 py-5 sm:p-0">
            <dl className="sm:divide-y sm:divide-gray-200">
              <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6">
                <dt className="text-sm font-medium text-gray-500">Full name</dt>
                <dd className="mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2">{user?.name || 'N/A'}</dd>
              </div>
              <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6">
                <dt className="text-sm font-medium text-gray-500">Email address</dt>
                <dd className="mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2">{user?.email || 'N/A'}</dd>
              </div>
              <div className="py-4 sm:py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6">
                <dt className="text-sm font-medium text-gray-500">Account status</dt>
                <dd className="mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2">
                  <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                    Active
                  </span>
                </dd>
              </div>
            </dl>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;
</file>

<file path="frontend/src/pages/LoginPage.js">
/**
 * LoginPage Component
 * Renders the login form in a page layout
 * Handles authentication flow and redirects
 * Displays loading states and error messages
 */
</file>

<file path="frontend/src/pages/RegisterPage.js">
/**
 * RegisterPage Component
 * Renders the registration form in a page layout
 * Handles user registration flow and validation
 * Provides feedback for registration status and errors
 */
</file>

<file path="frontend/src/routes/PrivateRoute.jsx">
import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const PrivateRoute = ({ children }) => {
  const { isAuthenticated, loading } = useAuth();

  if (loading) {
    return <div>Loading...</div>; // Or a loading spinner
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return children || <Outlet />;
};

export default PrivateRoute;
</file>

<file path="frontend/src/services/api.js">
import axios from 'axios';

// Determine the base URL based on the environment
const API_URL = process.env.NODE_ENV === 'development' 
  ? process.env.REACT_APP_DEV_API_URL || 'http://localhost:5000/api' // Default dev backend URL
  : process.env.REACT_APP_PROD_API_URL || '/api'; // Default prod backend URL (relative path for same-host deployment)

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

/**
 * Interceptor to add the JWT token to requests if available.
 * This is another place you could manage adding the token, but AuthContext already does it.
 * Keeping it here for reference or if you prefer this pattern.
 */
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token && !config.headers.Authorization) { // Check if AuthContext already set it
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

/**
 * Interceptor to handle common API errors, like 401 for unauthorized access.
 * This could be used for global error handling, e.g., redirecting to login on 401.
 */
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Handle unauthorized access, e.g., by logging out the user
      // This can be more complex if you're handling token refresh
      console.error('API request unauthorized (401). Token might be invalid or expired.');
      // Example: Trigger logout from AuthContext or redirect
      // This part needs careful consideration with AuthContext's role
      // For now, AuthContext handles token removal on its own initialization/error handling.
    }
    return Promise.reject(error);
  }
);

export default api;
</file>

<file path="frontend/src/services/apiService.js">
import axios from 'axios';

// Create axios instance with default config
const apiClient = axios.create({
  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:5000/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add auth token to requests
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle common errors
apiClient.interceptors.response.use(
  (response) => {
    return response.data;
  },
  (error) => {
    // Handle common errors (e.g., 401 Unauthorized)
    if (error.response?.status === 401) {
      // Clear auth data and redirect to login
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    
    // Return error with message
    const errorMessage = error.response?.data?.message || error.message || 'Something went wrong';
    return Promise.reject(new Error(errorMessage));
  }
);

// Helper methods for common HTTP methods
const apiService = {
  // GET request
  get: async (url, config = {}) => {
    try {
      const response = await apiClient.get(url, config);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // POST request
  post: async (url, data = {}, config = {}) => {
    try {
      const response = await apiClient.post(url, data, config);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // PUT request
  put: async (url, data = {}, config = {}) => {
    try {
      const response = await apiClient.put(url, data, config);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // PATCH request
  patch: async (url, data = {}, config = {}) => {
    try {
      const response = await apiClient.patch(url, data, config);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // DELETE request
  delete: async (url, config = {}) => {
    try {
      const response = await apiClient.delete(url, config);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Set authentication token
  setAuthToken: (token) => {
    if (token) {
      apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      localStorage.setItem('token', token);
    } else {
      delete apiClient.defaults.headers.common['Authorization'];
      localStorage.removeItem('token');
    }
  },
};

export default apiService;
</file>

<file path="frontend/src/services/authService.js">
import apiService from './apiService';

const authService = {
  // Login user
  login: async (email, password) => {
    try {
      const response = await apiService.post('/auth/login', { email, password });
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Register new user
  register: async (userData) => {
    try {
      const response = await apiService.post('/auth/register', userData);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Get current user
  getCurrentUser: async () => {
    try {
      const response = await apiService.get('/auth/me');
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Update user profile
  updateProfile: async (userData) => {
    try {
      const response = await apiService.put('/auth/me', userData);
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Change password
  changePassword: async (currentPassword, newPassword) => {
    try {
      const response = await apiService.post('/auth/change-password', {
        currentPassword,
        newPassword,
      });
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Request password reset
  forgotPassword: async (email) => {
    try {
      const response = await apiService.post('/auth/forgot-password', { email });
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Reset password with token
  resetPassword: async (token, password) => {
    try {
      const response = await apiService.post('/auth/reset-password', {
        token,
        password,
      });
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Verify email
  verifyEmail: async (token) => {
    try {
      const response = await apiService.post('/auth/verify-email', { token });
      return response;
    } catch (error) {
      throw error;
    }
  },

  // Logout (client-side only)
  logout: () => {
    apiService.setAuthToken(null);
  },
};

export default authService;
</file>

<file path="frontend/src/services/socketService.js">
/**
 * WebSocket service for managing real-time communication
 * Handles connection to the WebSocket server and event emission/listening
 * Manages reconnection logic and connection state
 */
</file>

<file path="frontend/src/utils/validators.js">
// Email validation regex
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

// Password requirements:
// - At least 8 characters
// - At least one uppercase letter
// - At least one lowercase letter
// - At least one number
// - At least one special character
const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*])(?=.{8,})/;

// Validation functions
export const validators = {
  required: (value) => (value ? undefined : 'This field is required'),
  
  email: (value) => 
    !value || emailRegex.test(value) ? undefined : 'Please enter a valid email address',
  
  minLength: (min) => (value) =>
    !value || value.length >= min 
      ? undefined 
      : `Must be at least ${min} characters`,
  
  maxLength: (max) => (value) =>
    !value || value.length <= max 
      ? undefined 
      : `Must be no more than ${max} characters`,
  
  password: (value) =>
    !value || passwordRegex.test(value)
      ? undefined
      : 'Password must be at least 8 characters long and include uppercase, lowercase, number, and special character',
  
  confirmPassword: (password) => (value) =>
    !value || value === password ? undefined : 'Passwords do not match',
  
  url: (value) => {
    if (!value) return undefined;
    try {
      new URL(value);
      return undefined;
    } catch (_) {
      return 'Please enter a valid URL';
    }
  },
  
  numeric: (value) => 
    !value || /^\d+$/.test(value) ? undefined : 'Must be a number',
  
  minValue: (min) => (value) =>
    !value || parseFloat(value) >= min 
      ? undefined 
      : `Must be at least ${min}`,
  
  maxValue: (max) => (value) =>
    !value || parseFloat(value) <= max 
      ? undefined 
      : `Must be no more than ${max}`,
};

// Helper function to compose multiple validators
export const composeValidators = (...validators) => (value) =>
  validators.reduce(
    (error, validator) => error || (validator && validator(value)),
    undefined
  );

// Common validation schemas
export const validationSchemas = {
  email: [
    validators.required,
    validators.email,
  ],
  
  password: [
    validators.required,
    validators.minLength(8),
    validators.password,
  ],
  
  name: [
    validators.required,
    validators.minLength(2),
    validators.maxLength(50),
  ],
  
  url: [
    validators.required,
    validators.url,
  ],
  
  requiredField: [
    validators.required,
  ],
};

// Function to validate a form field
export const validateField = (value, rules) => {
  if (!rules) return undefined;
  
  const errors = rules
    .map(rule => (typeof rule === 'function' ? rule(value) : undefined))
    .filter(Boolean);
    
  return errors.length > 0 ? errors[0] : undefined;
};

// Function to validate entire form
export const validateForm = (values, schema) => {
  const errors = {};
  
  Object.keys(schema).forEach(field => {
    const fieldError = validateField(values[field], schema[field]);
    if (fieldError) {
      errors[field] = fieldError;
    }
  });
  
  return Object.keys(errors).length === 0 ? null : errors;
};
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 [Your Name]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="project_documentation.md">
# ADHD Coach Application - File Structure Documentation

## Overview
This document outlines the purpose of each file in the AI-powered ADHD Coach application structure.

## Mobile App (/mobile-app)

### Core Files
- `src/App.js`: Main application component that serves as the entry point for the ADHD Coach mobile app. Handles routing, global state management, and overall app configuration.
- `src/index.js`: Entry point for the React Native application. Initializes the app and connects it to the native platform.
- `src/app.json`: Application configuration file containing settings for app name, version, and other metadata.
- `src/package.json`: Package information and dependencies for the mobile application.

### Components
#### Conversation
- `src/components/Conversation/ConversationContainer.js`: Container component that manages the chat interface between the user and the AI coach.
- `src/components/Conversation/MessageBubble.js`: UI component for rendering individual messages in the conversation.
- `src/components/Conversation/EmotionIndicator.js`: Component that visualizes the detected emotional state of the user based on their messages.

#### Task Management
- `src/components/TaskManagement/TaskList.js`: Component for displaying and managing the user's tasks and to-do items.
- `src/components/TaskManagement/TaskBreakdown.js`: Component that helps break down complex tasks into smaller, manageable steps.
- `src/components/TaskManagement/Calendar.js`: Calendar view for scheduling and visualizing tasks over time.

#### Gamification
- `src/components/Gamification/RewardSystem.js`: Implements the reward and point system to motivate users to complete tasks.
- `src/components/Gamification/ProgressTracker.js`: Visualizes the user's progress and achievements over time.

#### Common
- `src/components/Common/Button.js`: Reusable button component with consistent styling across the app.
- `src/components/Common/Modal.js`: Reusable modal dialog component for confirmations and notifications.

### Navigation
- `src/navigation/AppNavigator.js`: Handles screen navigation and routing throughout the application.

### Screens
- `src/screens/Dashboard.js`: Main dashboard screen showing overview of tasks, mood, and progress.

### Context
- `src/contexts/UserContext.js`: Context provider for user-related state management.
- `src/contexts/TaskContext.js`: Context provider for task-related state management.
- `src/contexts/EmotionalStateContext.js`: Context provider for tracking the user's emotional state.

### Hooks
- `src/hooks/useConversation.js`: Custom hook for managing conversation state and interactions with the AI.

## Backend (/backend)

### API
#### Routes
- `src/api/routes/conversationRoutes.js`: API endpoints for conversation-related actions.
- `src/api/routes/taskRoutes.js`: API endpoints for task management actions.
- `src/api/routes/userRoutes.js`: API endpoints for user account management.

#### Controllers
- `src/api/controllers/conversationController.js`: Handles business logic for conversation-related API requests.
- `src/api/controllers/taskController.js`: Handles business logic for task management API requests.
- `src/api/controllers/userController.js`: Handles business logic for user management API requests.

#### Middleware
- `src/api/middlewares/auth.js`: Authentication middleware to verify user identity and permissions.
- `src/api/middlewares/errorHandler.js`: Global error handling middleware for API requests.

### Services
#### AI Services
- `src/services/ai/languageModel.js`: Service for interacting with the OpenAI language model.
- `src/services/ai/emotionDetection.js`: Service for detecting and analyzing user emotions from text.
- `src/services/ai/adaptiveCoaching.js`: Service that adapts coaching strategies based on user behavior and needs.

#### Task Services
- `src/services/task/taskBreakdown.js`: Service for breaking down complex tasks into manageable steps.
- `src/services/task/reminderService.js`: Service for managing task reminders and notifications.

#### User Services
- `src/services/user/profileService.js`: Service for managing user profile information.
- `src/services/user/preferencesService.js`: Service for managing user preferences and settings.

### Models
- `src/models/User.js`: Data model for user accounts and profiles.
- `src/models/Task.js`: Data model for tasks and to-do items.
- `src/models/Conversation.js`: Data model for storing conversation history.
- `src/models/EmotionalState.js`: Data model for tracking user emotional states over time.

## OpenAI Integration (/openai-integration)

### Services
- `src/services/openaiService.js`: Core service for communicating with the OpenAI API.
- `src/services/promptManager.js`: Service for managing and optimizing prompts sent to the OpenAI API.
- `src/services/contextManager.js`: Service for managing conversation context and history for the OpenAI API.

### Configuration
- `src/config/openaiConfig.js`: Configuration settings for the OpenAI API integration.

## Security (/security)

### API Key Management
- `src/apiKey/keyManager.js`: Service for securely managing and rotating OpenAI API keys.

### Proxy
- `src/proxy/openaiProxy.js`: Proxy service for securely routing OpenAI API requests.

### Monitoring
- `src/monitoring/usageMonitor.js`: Service for monitoring and controlling OpenAI API usage and costs.
</file>

<file path="test-login.js">
const axios = require('axios');

const testLogin = async () => {
  try {
    console.log('Attempting to log in with test@example.com...');
    const response = await axios.post('http://localhost:5000/api/auth/login', {
      email: 'test@example.com',
      password: 'testpassword123'
    }, {
      validateStatus: (status) => status < 500 // Don't throw on 4xx errors
    });
    
    console.log('Login successful!');
    console.log('Full response:', JSON.stringify(response.data, null, 2));
    console.log('Access Token:', response.data.accessToken || 'No access token found');
    console.log('User:', response.data.user ? JSON.stringify(response.data.user, null, 2) : 'No user data found');
    return response.data.accessToken;
  } catch (error) {
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      console.error('Error response data:', error.response.data);
      console.error('Status code:', error.response.status);
      console.error('Response headers:', error.response.headers);
    } else if (error.request) {
      // The request was made but no response was received
      console.error('No response received:', error.request);
    } else {
      // Something happened in setting up the request that triggered an Error
      console.error('Error setting up request:', error.message);
    }
    console.error('Error config:', error.config);
    throw error;
  }
};

// Run the test
if (require.main === module) {
  testLogin().catch(console.error);
}

module.exports = testLogin;
</file>

<file path=".gitignore">
# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Node.js
node_modules/
npm-debug.log
yarn-debug.log
yarn-error.log
package-lock.json
yarn.lock

# React Native
# Xcode
ios/build/
ios/Pods/
ios/*.xcworkspace
ios/*.xcodeproj/xcuserdata/
ios/*.xcodeproj/project.xcworkspace/xcuserdata/
ios/*.xcworkspace/contents.xcworkspacedata
**/ios/**/build/
**/ios/**/.xcode.env.local

# Android/IntelliJ
android/.gradle
android/app/build/
android/build/
android/local.properties
android/captures/
.gradle
**/android/**/build/
**/android/**/local.properties
**/android/**/gradle-wrapper.jar

# Fastlane
**/android/**/fastlane/report.xml
**/android/**/fastlane/Preview.html
**/android/**/fastlane/screenshots
**/android/**/fastlane/test_output

# Bundle artifact
*.jsbundle

# Expo
.expo/
web-build/
web-report/
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/
web-report/
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*

# Babel
lib/**/*.js

# Metro
.metro-health-check*

# Coverage directory used by tools like istanbul
coverage/

# Env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE
.idea/
.vscode/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Repomix output
repomix-output.xml
mobile-app/repomix-output.xml

# Backend logs
backend/logs/

# Temp files
.temp/
.tmp/
.temp*/
.tmp*/
</file>

<file path="backend/.env.example">
# Server Configuration
PORT=5000
NODE_ENV=development

# Database Configuration
DB_USERNAME=your_db_username
DB_PASSWORD=your_db_password
DB_DATABASE=your_database_name
DB_HOST=localhost
DB_PORT=3306 # Example, adjust if different
DB_DIALECT=mysql # or postgres, or sqlite

# JWT Configuration
JWT_SECRET=your_jwt_secret_key
JWT_REFRESH_SECRET=your_jwt_refresh_secret_key
JWT_ACCESS_EXPIRATION_MINUTES=60
JWT_REFRESH_EXPIRATION_DAYS=7
JWT_PASSWORD_RESET_EXPIRATION_MINUTES=60
JWT_EMAIL_VERIFICATION_EXPIRATION_MINUTES=1440

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000 # 15 minutes
RATE_LIMIT_MAX=100 # requests per window

# Client URL for CORS
CLIENT_URL=http://localhost:3000

# AI Coach Configuration
AI_COACH_USER_ID=bffc93b4-f1d1-4395-bd7e-aef35648ed4e
AI_COACH_USERNAME=AICoach
AI_COACH_EMAIL=coach@example.com
AI_COACH_PASSWORD=aSecurePassword123!

# OpenAI API Configuration
OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=gpt-3.5-turbo
</file>

<file path="backend/config/config.js">
/**
 * Database configuration for different environments.
 * Loads environment variables from the project root .env file.
 * 
 * @module config/database
 * @requires dotenv
 * @requires path
 */

require('dotenv').config({ path: require('path').resolve(__dirname, '../.env') });
const fs = require('fs');
const path = require('path');

// Ensure logs directory exists
const logDir = path.join(__dirname, '../logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

// Configure logging function
const logging = process.env.NODE_ENV === 'development' 
  ? (msg) => {
      const logFile = path.join(logDir, 'sql.log');
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] ${msg}`);
      fs.appendFileSync(logFile, `[${timestamp}] ${msg}\n`);
    }
  : false; // Disable SQL logging in production

module.exports = {
  jwt: {
    secret: process.env.JWT_SECRET || 'your_default_jwt_secret_key',
    refreshSecret: process.env.JWT_REFRESH_SECRET || 'your_default_jwt_refresh_secret_key',
    accessExpirationMinutes: parseInt(process.env.JWT_ACCESS_EXPIRATION_MINUTES || '60', 10),
    refreshExpirationDays: parseInt(process.env.JWT_REFRESH_EXPIRATION_DAYS || '7', 10),
    passwordResetExpirationMinutes: parseInt(process.env.JWT_PASSWORD_RESET_EXPIRATION_MINUTES || '60', 10),
    emailVerificationExpirationMinutes: parseInt(process.env.JWT_EMAIL_VERIFICATION_EXPIRATION_MINUTES || '1440', 10),
    cookieOptions: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    },
  },
  development: {
    username: process.env.DB_USERNAME || 'root',
    password: process.env.DB_PASSWORD || 'Loloreno1',
    database: process.env.DB_DATABASE || 'coach_ally',
    host: process.env.DB_HOST || '127.0.0.1',
    port: parseInt(process.env.DB_PORT || '3306', 10),
    dialect: process.env.DB_DIALECT || 'mysql',
    logging: logging,
    dialectOptions: {
      // charset: 'utf8mb4_general_ci',
      // ssl: process.env.DB_SSL === 'true' ? { require: true, rejectUnauthorized: false } : false,
    }
  },
  test: {
    username: process.env.TEST_DB_USERNAME || process.env.DB_USERNAME,
    password: process.env.TEST_DB_PASSWORD || process.env.DB_PASSWORD,
    database: process.env.TEST_DB_DATABASE || `${process.env.DB_DATABASE}_test`,
    host: process.env.TEST_DB_HOST || process.env.DB_HOST || '127.0.0.1',
    port: parseInt(process.env.TEST_DB_PORT || process.env.DB_PORT || '3306', 10),
    dialect: process.env.TEST_DB_DIALECT || process.env.DB_DIALECT || 'mysql',
    logging: false,  // Disable logging during tests
    dialectOptions: {
      ssl: process.env.TEST_DB_SSL === 'true' 
        ? { require: true, rejectUnauthorized: false } 
        : false
    }
  },
  production: {
    username: process.env.PROD_DB_USERNAME || process.env.DB_USERNAME,
    password: process.env.PROD_DB_PASSWORD || process.env.DB_PASSWORD,
    database: process.env.PROD_DB_DATABASE || process.env.DB_DATABASE,
    host: process.env.PROD_DB_HOST || process.env.DB_HOST,
    port: parseInt(process.env.PROD_DB_PORT || process.env.DB_PORT || '3306', 10),
    dialect: process.env.PROD_DB_DIALECT || process.env.DB_DIALECT || 'mysql',
    logging: false,  // Disable logging in production
    dialectOptions: {
      ssl: process.env.PROD_DB_SSL === 'true'
        ? { 
            require: true,
            rejectUnauthorized: process.env.PROD_DB_SSL_REJECT_UNAUTHORIZED === 'false' ? false : true
          }
        : false
    }
  }
};
</file>

<file path="backend/config/config.json">
{
  "development": {
    "username": "root",
    "password": "Loloreno1",
    "database": "coach_ally",
    "host": "127.0.0.1",
    "port": 3306,
    "dialect": "mysql",
    "seederStorage": "sequelize",
    "seederStorageTableName": "SequelizeData"
  },
  "test": {
    "username": "root",
    "password": "Loloreno1",
    "database": "coach_ally_test",
    "host": "127.0.0.1",
    "port": 3306,
    "dialect": "mysql",
    "logging": false,
    "seederStorage": "sequelize",
    "seederStorageTableName": "SequelizeData"
  },
  "production": {
    "use_env_variable": "DATABASE_URL",
    "dialect": "mysql",
    "logging": false,
    "dialectOptions": {
      "ssl": {
        "require": true,
        "rejectUnauthorized": false
      }
    },
    "seederStorage": "sequelize",
    "seederStorageTableName": "SequelizeData"
  }
}
</file>

<file path="backend/controllers/aiChatController.js">
const httpStatus = require('http-status-codes');
const AIChatService = require('../services/aiChatService');
const logger = require('../utils/logger');

class AIChatController {
  /**
   * Send a message to the AI coach
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  static async sendMessage(req, res) {
    try {
      const { content } = req.body;
      const userId = req.user.id;

      if (!content || typeof content !== 'string' || content.trim() === '') {
        return res.status(httpStatus.BAD_REQUEST).json({
          status: 'error',
          message: 'Message content is required'
        });
      }

      const aiMessage = await AIChatService.sendMessageToAI(userId, content);
      
      res.status(httpStatus.CREATED).json({
        status: 'success',
        data: {
          message: aiMessage
        }
      });
    } catch (error) {
      logger.error('Error in sendMessage:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        status: 'error',
        message: 'Failed to send message to AI',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }

  /**
   * Get AI conversation history
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  static async getConversation(req, res) {
    try {
      const userId = req.user.id;
      const { limit = 20, offset = 0 } = req.query;

      const result = await AIChatService.getAIConversation(
        userId,
        parseInt(limit),
        parseInt(offset)
      );
      
      res.json({
        status: 'success',
        data: result
      });
    } catch (error) {
      logger.error('Error in getConversation:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        status: 'error',
        message: 'Failed to fetch AI conversation',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }

  /**
   * Clear AI conversation history
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  static async clearConversation(req, res) {
    try {
      const userId = req.user.id;
      await AIChatService.clearAIConversation(userId);
      
      res.json({
        status: 'success',
        message: 'AI conversation history cleared'
      });
    } catch (error) {
      logger.error('Error in clearConversation:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        status: 'error',
        message: 'Failed to clear AI conversation',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
}

module.exports = AIChatController;
</file>

<file path="backend/controllers/messageController.js">
const messageService = require('../services/messageService');
const logger = require('../utils/logger');
const httpStatusCodes = require('http-status-codes');

/**
 * @description Send a new message in a conversation and generate AI response.
 * @route POST /api/conversations/:conversationId/messages
 * @access Private
 */
const sendMessageHandler = async (req, res, next) => {
    try {
        const senderId = req.user.id;
        const { conversationId } = req.params;
        const { content, type, metadata } = req.body;

        if (!content) {
            return res.status(httpStatusCodes.BAD_REQUEST).json({ message: 'Message content is required.' });
        }

        logger.info(`MESSAGE CONTROLLER: Processing message from user ${senderId} in conversation ${conversationId}`);
        
        // Get both user message and AI response
        const { userMessage, aiMessage } = await messageService.sendMessage(
            senderId,
            conversationId,
            content,
            type,
            metadata
        );

        // Get Socket.IO instance
        const io = req.app.get('io');
        
        // Emit user message via WebSocket
        if (io && userMessage) {
            logger.info(`MESSAGE CONTROLLER: Emitting user message ${userMessage.id} via WebSocket`);
            io.to(conversationId.toString()).emit('newMessage', userMessage);
        }

        // Emit AI message via WebSocket (with slight delay to simulate thinking)
        if (io && aiMessage) {
            logger.info(`MESSAGE CONTROLLER: Emitting AI message ${aiMessage.id} via WebSocket`);
            // Optional delay to simulate AI thinking
            setTimeout(() => {
                io.to(conversationId.toString()).emit('newMessage', aiMessage);
            }, 500); // 500ms delay
        }

        // Respond to HTTP request with the user's message
        res.status(httpStatusCodes.CREATED).json(userMessage);
    } catch (error) {
        logger.error('Error in sendMessageHandler:', error);
        // Pass to global error handler or handle specific errors
        if (error.status) { // If error has a status (like from service layer)
             return res.status(error.status).json({ message: error.message });
        }
        next(error); // For generic error handling middleware
    }
};

/**
 * @description Get message history for a conversation.
 * @route GET /api/conversations/:conversationId/messages
 * @access Private
 */
const getMessagesHandler = async (req, res, next) => {
    logger.info(`MESSAGE CONTROLLER: Entered getMessagesHandler for convId: ${req.params.conversationId}`); // Added logging
    try {
        const userId = req.user.id;
        const { conversationId } = req.params;
        const { page, limit, beforeMessageId, afterMessageId } = req.query;

        const messagesResult = await messageService.getMessages(
            conversationId,
            userId,
            {
                page: page ? parseInt(page, 10) : undefined,
                limit: limit ? parseInt(limit, 10) : undefined,
                beforeMessageId,
                afterMessageId
            }
        );
        res.status(httpStatusCodes.OK).json(messagesResult);
    } catch (error) {
        logger.error('Error in getMessagesHandler:', error);
        if (error.status) {
             return res.status(error.status).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * @description Mark messages in a conversation as read.
 * @route POST /api/conversations/:conversationId/messages/read
 * @access Private
 */
const markMessagesAsReadHandler = async (req, res, next) => {
    try {
        const userId = req.user.id;
        const { conversationId } = req.params;
        const { lastReadMessageId } = req.body; // Or however you identify what's been read

        // This service function is a placeholder in your code, you'll need to implement its logic
        const result = await messageService.markMessagesAsRead(conversationId, userId, lastReadMessageId);
        
        // const io = req.app.get('io');
        // if (io) {
        //    io.to(conversationId.toString()).emit('messagesRead', { conversationId, readerId: userId, lastReadMessageId });
        // }

        res.status(httpStatusCodes.OK).json(result);
    } catch (error) {
        logger.error('Error in markMessagesAsReadHandler:', error);
         if (error.status) {
             return res.status(error.status).json({ message: error.message });
        }
        next(error);
    }
};


module.exports = {
    sendMessageHandler,
    getMessagesHandler,
    markMessagesAsReadHandler,
    // Add other handlers as you implement them (update, delete, etc.)
};
</file>

<file path="backend/controllers/taskController.js">
const TaskService = require('../services/taskService');
const httpStatus = require('http-status-codes');
const logger = require('../utils/logger');

class TaskController {
  static async createTask(req, res) {
    try {
      const task = await TaskService.createTask(req.user.id, req.body);
      res.status(httpStatus.CREATED).json(task);
    } catch (error) {
      logger.error('Create task error:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        message: error.message || 'Error creating task',
      });
    }
  }

  static async getTasks(req, res) {
    try {
      const { status, limit = 10, offset = 0 } = req.query;
      const result = await TaskService.getTasks(req.user.id, { status, limit, offset });
      res.json(result);
    } catch (error) {
      logger.error('Get tasks error:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        message: 'Error fetching tasks',
      });
    }
  }

  static async getTask(req, res) {
    try {
      const task = await TaskService.getTaskById(req.user.id, req.params.taskId);
      res.json(task);
    } catch (error) {
      if (error.message === 'Task not found') {
        return res.status(httpStatus.NOT_FOUND).json({ message: error.message });
      }
      logger.error('Get task error:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        message: 'Error fetching task',
      });
    }
  }

  static async updateTask(req, res) {
    try {
      const task = await TaskService.updateTask(
        req.user.id,
        req.params.taskId,
        req.body
      );
      res.json(task);
    } catch (error) {
      if (error.message === 'Task not found or not authorized') {
        return res.status(httpStatus.NOT_FOUND).json({ message: error.message });
      }
      logger.error('Update task error:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        message: 'Error updating task',
      });
    }
  }

  static async deleteTask(req, res) {
    try {
      await TaskService.deleteTask(req.user.id, req.params.taskId);
      res.status(httpStatus.NO_CONTENT).send();
    } catch (error) {
      if (error.message === 'Task not found or not authorized') {
        return res.status(httpStatus.NOT_FOUND).json({ message: error.message });
      }
      logger.error('Delete task error:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        message: 'Error deleting task',
      });
    }
  }

  static async getUpcomingTasks(req, res) {
    try {
      const tasks = await TaskService.getUpcomingTasks(
        req.user.id,
        req.query.days || 7
      );
      res.json(tasks);
    } catch (error) {
      logger.error('Get upcoming tasks error:', error);
      res.status(httpStatus.INTERNAL_SERVER_ERROR).json({
        message: 'Error fetching upcoming tasks',
      });
    }
  }
}

module.exports = TaskController;
</file>

<file path="backend/middleware/authMiddleware.js">
// backend/middleware/authMiddleware.js

const jwt = require('jsonwebtoken');
const { User } = require('../models'); // Adjust path if necessary
const config = require('../config/config'); // Ensure this path is correct and loads your jwt.secret
const { UnauthorizedError } = require('../utils/errors');
const logger = require('../utils/logger');

const authMiddleware = async (req, res, next) => {
    let token;
    // Log the entire authorization header
    logger.info(`AUTH_MIDDLEWARE: Authorization Header: [${req.headers.authorization}]`);

    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
        try {
            token = req.headers.authorization.split(' ')[1];

            // Check for common invalid token string values
            if (!token || token === 'null' || token === 'undefined' || token.trim() === '') {
                logger.warn(`AUTH_MIDDLEWARE: Invalid token string extracted: [${token}]`);
                return next(new UnauthorizedError('Not authorized, malformed token.'));
            }

            logger.info(`AUTH_MIDDLEWARE: Token to verify: [${token}]`);

            const decoded = jwt.verify(token, config.jwt.secret); // Error happens here if token is bad
            logger.info(`AUTH_MIDDLEWARE: Token decoded successfully for user ID: ${decoded.id}`);

            const user = await User.findByPk(decoded.id, {
                attributes: { exclude: ['password', 'passwordResetToken', 'passwordResetTokenExpires', 'emailVerificationToken', 'emailVerificationTokenExpires', 'refreshTokenHash'] }
            });

            if (!user) {
                logger.warn(`AUTH_MIDDLEWARE: User not found for token ID: ${decoded.id}`);
                return next(new UnauthorizedError('Not authorized, user not found.'));
            }

            req.user = user.get({ plain: true }); // Attach plain user object
            logger.info(`AUTH_MIDDLEWARE: User ${req.user.username} authenticated.`);
            next();
        } catch (error) {
            logger.error('AUTH_MIDDLEWARE: JWT Verification or User Fetch Error:', {
                message: error.message,
                name: error.name,
                tokenProvided: token, // Log the token that caused the error
            });
            if (error.name === 'JsonWebTokenError') {
                return next(new UnauthorizedError('Not authorized, token failed verification (malformed or invalid signature).'));
            } else if (error.name === 'TokenExpiredError') {
                return next(new UnauthorizedError('Not authorized, token expired.'));
            }
            return next(new UnauthorizedError('Not authorized, an unexpected error occurred with token.'));
        }
    } else {
        logger.warn('AUTH_MIDDLEWARE: No Bearer token in authorization header.');
        return next(new UnauthorizedError('Not authorized, no token in header.'));
    }
};

module.exports = authMiddleware;
</file>

<file path="backend/middleware/websocket/auth.js">
/**
 * WebSocket authentication middleware
 * Verifies JWT tokens for WebSocket connections
 * Attaches user information to socket for authorization
 */
const jwt = require('jsonwebtoken');
const { User } = require('../../models'); 
const config = require('../../config/config'); 
const logger = require('../../utils/logger'); 

const socketAuthMiddleware = async (socket, next) => {
    // Token can be sent in handshake query or auth headers (e.g., socket.handshake.auth.token)
    const token = socket.handshake.auth?.token || socket.handshake.query?.token;

    if (!token) {
        logger.warn('WebSocket connection attempt without token.');
        // Create a custom error object that Socket.IO can send to the client
        const err = new Error('Authentication error: Token not provided');
        err.data = { content: 'Token not provided for WebSocket connection.' }; // additional details for client
        return next(err);
    }

    try {
        // Ensure you are using the correct secret key from config.js
        const jwtSecret = config.jwt.secret;
        logger.info(`WS Auth: JWT Secret Used: [${jwtSecret ? '***SECRET EXISTS***' : 'UNDEFINED'}]`);
        
        if (!jwtSecret) {
            logger.error('WS Auth: config.jwt.secret is indeed falsy.');
            const err = new Error('Authentication error: Server configuration issue');
            err.data = { content: 'Server configuration error for JWT.' };
            return next(err);
        }
        const decoded = jwt.verify(token, jwtSecret);
        
        // Assuming your JWT payload has an 'id' field for the user's primary key
        const user = await User.findByPk(decoded.id);

        if (!user) {
            logger.warn(`WebSocket authentication failed: User not found for ID ${decoded.id}`);
            const err = new Error('Authentication error: User not found');
            err.data = { content: 'User associated with token not found.' };
            return next(err);
        }

        // Attach user to the socket object for use in event handlers
        socket.user = {
            id: user.id,
            username: user.username,
            email: user.email
            // Add other relevant non-sensitive user fields if needed
        };
        logger.info(`WebSocket authenticated for user: ${socket.user.username} (ID: ${socket.user.id}) (Socket ID: ${socket.id})`);
        next(); // Proceed to the next middleware or connection handler
    } catch (error) {
        logger.error('WebSocket authentication error:', error.message);
        let authError = new Error('Authentication error: Could not verify token');
        if (error.name === 'TokenExpiredError') {
            authError = new Error('Authentication error: Token expired');
            authError.data = { content: 'Access token has expired.' };
        } else if (error.name === 'JsonWebTokenError') {
            authError = new Error('Authentication error: Invalid token');
            authError.data = { content: 'Access token is invalid.' };
        }
        return next(authError);
    }
};

module.exports = socketAuthMiddleware;
</file>

<file path="backend/models/User.js">
'use strict';
const { Model } = require('sequelize');
const bcrypt = require('bcryptjs');

module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    static associate(models) {
      // Messages sent by the user
      User.hasMany(models.Message, { 
        foreignKey: 'sender_id', 
        as: 'sentMessages' 
      });
      
      // Conversations the user participates in
      User.belongsToMany(models.Conversation, { 
        through: models.UserConversation,
        foreignKey: 'user_id',
        otherKey: 'conversation_id',
        as: 'conversations'
      });
      
      // User's participation in conversations
      User.hasMany(models.UserConversation, {
        foreignKey: 'user_id',
        as: 'conversationParticipants'
      });
    }

    async comparePassword(candidatePassword) {
      return bcrypt.compare(candidatePassword, this.password);
    }

    async generateAuthTokens() {
      const jwt = require('jsonwebtoken');
      const config = require('../config/config');
      
      const accessToken = jwt.sign(
        { id: this.id, role: this.role },
        config.jwt.secret,
        { expiresIn: config.jwt.accessExpirationMinutes * 60 }
      );
      
      const refreshToken = jwt.sign(
        { id: this.id },
        config.jwt.refreshSecret,
        { expiresIn: config.jwt.refreshExpirationDays * 24 * 60 * 60 }
      );
      
      this.refresh_token = refreshToken;
      await this.save();
      
      return { accessToken, refreshToken };
    }
  }

  User.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
      field: 'id'
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      field: 'username',
      validate: {
        notEmpty: { msg: 'Username cannot be empty.' },
        len: {
          args: [3, 30],
          msg: 'Username must be between 3 and 30 characters.'
        },
        is: {
          args: /^[a-zA-Z0-9_]+$/,
          msg: 'Username can only contain letters, numbers, and underscores.'
        }
      }
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      field: 'email',
      validate: {
        isEmail: { msg: 'Invalid email address.' },
        notEmpty: { msg: 'Email cannot be empty.' }
      }
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      field: 'password',
      validate: {
        notEmpty: { msg: 'Password cannot be empty.' },
        len: {
          args: [8, 100],
          msg: 'Password must be at least 8 characters long.'
        }
      }
    },
    first_name: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'first_name',
      validate: {
        len: {
          args: [1, 50],
          msg: 'First name must be between 1 and 50 characters.'
        }
      }
    },
    last_name: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'last_name',
      validate: {
        len: {
          args: [1, 50],
          msg: 'Last name must be between 1 and 50 characters.'
        }
      }
    },
    role: {
      type: DataTypes.ENUM('user', 'admin'),
      allowNull: false,
      defaultValue: 'user',
      field: 'role'
    },
    is_email_verified: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
      field: 'is_email_verified'
    },
    last_login: {
      type: DataTypes.DATE,
      allowNull: true,
      field: 'last_login'
    },
    refresh_token: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'refresh_token'
    },
    password_reset_token: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'password_reset_token'
    },
    password_reset_expires: {
      type: DataTypes.DATE,
      allowNull: true,
      field: 'password_reset_expires'
    },
    email_verification_token: {
      type: DataTypes.STRING,
      allowNull: true,
      field: 'email_verification_token'
    },
    email_verification_token_expires: {
      type: DataTypes.DATE,
      allowNull: true,
      field: 'email_verification_token_expires'
    },
    created_at: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'created_at',
      defaultValue: DataTypes.NOW
    },
    updated_at: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'updated_at',
      defaultValue: DataTypes.NOW
    }
  }, {
    sequelize,
    modelName: 'User',
    tableName: 'users',
    timestamps: true,
    underscored: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    defaultScope: {
      attributes: { 
        exclude: [
          'password', 
          'refresh_token', 
          'password_reset_token', 
          'email_verification_token',
          'email_verification_token_expires',
          'password_reset_expires'
        ] 
      },
    },
    scopes: {
      withSensitiveData: {
        attributes: { 
          include: [
            'password', 
            'refresh_token', 
            'password_reset_token', 
            'email_verification_token',
            'email_verification_token_expires',
            'password_reset_expires'
          ] 
        },
      },
    },
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
      },
      beforeUpdate: async (user) => {
        if (user.changed('password')) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
      }
    }
  });

  return User;
};
</file>

<file path="backend/routes/aiChat.js">
const express = require('express');
const { body, query } = require('express-validator');
const { authenticateJWT } = require('../middleware/auth');
const { validateRequest } = require('../middleware/validators/commonValidator');
const AIChatController = require('../controllers/aiChatController');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticateJWT);

/**
 * @route   POST /api/ai/chat
 * @desc    Send a message to the AI coach
 * @access  Private
 */
router.post(
  '/chat',
  [
    body('content')
      .trim()
      .notEmpty()
      .withMessage('Message content is required')
      .isLength({ max: 2000 })
      .withMessage('Message must be less than 2000 characters'),
  ],
  validateRequest,
  AIChatController.sendMessage
);

/**
 * @route   GET /api/ai/conversation
 * @desc    Get AI conversation history
 * @access  Private
 */
router.get(
  '/conversation',
  [
    query('limit')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage('Limit must be between 1 and 100')
      .toInt(),
    query('offset')
      .optional()
      .isInt({ min: 0 })
      .withMessage('Offset must be a positive integer')
      .toInt(),
  ],
  validateRequest,
  AIChatController.getConversation
);

/**
 * @route   DELETE /api/ai/conversation
 * @desc    Clear AI conversation history
 * @access  Private
 */
router.delete(
  '/conversation',
  AIChatController.clearConversation
);

module.exports = router;
</file>

<file path="backend/routes/api/messages.js">
const express = require('express');
// Ensure mergeParams is true to access :conversationId from parent router
const router = express.Router({ mergeParams: true }); 
const messageController = require('../../controllers/messageController');
const {
    sendMessageRules,
    getMessagesRules,
    markMessagesAsReadRules,
    validateRequest
} = require('../../middleware/validators/messageValidator');
const authMiddleware = require('../../middleware/authMiddleware'); // Use the real auth middleware
const logger = require('../../utils/logger');

logger.info('MESSAGE ROUTER FILE LOADED'); // Confirm this file is loaded by Node

// @route   POST /
// @desc    Send a new message in a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/messages)
router.post(
    '/',
    authMiddleware,
    sendMessageRules(),
    validateRequest,
    messageController.sendMessageHandler
);

// @route   GET /
// @desc    Get message history for a conversation
// @access  Private
// (Mounted at /api/conversations/:conversationId/messages)
router.get(
    '/',
    (req, res, next) => {
        logger.info(`MESSAGE ROUTE: Initial entry for GET / (convId: ${req.params.conversationId})`);
        next();
    },
    authMiddleware,
    (req, res, next) => {
        logger.info(`MESSAGE ROUTE: After authMiddleware for GET / (user: ${req.user ? req.user.id : 'null'})`);
        next();
    },
    getMessagesRules(),
    (req, res, next) => {
        logger.info('MESSAGE ROUTE: After getMessagesRules for GET /');
        next();
    },
    validateRequest,
    (req, res, next) => {
        logger.info('MESSAGE ROUTE: After validateRequest for GET /');
        next();
    },
    messageController.getMessagesHandler
);

// @route   POST /read
// @desc    Mark messages in a conversation as read
// @access  Private
// (Mounted at /api/conversations/:conversationId/messages/read)
router.post(
    '/read',
    authMiddleware,
    markMessagesAsReadRules(),
    validateRequest,
    messageController.markMessagesAsReadHandler
);

module.exports = router;
</file>

<file path="backend/routes/tasks.js">
const express = require('express');
const router = express.Router();
const TaskController = require('../controllers/taskController');
const { authenticateJWT } = require('../middleware/auth');
const { body, param, query } = require('express-validator');
const { validateRequest } = require('../middleware/validators/commonValidator');

// Apply authentication middleware to all task routes
router.use(authenticateJWT);

// Create a new task
router.post(
  '/',
  [
    body('title').trim().notEmpty().withMessage('Title is required'),
    body('description').optional().trim(),
    body('dueDate').optional().isISO8601().withMessage('Invalid date format'),
    body('priority').optional().isIn(['low', 'medium', 'high']).withMessage('Invalid priority'),
    body('category').optional().trim(),
  ],
  validateRequest,
  TaskController.createTask
);

// Get all tasks with optional filtering
router.get(
  '/',
  [
    query('status').optional().isIn(['all', 'completed', 'pending']).withMessage('Invalid status'),
    query('limit').optional().isInt({ min: 1, max: 100 }).toInt(),
    query('offset').optional().isInt({ min: 0 }).toInt()
  ],
  validateRequest,
  TaskController.getTasks
);

// Get a single task by ID
router.get(
  '/:taskId',
  [
    param('taskId').isUUID().withMessage('Invalid task ID')
  ],
  validateRequest,
  TaskController.getTask
);

// Update a task
router.put(
  '/:taskId',
  [
    param('taskId').isUUID().withMessage('Invalid task ID'),
    body('title').optional().trim().notEmpty().withMessage('Title cannot be empty'),
    body('description').optional().trim(),
    body('dueDate').optional().isISO8601().withMessage('Invalid date format'),
    body('priority').optional().isIn(['low', 'medium', 'high']).withMessage('Invalid priority'),
    body('completed').optional().isBoolean().withMessage('Completed must be a boolean'),
    body('category').optional().trim()
  ],
  validateRequest,
  TaskController.updateTask
);

// Delete a task
router.delete(
  '/:taskId',
  [
    param('taskId').isUUID().withMessage('Invalid task ID')
  ],
  validateRequest,
  TaskController.deleteTask
);

// Get upcoming tasks
router.get(
  '/upcoming/tasks',
  [
    query('days').optional().isInt({ min: 1, max: 30 }).withMessage('Days must be between 1 and 30').toInt()
  ],
  validateRequest,
  TaskController.getUpcomingTasks
);

module.exports = router;
</file>

<file path="backend/scripts/mark-migration-complete.js">
/**
 * Script to mark specific migrations as complete in the SequelizeMeta table.
 * This is useful when consolidating migrations or manually applying changes.
 */

const { Sequelize } = require('sequelize');
const config = require('../config/config');

// List of migrations to mark as complete
const MIGRATIONS_TO_MARK = [
  '20250519202930-add-is-ai-conversation-column.js'  // Our consolidated migration
];

async function markMigrationsComplete() {
  const env = process.env.NODE_ENV || 'development';
  const dbConfig = config[env];
  
  console.log(`Connecting to database: ${dbConfig.database}@${dbConfig.host}`);
  
  const sequelize = new Sequelize(
    dbConfig.database,
    dbConfig.username,
    dbConfig.password,
    {
      host: dbConfig.host,
      port: dbConfig.port,
      dialect: dbConfig.dialect,
      logging: false,
      dialectOptions: {
        // Add any necessary SSL options here if needed
        // ssl: dbConfig.dialectOptions?.ssl
      }
    }
  );

  try {
    // Test the connection
    await sequelize.authenticate();
    console.log(' Database connection established successfully.');

    // Ensure SequelizeMeta table exists
    await sequelize.getQueryInterface().showAllTables();
    
    // Mark each migration as complete
    for (const migrationName of MIGRATIONS_TO_MARK) {
      try {
        const [results] = await sequelize.query(
          'SELECT name FROM SequelizeMeta WHERE name = ?',
          { replacements: [migrationName] }
        );
        
        if (results.length === 0) {
          await sequelize.query(
            'INSERT INTO SequelizeMeta (name) VALUES (?)',
            { replacements: [migrationName] }
          );
          console.log(` Marked migration as complete: ${migrationName}`);
        } else {
          console.log(` Migration already marked as complete: ${migrationName}`);
        }
      } catch (error) {
        console.error(` Error processing migration ${migrationName}:`, error.message);
      }
    }
    
    console.log(' All migrations processed successfully');
    
  } catch (error) {
    console.error(' Error marking migrations as complete:', error.message);
    process.exit(1);
  } finally {
    // Close the connection
    if (sequelize) {
      await sequelize.close();
      console.log('Database connection closed.');
    }
  }
}

// Run the script
markMigrationsComplete()
  .then(() => {
    console.log('Script completed successfully');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Script failed:', error);
    process.exit(1);
  });
</file>

<file path="backend/services/aiService.js">
const { OpenAI } = require('openai');
const logger = require('../utils/logger');

class AIService {
  constructor() {
    if (!process.env.OPENAI_API_KEY) {
      logger.warn('OpenAI API key not configured. AI features will be disabled.');
      this.openai = null;
      this.isConfigured = false; // Add a flag to check if configured
      return;
    }

    // Directly instantiate the OpenAI client
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.isConfigured = true; // Mark as configured
    this.model = process.env.OPENAI_MODEL || 'gpt-3.5-turbo';
    this.systemPrompt = process.env.COACH_ALLY_SYSTEM_PROMPT ||
      'You are Coach Ally, a supportive and encouraging AI assistant. ' +
      'Help users with their tasks, provide guidance, and offer helpful suggestions.';
    logger.info(`OpenAI Service configured with model: ${this.model}`);
  }

  async generateResponse(messages, userId) {
    if (!this.isConfigured || !this.openai) { // Check the flag
      logger.warn('AIService.generateResponse called but OpenAI service is not configured.');
      throw new Error('OpenAI service is not configured');
    }

    try {
      const conversation = [
        { role: 'system', content: this.systemPrompt },
        ...messages,
      ];

      logger.info(`Generating AI response for user ${userId} with model ${this.model}`);

      // Use the new API structure for chat completions
      const response = await this.openai.chat.completions.create({
        model: this.model,
        messages: conversation,
        temperature: 0.7,
        max_tokens: 500,
        user: userId, // Associate chat with user for abuse monitoring
      });

      return response.choices[0].message.content.trim();
    } catch (error) {
      logger.error('Error generating AI response:', {
        message: error.message,
        name: error.name,
        // Consider logging parts of the error object if it's an APIError from OpenAI
        ...(error.response && error.response.data && { responseData: error.response.data }),
        stack: error.stack
      });
      throw new Error('Failed to generate AI response');
    }
  }

  async generateTaskSuggestions(userTasks, userId) {
    if (!this.isConfigured || !this.openai) { // Check the flag
      logger.warn('AIService.generateTaskSuggestions called but OpenAI service is not configured.');
      throw new Error('OpenAI service is not configured');
    }

    try {
      const taskList = userTasks
        .map((task, index) => `${index + 1}. ${task.title} (${task.priority} priority)`)
        .join('\n');

      const prompt = `The user has the following tasks:\n${taskList}\n\n` +
        'Please provide 3-5 suggestions for organizing or prioritizing these tasks. ' +
        'Consider due dates, priorities, and task relationships. ' +
        'Be encouraging and provide actionable advice.';

      // Assuming generateResponse is updated as above
      const response = await this.generateResponse(
        [{ role: 'user', content: prompt }],
        userId
      );

      return response;
    } catch (error) {
      logger.error('Error generating task suggestions:', error);
      throw new Error('Failed to generate task suggestions');
    }
  }

  async analyzeTask(task, userId) {
    if (!this.isConfigured || !this.openai) { // Check the flag
      logger.warn('AIService.analyzeTask called but OpenAI service is not configured.');
      throw new Error('OpenAI service is not configured');
    }

    try {
      const prompt = `Task: ${task.title}\n` +
        (task.description ? `Description: ${task.description}\n` : '') +
        (task.dueDate ? `Due Date: ${new Date(task.dueDate).toDateString()}\n` : '') +
        `Priority: ${task.priority || 'Not specified'}\n\n` +
        'Please analyze this task and provide suggestions for breaking it down into smaller, ' +
        'more manageable steps. Also, suggest any resources or considerations that might help with completion.';

      // Assuming generateResponse is updated as above
      const response = await this.generateResponse(
        [{ role: 'user', content: prompt }],
        userId
      );

      return response;
    } catch (error) {
      logger.error('Error analyzing task:', error);
      throw new Error('Failed to analyze task');
    }
  }
}

// Export a singleton instance
module.exports = new AIService();
</file>

<file path="backend/services/authService.js">
/**
 * Authentication Service
 * 
 * Handles core authentication logic including user registration, login,
 * token generation, and password management.
 * 
 * @module services/authService
 * @requires bcryptjs
 * @requires jsonwebtoken
 * @requires ../models/User
 * @requires ../config/config
 * @requires ../utils/logger
 * @requires ../utils/errors
 * 
 * @example
 * // Example usage:
 * const { registerUser, loginUser } = require('../services/authService');
 * const user = await registerUser(userData);
 * const tokens = await loginUser(email, password);
 */

const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { User } = require('../models'); // Assuming models/index.js exports models
const config = require('../config/config');
const logger = require('../utils/logger');
const crypto = require('crypto');
const { ApiError, SMTPEror, BadRequestError, NotFoundError, UnauthorizedError, ForbiddenError } = require('../utils/errors'); // Assuming custom errors
const httpStatusCodes = require('http-status-codes');

/**
 * Registers a new user.
 * @param {object} userData - The user data (username, email, password, firstName, lastName).
 * @returns {Promise<User>} The created user object (without sensitive data).
 * @throws {ApiError} If email or username already exists, or on other validation errors.
 */
const registerUser = async (userData) => {
  const { email, username, password, first_name, last_name } = userData;

  // Check if email or username already exists
  const existingUserByEmail = await User.findOne({ where: { email } });
  if (existingUserByEmail) {
    throw new BadRequestError('Email address is already in use.');
  }

  const existingUserByUsername = await User.findOne({ where: { username } });
  if (existingUserByUsername) {
    throw new BadRequestError('Username is already taken.');
  }

  try {
    const user = await User.create({
      username,
      email,
      password,
      first_name,
      last_name,
      role: 'user',
      is_email_verified: false,
    });
    logger.info(`User registered successfully: ${user.email}`);
    // The toJSON method in the User model should handle removing sensitive fields.
    return user; 
  } catch (error) {
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
      // Extract meaningful messages from Sequelize errors
      const messages = error.errors.map(e => e.message).join(', ');
      logger.error(`Validation error during registration: ${messages}`);
      throw new BadRequestError(`Registration failed: ${messages}`);
    }    
    logger.error(`Error registering user: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred during registration.');
  }
};

/**
 * Logs in an existing user.
 * @param {string} email - The user's email.
 * @param {string} password - The user's password.
 * @returns {Promise<{user: User, tokens: {accessToken: string, refreshToken: string}}>} User object and tokens.
 * @throws {ApiError} If login fails (e.g., invalid credentials, user not found).
 */
const loginUser = async (email, password) => {
  if (!email || !password) {
    throw new BadRequestError('Email and password are required.');
  }

  // Find user by email, including sensitive info for password comparison
  const user = await User.scope('withSensitiveData').findOne({ where: { email } });

  if (!user) {
    logger.warn(`Login attempt failed for non-existent email: ${email}`);
    throw new UnauthorizedError('Invalid email or password.');
  }

  // Compare password
  const isPasswordMatch = await user.comparePassword(password);
  if (!isPasswordMatch) {
    logger.warn(`Login attempt failed for user ${email}: Incorrect password.`);
    throw new UnauthorizedError('Invalid email or password.');
  }

  // Generate tokens
  const tokens = await user.generateAuthTokens();

  // Update lastLogin timestamp
  user.lastLogin = new Date();
  await user.save({ fields: ['lastLogin'] }); // Only update lastLogin

  logger.info(`User logged in successfully: ${user.email}`);
  // The user object returned here will be serialized by its toJSON method (or defaultScope if not overridden by toJSON)
  return { user, tokens }; 
};

/**
 * Refreshes authentication tokens using a refresh token.
 * @param {string} oldRefreshToken - The refresh token to be verified.
 * @returns {Promise<{accessToken: string, refreshToken: string}>} New access and refresh tokens.
 * @throws {ApiError} If the refresh token is invalid, expired, or not found.
 */
const refreshAuthTokens = async (oldRefreshToken) => {
  if (!oldRefreshToken) {
    throw new BadRequestError('Refresh token is required.');
  }

  try {
    // Verify the refresh token
    const decoded = jwt.verify(oldRefreshToken, config.jwt.refreshSecret);
    
    // Find user by ID from token, including sensitive info to check stored refresh token
    const user = await User.scope('withSensitiveInfo').findByPk(decoded.id);

    if (!user) {
      logger.warn(`Refresh token verification failed: User ${decoded.id} not found.`);
      throw new UnauthorizedError('Invalid refresh token: User not found.');
    }

    // Check if the provided refresh token matches the one stored in the database
    if (user.refreshToken !== oldRefreshToken) {
      logger.warn(`Refresh token mismatch for user ${user.email}. Possible token reuse or old token.`);
      // Optionally, invalidate all user sessions here for security
      // user.refreshToken = null;
      // await user.save();
      throw new UnauthorizedError('Invalid refresh token: Token has been invalidated or is old.');
    }

    // Generate new tokens (this will also save the new refresh token to the user model)
    const newTokens = await user.generateAuthTokens();
    logger.info(`Tokens refreshed successfully for user: ${user.email}`);
    return newTokens;

  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError || error instanceof jwt.TokenExpiredError) {
      logger.warn(`Refresh token verification failed: ${error.message}`);
      throw new UnauthorizedError(`Invalid or expired refresh token: ${error.message}`);
    }
    logger.error(`Error refreshing tokens: ${error.message}`, { stack: error.stack });
    // If it's an error we threw (like UnauthorizedError from user not found/token mismatch), rethrow it
    if (error instanceof ApiError) {
        throw error;
    }
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while refreshing tokens.');
  }
};

/**
 * Logs out a user by invalidating their refresh token.
 * @param {string} userId - The ID of the user to log out.
 * @returns {Promise<void>}
 * @throws {ApiError} If the user is not found or an error occurs.
 */
const logoutUser = async (userId) => {
  if (!userId) {
    throw new BadRequestError('User ID is required for logout.');
  }

  const user = await User.scope('withSensitiveInfo').findByPk(userId);

  if (!user) {
    // This case might be debatable: if user doesn't exist, are they 'logged out'? 
    // For security, treating as an error or logging is fine.
    logger.warn(`Logout attempt for non-existent user ID: ${userId}`);
    throw new NotFoundError('User not found, cannot logout.');
  }

  // Invalidate the refresh token
  user.refreshToken = null;
  try {
    await user.save({ fields: ['refreshToken'] });
    logger.info(`User logged out successfully: ${user.email}`);
  } catch (error) {
    logger.error(`Error during logout for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred during logout.');
  }
};

/**
 * Generates a password reset token for a user and stores its hash.
 * (In a real app, this would also trigger sending an email with the plain token).
 * @param {string} email - The email of the user requesting a password reset.
 * @returns {Promise<string>} The plain password reset token (for email sending).
 * @throws {ApiError} If the user is not found or an error occurs.
 */
const requestPasswordReset = async (email) => {
  if (!email) {
    throw new BadRequestError('Email is required to request a password reset.');
  }

  const user = await User.scope('withSensitiveInfo').findOne({ where: { email } });

  if (!user) {
    // Do not reveal if the user exists or not for security reasons.
    // Log it, but return a generic success-like message or handle it in the controller.
    logger.info(`Password reset request for non-existent email: ${email}`);
    // To prevent email enumeration, you might not want to throw an error here that indicates the user doesn't exist.
    // However, for service-level logic, knowing the user wasn't found is important. The controller can mask this.
    // For now, we'll throw NotFoundError, but this is a design consideration.
    throw new NotFoundError('User with this email not found.'); 
  }

  // Generate a plain token
  const resetToken = crypto.randomBytes(32).toString('hex');

  // Hash the token before storing it in the database
  user.passwordResetToken = crypto.createHash('sha256').update(resetToken).digest('hex');
  // Set expiration (e.g., 1 hour from now)
  user.passwordResetExpires = new Date(Date.now() + (config.jwt.passwordResetExpirationMinutes || 60) * 60 * 1000); 

  try {
    await user.save({ fields: ['passwordResetToken', 'passwordResetExpires'] });
    logger.info(`Password reset token generated for user: ${email}`);
    // In a real application, you would now send an email to the user with 'resetToken'
    // e.g., sendPasswordResetEmail(user.email, resetToken);
    return resetToken; // Return the plain token to be used in the reset link
  } catch (error) {
    logger.error(`Error saving password reset token for user ${email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while requesting password reset.');
  }
};

/**
 * Resets a user's password using a valid reset token.
 * @param {string} resetToken - The plain password reset token.
 * @param {string} newPassword - The new password to set.
 * @returns {Promise<void>}
 * @throws {ApiError} If the token is invalid, expired, or the user is not found.
 */
const resetPassword = async (resetToken, newPassword) => {
  if (!resetToken || !newPassword) {
    throw new BadRequestError('Reset token and new password are required.');
  }

  // Hash the incoming plain token to match the one stored in the database
  const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');

  // Find user by the hashed token and check if it's not expired
  const user = await User.scope('withSensitiveInfo').findOne({
    where: {
      passwordResetToken: hashedToken,
      passwordResetExpires: { [User.sequelize.Op.gt]: new Date() }, // Check if token is not expired
    },
  });

  if (!user) {
    logger.warn('Invalid or expired password reset token attempt.');
    throw new BadRequestError('Password reset token is invalid or has expired.');
  }

  // Set the new password (it will be hashed by the beforeUpdate hook in the User model)
  user.password = newPassword;
  // Clear the reset token fields
  user.passwordResetToken = null;
  user.passwordResetExpires = null;
  // Also clear any existing refresh token to force re-login on other devices
  user.refreshToken = null; 

  try {
    await user.save({ fields: ['password', 'passwordResetToken', 'passwordResetExpires', 'refreshToken'] });
    logger.info(`Password reset successfully for user: ${user.email}`);
    // In a real application, you might send a confirmation email here
    // e.g., sendPasswordResetSuccessEmail(user.email);
  } catch (error) {
    if (error.name === 'SequelizeValidationError') {
        const messages = error.errors.map(e => e.message).join(', ');
        logger.error(`Validation error during password reset for ${user.email}: ${messages}`);
        throw new BadRequestError(`Password reset failed: ${messages}`);
    }
    logger.error(`Error resetting password for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while resetting password.');
  }
};


/**
 * Generates an email verification token for a user and stores its hash.
 * (In a real app, this would also trigger sending an email with the plain token).
 * @param {string} userId - The ID of the user requesting email verification.
 * @returns {Promise<string>} The plain email verification token (for email sending).
 * @throws {ApiError} If the user is not found, already verified, or an error occurs.
 */
const requestEmailVerification = async (userId) => {
  if (!userId) {
    throw new BadRequestError('User ID is required to request email verification.');
  }

  const user = await User.scope('withSensitiveInfo').findByPk(userId);

  if (!user) {
    logger.warn(`Email verification request for non-existent user ID: ${userId}`);
    throw new NotFoundError('User not found.');
  }

  if (user.isEmailVerified) {
    logger.info(`Email verification requested for already verified user: ${user.email}`);
    throw new BadRequestError('Email is already verified.');
  }

  // Generate a plain token
  const verificationToken = crypto.randomBytes(32).toString('hex');

  // Hash the token before storing it in the database
  user.emailVerificationToken = crypto.createHash('sha256').update(verificationToken).digest('hex');
  // Set expiration (e.g., 24 hours from now)
  user.emailVerificationTokenExpires = new Date(Date.now() + (config.jwt.emailVerificationExpirationMinutes || 24 * 60) * 60 * 1000); 

  try {
    await user.save({ fields: ['emailVerificationToken', 'emailVerificationTokenExpires'] });
    logger.info(`Email verification token generated for user: ${user.email}`);
    // In a real application, you would now send an email to the user with 'verificationToken'
    // e.g., sendEmailVerificationLink(user.email, verificationToken);
    return verificationToken; // Return the plain token to be used in the verification link
  } catch (error) {
    logger.error(`Error saving email verification token for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while requesting email verification.');
  }
};

/**
 * Verifies a user's email address using a valid verification token.
 * @param {string} verificationToken - The plain email verification token.
 * @returns {Promise<void>}
 * @throws {ApiError} If the token is invalid, expired, or the user is not found.
 */
const verifyEmail = async (verificationToken) => {
  if (!verificationToken) {
    throw new BadRequestError('Email verification token is required.');
  }

  // Hash the incoming plain token to match the one stored in the database
  const hashedToken = crypto.createHash('sha256').update(verificationToken).digest('hex');

  // Find user by the hashed token and check if it's not expired
  const user = await User.scope('withSensitiveInfo').findOne({
    where: {
      emailVerificationToken: hashedToken,
      emailVerificationTokenExpires: { [User.sequelize.Op.gt]: new Date() }, // Check if token is not expired
    },
  });

  if (!user) {
    logger.warn('Invalid or expired email verification token attempt.');
    throw new BadRequestError('Email verification token is invalid or has expired.');
  }

  if (user.isEmailVerified) {
    logger.info(`Email already verified for user: ${user.email}. Token was (re)used.`);
    // Optionally, still clear the token to prevent reuse, even if already verified.
    user.emailVerificationToken = null;
    user.emailVerificationTokenExpires = null;
    try {
      await user.save({ fields: ['emailVerificationToken', 'emailVerificationTokenExpires']});
    } catch (saveError) {
        // Log error but don't fail the overall already-verified status.
        logger.error(`Error clearing already-used verification token for ${user.email}: ${saveError.message}`);
    }
    return; // Or throw BadRequestError('Email is already verified.') if strict about token reuse.
  }

  user.isEmailVerified = true;
  user.emailVerificationToken = null;
  user.emailVerificationTokenExpires = null;

  try {
    await user.save({ fields: ['isEmailVerified', 'emailVerificationToken', 'emailVerificationTokenExpires'] });
    logger.info(`Email verified successfully for user: ${user.email}`);
    // In a real application, you might send a welcome email or confirmation here
  } catch (error) {
    logger.error(`Error verifying email for user ${user.email}: ${error.message}`, { stack: error.stack });
    throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'An unexpected error occurred while verifying email.');
  }
};

module.exports = {
  registerUser,
  loginUser,
  refreshAuthTokens,
  logoutUser,
  requestPasswordReset,
  resetPassword,
  requestEmailVerification,
  verifyEmail,
};
</file>

<file path="backend/services/messageService.js">
// Contains business logic and data access for message operations
const { Op, col } = require('sequelize');
const { Message, User, Conversation, UserConversation, sequelize } = require('../models'); // Adjust path if your models are elsewhere
const logger = require('../utils/logger'); // Adjust path for your logger
const openAIService = require('../../openai-integration/src/services/openaiService'); // Import OpenAI service

/**
 * Sends a new message in a conversation.
 * @param {string} senderId - The ID of the user sending the message.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} content - The content of the message.
 * @param {string} type - The type of message (e.g., 'text', 'image'). Defaults to 'text'.
 * @param {object|null} metadata - Additional metadata for the message (e.g., image URL, file info).
 * @returns {Promise<Message>} The created message object with sender details.
 */
const sendMessage = async (senderId, conversationId, content, type = 'text', metadata = null) => {
    logger.info(`Sending message: senderId=${senderId}, conversationId=${conversationId}, type=${type}`);

    if (!senderId || !conversationId || !content) {
        throw new Error('Sender ID, Conversation ID, and Content are required to send a message.');
    }

    try {
        // 1. Verify conversation exists and sender is a participant (important for authorization)
        const conversation = await Conversation.findByPk(conversationId, {
            include: [{
                model: UserConversation,
                as: 'userConversations',
                attributes: ['userId']
            }]
        });

        if (!conversation) {
            throw new Error(`Conversation with ID ${conversationId} not found.`);
        }

        const isParticipant = conversation.userConversations.some(uc => uc.userId === senderId);
        if (!isParticipant) {
            const authError = new Error(`User ${senderId} is not a participant of conversation ${conversationId}.`);
            authError.status = 403; // Forbidden
            throw authError;
        }

        // 2. Create the message
        const message = await Message.create({
            senderId,
            conversationId,
            content,
            type,
            metadata,
            status: 'sent' // Or 'sending' if client confirmation is awaited for 'sent'
        });
        
        // 3. Update the conversation's updatedAt timestamp to mark recent activity
        // This helps in ordering conversations by the latest message.
        await conversation.changed('updatedAt', true); // Mark 'updatedAt' as changed
        await conversation.update({ updatedAt: new Date() }); // Force update, or simply save if no other changes

        // 4. Fetch the message again with sender details to return the full object (as expected by WebSocket handlers)
        const userMessageWithSender = await Message.findByPk(message.id, {
            include: [{
                model: User,
                as: 'sender',
                attributes: ['id', 'username', 'email'] // Include necessary sender fields
            }]
        });

        logger.info(`User message ${userMessageWithSender.id} sent successfully by ${senderId} in conversation ${conversationId}`);
        
        // 5. Generate AI response
        let aiMessageWithSender = null;
        try {
            // Fetch recent conversation history for context
            const history = await Message.findAll({
                where: { conversationId },
                order: [[sequelize.col('created_at'), 'DESC']], // Use sequelize.col for proper column name
                limit: 10, // Get last 10 messages for context
                include: [{
                    model: User,
                    as: 'sender',
                    attributes: ['id', 'username']
                }]
            });
            
            // Format history for OpenAI API
            const formattedHistory = history.reverse().map(msg => ({
                role: msg.sender.id === senderId ? 'user' : 'assistant',
                content: msg.content
            }));
            
            // Get AI coach user ID
            const AI_COACH_USER_ID = process.env.AI_COACH_USER_ID || 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e';
            
            // Call OpenAI service to generate response
            logger.info(`Generating AI response for message: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`);
            const aiResponseContent = await openAIService.generateReply(formattedHistory, content);
            
            if (aiResponseContent) {
                // Create AI message in database
                const aiMessage = await Message.create({
                    senderId: AI_COACH_USER_ID,
                    conversationId,
                    content: aiResponseContent,
                    type: 'text',
                    status: 'sent'
                });
                
                // Update conversation timestamp again
                await conversation.update({ updatedAt: new Date() });
                
                // Fetch AI message with sender details
                aiMessageWithSender = await Message.findByPk(aiMessage.id, {
                    include: [{
                        model: User,
                        as: 'sender',
                        attributes: ['id', 'username', 'email']
                    }]
                });
                
                logger.info(`AI message ${aiMessageWithSender.id} created for conversation ${conversationId}`);
            }
        } catch (aiError) {
            logger.error(`Error generating AI response: ${aiError.message}`, aiError);
            // Don't let AI errors block the user message flow
        }
        
        // Return both messages
        return {
            userMessage: userMessageWithSender,
            aiMessage: aiMessageWithSender // Will be null if AI didn't respond or errored
        };
    } catch (error) {
        logger.error('Error sending message:', error);
        if (!error.status) error.status = 500; // Default to server error if not set
        throw error;
    }
};

/**
 * Retrieves messages for a specific conversation with pagination.
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userId - The ID of the user requesting messages (for auth check).
 * @param {object} options - Pagination options.
 * @param {number} options.page - The page number (e.g., 1 for the latest page if ordering DESC).
 * @param {number} options.limit - Number of messages per page (default: 50).
 * @param {string|null} options.beforeMessageId - Fetches messages created before the message with this ID (for older messages).
 * @param {string|null} options.afterMessageId - Fetches messages created after the message with this ID (for newer messages/updates).
 * @returns {Promise<object>} An object containing messages and pagination info.
 */
const getMessages = async (conversationId, userId, { page, limit = 30, beforeMessageId, afterMessageId } = {}) => {
    logger.info(`MESSAGE SERVICE: Entered getMessages for convId: ${conversationId}, userId: ${userId}`);
    logger.info(`Fetching messages for conversation ${conversationId}, user ${userId}, options: ${JSON.stringify({ page, limit, beforeMessageId, afterMessageId })}`);

    try {
        // 1. Verify conversation exists and user is a participant
        logger.info(`MESSAGE SERVICE: Finding conversation ${conversationId} for participation check.`);
        const conversation = await Conversation.findByPk(conversationId, {
            include: [{
                model: UserConversation,
                as: 'userConversations', // Ensure this alias is correct as per Conversation.js model
                attributes: ['userId']
            }]
        });

        if (!conversation) {
            logger.warn(`MESSAGE SERVICE: Conversation ${conversationId} not found during getMessages.`);
            // For a 404 from the service layer, you might want a custom error
            const notFoundError = new Error(`Conversation with ID ${conversationId} not found.`);
            notFoundError.status = 404;
            throw notFoundError;
        }

        logger.info(`MESSAGE SERVICE: Conversation ${conversationId} found.`);

        const isParticipant = conversation.userConversations.some(uc => uc.userId === userId);
        if (!isParticipant) {
            logger.warn(`MESSAGE SERVICE: User ${userId} is not a participant of conversation ${conversationId}. Access denied.`);
            const authError = new Error(`User ${userId} is not a participant of conversation ${conversationId}.`);
            authError.status = 403; // Forbidden
            throw authError;
        }
        logger.info(`MESSAGE SERVICE: User ${userId} is participant. Fetching messages.`);

        // Default query options
        const queryOptions = {
            where: { conversationId },
            include: [{
                model: User,
                as: 'sender',
                attributes: ['id', 'username', 'email']
            }],
            order: [[sequelize.col('created_at'), 'DESC']], // Use sequelize.col() to reference the actual DB column name
            limit
        };

        if (beforeMessageId) {
            const cursorMessage = await Message.findByPk(beforeMessageId, { attributes: ['createdAt'] });
            if (cursorMessage) {
                queryOptions.where.createdAt = { [Op.lt]: cursorMessage.createdAt };
            }
        } else if (afterMessageId) {
             const cursorMessage = await Message.findByPk(afterMessageId, { attributes: ['createdAt'] });
            if (cursorMessage) {
                queryOptions.where.createdAt = { [Op.gt]: cursorMessage.createdAt };
                queryOptions.order = [[sequelize.col('created_at'), 'ASC']]; // Use sequelize.col() here too
            }
        } else if (page) {
            queryOptions.offset = (page - 1) * limit;
        }
        // If no pagination option (page, beforeMessageId, afterMessageId) is provided, it fetches the latest 'limit' messages.

        const { count, rows: messages } = await Message.findAndCountAll(queryOptions);
        
        // If using afterMessageId, reverse the order to be chronological for the client
        if (afterMessageId) {
            messages.reverse();
        }

        // Calculate totalPages only if using page-based pagination
        const totalPages = page ? Math.ceil(await Message.count({ where: { conversationId } }) / limit) : undefined;

        return {
            messages,
            // totalMessages: count, // This count is for the current query, not total in conversation if paginating
            totalPages, // Only relevant for page-based pagination
            currentPage: page, // Only relevant for page-based pagination
            hasNextPage: page && (page * limit < await Message.count({ where: { conversationId } })), // simplified hasNextPage
            hasPreviousPage: page && page > 1, // simplified hasPreviousPage
        };

    } catch (error) {
        logger.error(`Error fetching messages for conversation ${conversationId}:`, error);
        if (!error.status) error.status = 500; // Default to server error if not set
        throw error;
    }
};

/**
 * Marks messages in a conversation as read by a user.
 * (Placeholder - Full implementation would involve updating message statuses or a UserMessageRead table).
 * @param {string} conversationId - The ID of the conversation.
 * @param {string} userId - The ID of the user who read the messages.
 * @param {string|null} lastReadMessageId - ID of the last message read by the user. If null, could mark all.
 * @returns {Promise<object>} A success status or details of messages marked as read.
 */
const markMessagesAsRead = async (conversationId, userId, lastReadMessageId = null) => {
    logger.info(`Marking messages as read: conversationId=${conversationId}, userId=${userId}, lastReadMessageId=${lastReadMessageId}`);
    // TODO: Implement actual logic
    // 1. Verify user is participant of conversationId.
    // 2. If lastReadMessageId is provided, find all messages up to that ID (and possibly timestamp).
    // 3. Update their status to 'read' for this specific user.
    //    - This could mean updating a join table (e.g., MessageReadBy) or individual message records if status is per user.
    //    - Or, more commonly, update a UserConversation record with `lastReadMessageTimestamp` or `lastReadMessageId`.
    // 4. Potentially broadcast an event via WebSockets to notify other clients of read status update.
    
    // Example (Conceptual - requires UserConversation model to have lastReadMessageId field):
    /*
    const userConv = await UserConversation.findOne({ where: { userId, conversationId } });
    if (userConv) {
        userConv.lastReadMessageId = lastReadMessageId || userConv.lastReadMessageId; // Update if new one is provided
        // userConv.lastReadTimestamp = new Date(); // Alternative or complementary
        await userConv.save();
        return { status: 'success', message: 'Messages marked as read.' };
    } else {
        throw new Error('User or conversation not found for marking messages as read.');
    }
    */
    return { status: 'pending_implementation', message: 'Mark as read functionality is not fully implemented.' };
};

module.exports = {
    sendMessage,
    getMessages,
    markMessagesAsRead,
};
</file>

<file path="frontend/package.json">
{
  "name": "coach-ally-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.1.0",
    "@mui/lab": "^7.0.0-beta.12",
    "@mui/material": "^7.1.0",
    "@reduxjs/toolkit": "^2.8.2",
    "axios": "^1.9.0",
    "formik": "^2.4.6",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^6.30.0",
    "react-scripts": "^5.0.1",
    "web-vitals": "^2.1.4",
    "yup": "^1.6.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="frontend/src/App.js">
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider, useAuth } from './context/AuthContext';
import PrivateRoute from './routes/PrivateRoute';
import Login from './pages/auth/Login';
import Register from './pages/auth/Register';
import Dashboard from './pages/dashboard/Dashboard';
import Layout from './components/layout/Layout';
import './App.css';

// Component to handle root navigation based on auth state
const RootNavigator = () => {
  const { isAuthenticated } = useAuth();
  return isAuthenticated ? <Navigate to="/dashboard" replace /> : <Navigate to="/login" replace />;
};

function App() {
  return (
    <AuthProvider>
      <Router>
        <Layout>
          <Routes>
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route
              path="/dashboard"
              element={
                <PrivateRoute>
                  <Dashboard />
                </PrivateRoute>
              }
            />
            <Route path="/" element={<RootNavigator />} />
            <Route path="*" element={<Navigate to="/" replace />} />
          </Routes>
        </Layout>
      </Router>
    </AuthProvider>
  );
}

export default App;
</file>

<file path="package.json">
{
  "name": "coach-ally-chat",
  "version": "1.0.0",
  "description": "Coach Ally - AI-powered chat functionality",
  "main": "backend/server.js",
  "scripts": {
    "start": "node backend/server.js",
    "dev": "nodemon backend/server.js",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "migrate": "sequelize-cli db:migrate",
    "migrate:undo": "sequelize-cli db:migrate:undo",
    "seed": "sequelize-cli db:seed:all",
    "seed:undo": "sequelize-cli db:seed:undo:all"
  },
  "dependencies": {
    "axios": "^1.9.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-rate-limit": "^6.7.0",
    "express-validator": "^7.2.1",
    "helmet": "^6.0.1",
    "http-status-codes": "^2.2.0",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "openai": "^4.0.0",
    "pg": "^8.16.0",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.31.0",
    "sequelize-cli": "^6.6.0",
    "socket.io": "^4.6.1",
    "winston": "^3.8.2"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "nodemon": "^2.0.22",
    "sequelize-mock": "^0.10.2",
    "supertest": "^6.3.3"
  },
  "jest": {
    "testEnvironment": "node",
    "coveragePathIgnorePatterns": [
      "/node_modules/"
    ]
  }
}
</file>

<file path="README.md">
# AI Coach Chat Application

A real-time chat application with AI coaching capabilities, built with React Native for the mobile frontend and Node.js/Express for the backend.

## Features

- Real-time messaging using WebSockets
- AI coach responses to user messages
- Secure authentication with JWT
- Modern, responsive UI
- Optimistic UI updates for a smooth user experience

## Getting Started

### Backend Setup

1. Navigate to the backend directory: `cd backend`
2. Install dependencies: `npm install`
3. Set up environment variables (see `.env.example`)
4. Start the server: `npm start`

### Mobile App Setup

1. Navigate to the mobile app directory: `cd mobile-app`
2. Install dependencies: `npm install`
3. Start the development server: `npm start`
4. Run on iOS: `npm run ios` or Android: `npm run android`

## Project Structure

- `/mobile-app` - React Native mobile application
  - `/src/screens` - Application screens
  - `/src/services` - API and WebSocket services
  - `/src/components` - Reusable UI components
- `/backend` - Node.js/Express backend server
  - `/controllers` - Request handlers
  - `/models` - Database models
  - `/services` - Business logic
  - `/routes` - API routes
  - `/middleware` - Express middleware

## WebSocket Implementation

### Frontend

The frontend uses Socket.IO client to establish a real-time connection with the backend:

- `socketService.ts` - Manages the WebSocket connection lifecycle
- `ChatScreen.tsx` - Implements WebSocket event listeners for real-time message updates

### Backend

The backend uses Socket.IO to broadcast messages to connected clients:

- Authentication middleware validates JWT tokens for secure connections
- Messages are broadcast to conversation-specific rooms
- AI responses are sent in real-time to clients

## Best Practices Implemented

- **Clean Code**: Modular architecture with separation of concerns
- **SOLID Principles**: Single responsibility and interface segregation
- **Type Safety**: TypeScript interfaces for data models
- **Error Handling**: Comprehensive error handling throughout the application
- **Optimistic Updates**: UI updates immediately with optimistic changes
- **Real-time Communication**: Efficient WebSocket implementation
- **Security**: JWT authentication for API and WebSocket connections

## License

MIT License - See LICENSE file for details
</file>

<file path="backend/controllers/chatController.js">
/**
 * Chat Controller
 * 
 * Manages chat conversations including creating, listing, and updating conversations.
 * Handles both direct messages and group chats.
 * 
 * @module controllers/chatController
 * @requires ../models/Conversation
 * @requires ../models/User
 * @requires ../models/Message
 * @requires ../services/chatService
 * @requires ../utils/logger
 * @requires ../models - Sequelize models
 * 
 * @example
 * // Example routes that use this controller:
 * GET    /api/conversations - List user's conversations
 * POST   /api/conversations - Create new conversation
 * GET    /api/conversations/:id - Get conversation details
 * PUT    /api/conversations/:id - Update conversation
 * DELETE /api/conversations/:id - Delete conversation
 */
const { sequelize, User, UserConversation, Conversation, Message } = require('../models');
const { Op } = require('sequelize'); // <--- ADD THIS LINE
const logger = require('../utils/logger');
// File will be implemented with:
// 1. Create new conversations (direct or group)
// 2. List user's conversations with pagination
// 3. Get conversation details and participants
// 4. Update conversation (add/remove participants, change title, etc.)
// 5. Delete or archive conversations

// Implementation will include proper authorization and validation

/**
 * Get or create a direct conversation between two users
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 */
const getOrCreateConversation = async (req, res) => {
  logger.info('=== START getOrCreateConversation ===');
  logger.info('Request body:', JSON.stringify(req.body, null, 2));
  logger.info('Authenticated user:', JSON.stringify(req.user, null, 2));
  
  let { participantUserIds } = req.body;
  const currentUserId = req.user?.id;
  let participantId;
  
  if (!currentUserId) {
    const errorMsg = 'Current user ID is missing';
    logger.error(errorMsg);
    return res.status(401).json({ status: 'error', message: 'Authentication required' });
  }
  
  // Extract participantId from participantUserIds array if provided
  if (participantUserIds && Array.isArray(participantUserIds) && participantUserIds.length > 0) {
    participantId = participantUserIds[0]; // Take the first one for a direct chat
    logger.info(`Extracted participantId from participantUserIds array: ${participantId}`);
  }
  
  logger.info(`Current User ID: ${currentUserId}, Requested Participant ID: ${participantId}`);
  
  // If no participant ID is provided or it's invalid, find another valid user
  if (!participantId || participantId === currentUserId) {
    logger.info('Finding a valid participant as none was provided or invalid one was supplied');
    try {
      const otherUser = await User.findOne({
        where: {
          id: { [Op.ne]: currentUserId } // Using Op from sequelize import
        },
        attributes: ['id', 'username', 'email']
      })
      if (otherUser) {
        participantId = otherUser.id;
        logger.info(`Using alternate participant: ${otherUser.username} (${otherUser.id})`);
      } else {
        // Create a chatbot user if no other users exist
        logger.info('No other users found, creating a chatbot user');
        const chatbot = await User.findOrCreate({
          where: { email: 'chatbot@example.com' },
          defaults: {
            id: sequelize.literal('UUID()'),
            username: 'chatbot',
            email: 'chatbot@example.com',
            password: 'chatbotpassword123',
            first_name: 'Chat',
            last_name: 'Bot',
            role: 'system',
            is_email_verified: true
          }
        });
        participantId = chatbot[0].id;
        logger.info(`Created and using chatbot as participant: ${participantId}`);
      }
    } catch (error) {
      logger.error('Error finding alternative participant:', error);
      return res.status(500).json({ 
        status: 'error', 
        message: 'Failed to find a valid conversation participant' 
      });
    }
  }
  
  logger.info(`Using participant ID: ${participantId}`);
  
  if (participantId === currentUserId) {
    const errorMsg = 'Cannot create a conversation with yourself';
    logger.error(errorMsg);
    return res.status(400).json({ status: 'error', message: errorMsg });
  }

  let transaction;
  
  try {
    // Start a transaction
    transaction = await sequelize.transaction();
    
    logger.info('Transaction started');
    
    try {
      // Log the users table for debugging
      const allUsers = await User.findAll({ transaction });
      logger.info('All users in database:', JSON.stringify(allUsers.map(u => ({
        id: u.id,
        email: u.email,
        username: u.username
      })), null, 2));
      
      // Debug the transaction condition
      logger.info('Transaction exists:', !!transaction);
      logger.info('Transaction finished type:', typeof transaction.finished);
      logger.info('Transaction finished value:', transaction.finished);
      logger.info(' DEBUG - Point 1: After user debug logs');
    } catch (debugError) {
      logger.error(' Error in debug logging section:', debugError);
      throw debugError;
    }
    
    // Simplified condition - we only need to check if transaction exists
    logger.info(' DEBUG - Point 2: About to enter main transaction block');
    if (transaction) { 
      logger.info(' Inside transaction block!');
      logger.info(`Looking for participant with ID: ${participantId}`);
      // Declare participant variable outside the try block so it's available in the outer scope
      let participant;
      try {
        participant = await User.findByPk(participantId, { transaction });
        logger.info(' DEBUG - Point 3: After findByPk');
        if (!participant) {
          const errorMsg = `Participant with ID ${participantId} not found`;
          logger.error(errorMsg);
          await transaction.rollback();
          return res.status(404).json({ status: 'error', message: errorMsg });
        }
        // Successfully found participant
        logger.info(`Found participant: ${participant.username} (${participant.email})`);
      } catch (participantError) {
        logger.error(' Error finding participant:', participantError);
        throw participantError;
      }
      

      logger.info(' DEBUG - Point 4: About to create conversation');
      // Create a new conversation with explicit timestamps
      logger.info('Creating new conversation...');
      const now = new Date();
      let conversationId;
      try {
        // Generate UUID on the JavaScript side for better control
        conversationId = require('uuid').v4();
        logger.info(' DEBUG - Point 5: Generated UUID');
      } catch (uuidError) {
        logger.error(' Error generating UUID:', uuidError);
        throw uuidError;
      }
      logger.info(`Generated conversation ID: ${conversationId}`);
      
      // Create conversation with pre-generated ID
      const newConversation = await Conversation.create({
        id: conversationId,
        type: 'direct',
        name: null, // Can be null for direct conversations
        createdBy: currentUserId, // This matches the exact column name in the database (camelCase)
        created_at: now,
        updated_at: now
      }, { 
        transaction,
        // Specify exact field names with correct case sensitivity
        fields: ['id', 'type', 'name', 'createdBy', 'created_at', 'updated_at']
      });
      
      logger.info(`Created conversation with ID: ${newConversation.id}`);
      
      logger.info(`Created conversation with ID: ${newConversation.id}`);

      // Add participants to the conversation using the association method
      logger.info(`Adding participants: [${currentUserId}, ${participantId}]`);
      
      try {
        // Create UserConversation records manually with the correct structure
        // Ensure we're using the actual conversation ID string, not an object
        const conversationIdString = newConversation.id.toString();
        logger.info(`Adding user ${currentUserId} to conversation ${conversationIdString}`);
        await UserConversation.create({
          user_id: currentUserId,
          conversation_id: conversationIdString,
          created_at: new Date(),
          updated_at: new Date()
        }, { transaction });
        
        logger.info(`Adding user ${participantId} to conversation ${conversationIdString}`);
        await UserConversation.create({
          user_id: participantId,
          conversation_id: conversationIdString,
          created_at: new Date(),
          updated_at: new Date()
        }, { transaction });
        
        logger.info('Participants added successfully');
      } catch (error) {
        logger.error('Error adding participants:', error.message);
        logger.error('Error details:', JSON.stringify({
          name: error.name,
          stack: error.stack.split('\n').slice(0, 3).join('\n'),
          code: error.code,
          sql: error.sql
        }, null, 2));
        throw error; // This will be caught by the outer try-catch
      }

      try {
        // Fetch conversation with participants using proper associations
        logger.info(`Fetching conversation with ID: ${conversationId}`);
        const conversation = await Conversation.findByPk(conversationId, {
          include: [
            {
              model: User,
              as: 'participants',
              through: { attributes: [] }, // Exclude join table attributes
              attributes: ['id', 'username', 'email', 'first_name', 'last_name']
            },
            {
              model: User,
              as: 'creator',
              attributes: ['id', 'username', 'email', 'first_name', 'last_name']
            }
          ],
          transaction
        });
        
        if (!conversation) {
          logger.error(`Failed to fetch conversation with ID: ${conversationId}`);
          throw new Error('Failed to fetch the created conversation');
        }
        
        // Convert to plain object and format the response
        const conversationData = conversation.get({ plain: true });
        logger.info('Conversation fetched successfully');
        
        // Log participants for debugging
        const participants = conversationData.participants || [];
        logger.info(`Found ${participants.length} participants for conversation: ${participants.map(p => p.id).join(', ')}`);
        
        logger.info('Preparing conversationDetails for response...');
        const participantDetails = conversation.participants.map(p => ({
          id: p.id,
          username: p.username,
        }));
        logger.info('Participant details mapped.');

        const creatorDetails = conversation.creator ? {
          id: conversation.creator.id,
          username: conversation.creator.username,
        } : null;
        logger.info('Creator details mapped.');

        const conversationDetails = {
          id: conversation.id,
          type: conversation.type,
          name: conversation.name,
          createdBy: conversation.createdBy,
          createdAt: conversation.createdAt,
          updatedAt: conversation.updatedAt,
          participants: participantDetails,
          creator: creatorDetails,
        };
        logger.info('Conversation details object created:', conversationDetails);

        logger.info('Successfully prepared conversationDetails. Preparing to add welcome message and commit transaction...');
        
        // Create a welcome message from the system or participant
        logger.info('Creating welcome message for the conversation...');
        try {
          // Get message sender - using the participant or system user
          const welcomeMessageSender = participantId;
          const welcomeContent = `Hello Test, How are you feeling today?`;
          
          // Create welcome message using the Message model
          logger.info('Creating welcome message with Message model...');
          try {
            // Generate UUID for the message
            const messageId = require('uuid').v4();
            logger.info(`Generated message ID: ${messageId}`);
            
            // Create message with minimal required fields and let Sequelize handle the rest
            const welcomeMessage = await Message.create({
              id: messageId,
              content: welcomeContent,
              type: 'text',
              status: 'sent',
              senderId: welcomeMessageSender,
              conversationId: conversationId
              // Let Sequelize handle timestamps automatically
              // Let parentMessageId and metadata default to null
            }, { transaction });
            
            logger.info(`Welcome message created with ID: ${welcomeMessage.id}`);
          } catch (messageDetailedError) {
            // Log detailed error information to diagnose exactly what's wrong
            logger.error('Detailed message creation error:', messageDetailedError);
            logger.error('Error name:', messageDetailedError.name);
            logger.error('Error message:', messageDetailedError.message);
            if (messageDetailedError.parent) {
              logger.error('Parent error:', messageDetailedError.parent);
              logger.error('SQL error:', messageDetailedError.parent.sqlMessage);
              logger.error('SQL code:', messageDetailedError.parent.code);
            }
            throw messageDetailedError; // Re-throw to be caught by the outer catch
          }
        } catch (messageError) {
          // Log error but don't fail the conversation creation if message fails
          logger.error('Error creating welcome message:', messageError);
          logger.error('Continuing with conversation creation despite welcome message failure');
        }
        
        // Now commit the transaction with all changes (conversation, participants, welcome message)
        logger.info('Attempting to commit transaction...');
        await transaction.commit();
        logger.info('Transaction committed successfully');
        
        logger.info('Conversation created successfully:');
        
        // Format the response following best practices with consistent naming
        logger.info('Sending success response to client.');
        res.status(201).json({
          status: 'success',
          message: 'Conversation created successfully',
          data: {
            id: conversationDetails.id,
            type: conversationDetails.type,
            name: conversationDetails.name,
            createdBy: conversationDetails.createdBy,
            participants: conversationDetails.participants,
            creator: conversationDetails.creator,
            participantCount: conversationDetails.participants.length,
            createdAt: conversationDetails.createdAt,
            updatedAt: conversationDetails.updatedAt,
            isNew: true
          }
        });
      } catch (fetchError) {
        logger.error('--- INNER CATCH BLOCK ---');
        logger.error('Type of fetchError:', typeof fetchError);
        logger.error('fetchError raw value:', fetchError);
        try {
          logger.error('fetchError JSON.stringify (simple):', JSON.stringify(fetchError, null, 2));
          logger.error('fetchError JSON.stringify (w/ props):', JSON.stringify(fetchError, Object.getOwnPropertyNames(fetchError), 2));
        } catch (stringifyError) {
          logger.error('Failed to stringify fetchError:', stringifyError);
        }

        if (fetchError instanceof Error) {
          logger.error('fetchError is an instance of Error.');
          logger.error('Error message:', fetchError.message);
          logger.error('Error stack:', fetchError.stack);
          if (fetchError.original) {
            logger.error('Original Sequelize error:', fetchError.original);
          }
        } else {
          logger.error('fetchError is NOT a standard Error instance.');
        }
        throw fetchError; // Re-throw to be caught by the outer catch block
      }
    }
  } catch (error) {
    logger.error('--- OUTER CATCH BLOCK ---');
    logger.error('Type of error in getOrCreateConversation:', typeof error);
    logger.error('Error in getOrCreateConversation (raw):', error);
    try {
        logger.error('Error in getOrCreateConversation (JSON.stringify simple):', JSON.stringify(error, null, 2));
        logger.error('Error in getOrCreateConversation (JSON.stringify w/ props):', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
    } catch (stringifyError) {
        logger.error('Failed to stringify error in outer catch:', stringifyError);
    }

    if (error instanceof Error) {
        logger.error('Error message:', error.message);
        logger.error('Error stack:', error.stack);
        if (error.original) { // For Sequelize errors
            logger.error('Original Sequelize error:', error.original);
        }
    } else {
        logger.error('Error is not an instance of Error object.');
    }

    // Attempt to rollback transaction if it exists and hasn't been finished
    if (transaction && typeof transaction.finished === 'boolean' && !transaction.finished) {
        try {
            logger.info('Attempting to rollback transaction due to error in outer catch block...');
            await transaction.rollback();
            logger.info('Transaction rolled back successfully from outer catch.');
        } catch (rollbackError) {
            logger.error('Failed to rollback transaction from outer catch:', rollbackError);
        }
    }

    if (res.headersSent) {
        logger.error('Headers already sent, cannot send error response from outer catch.');
        return; // Exit if headers are already sent
    }

    // Handle specific Sequelize error types
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
        const errors = error.errors?.map(err => ({ field: err.path, message: err.message }));
        return res.status(400).json({
            status: 'error',
            message: 'Validation error.',
            errors: errors,
            ...(process.env.NODE_ENV === 'development' && {
                errorDetails: { name: error.name, message: error.message, stack: error.stack, original: error.original }
            })
        });
    }
    
    if (error.name === 'SequelizeForeignKeyConstraintError') {
        return res.status(400).json({
            status: 'error',
            message: 'Invalid reference. One or more users may not exist or related data is missing.',
            ...(process.env.NODE_ENV === 'development' && {
                errorDetails: { name: error.name, message: error.message, stack: error.stack, original: error.original }
            })
        });
    }

    // Default error response for other errors
    const errorMessageString = (error instanceof Error ? error.message : String(error)) || 'Failed to create or retrieve conversation due to an unexpected server error.';
    const errorResponse = {
        message: errorMessageString,
        status: 'error',
    };
    if (process.env.NODE_ENV === 'development') {
        errorResponse.errorDetails = {
            name: error instanceof Error ? error.name : typeof error,
            message: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
            original: error instanceof Error ? error.original : undefined
        };
    }
    res.status(500).json(errorResponse);
  } finally {
    logger.info('=== END getOrCreateConversation ===');
  }
};

/**
 * Get a conversation by ID
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 */
const getConversation = async (req, res) => {
  const { id } = req.params;
  const userId = req.user.id;

  try {
    const conversation = await Conversation.findOne({
      where: { id },
      include: [
        {
          model: User,
          as: 'participants',
          attributes: ['id', 'username', 'email', 'firstName', 'lastName', 'profilePicture'],
          through: { attributes: [] }
        },
        {
          model: Message,
          as: 'messages',
          limit: 50, // Limit to 50 most recent messages
          order: [['createdAt', 'DESC']],
          include: [
            {
              model: User,
              as: 'sender',
              attributes: ['id', 'username', 'profilePicture']
            }
          ]
        }
      ]
    });

    if (!conversation) {
      return res.status(404).json({ status: 'error', message: 'Conversation not found' });
    }

    // Check if the user is a participant in this conversation
    const isParticipant = conversation.participants.some(p => p.id === userId);
    if (!isParticipant) {
      return res.status(403).json({ status: 'error', message: 'Not authorized to view this conversation' });
    }

    res.status(200).json({
      status: 'success',
      data: { conversation }
    });
  } catch (error) {
    logger.error('Error in getConversation:', error);
    res.status(500).json({ status: 'error', message: 'Failed to get conversation' });
  }
};

module.exports = {
  getOrCreateConversation,
  getConversation
};
</file>

<file path="backend/middleware/auth.js">
/**
 * Authentication Middleware (Development Version)
 * 
 * For development purposes only - automatically authenticates as a test user
 * In production, use proper JWT authentication
 */

const { User } = require('../models');
const logger = require('../utils/logger');
const { UnauthorizedError } = require('../utils/errors');

/**
 * Middleware that automatically authenticates as the test user
 * Skips JWT verification for development purposes
 */
const authenticateJWT_DevMode = async (req, res, next) => {
  logger.info('DEV_AUTH_MIDDLEWARE: Bypassing JWT, authenticating as test@example.com');
  try {
    const testUser = await User.findOne({
      where: { email: 'test@example.com' },
      attributes: ['id', 'email', 'username', 'role'] // Fetch necessary fields
    });

    if (!testUser) {
      logger.error('DEV_AUTH_MIDDLEWARE: Test user (test@example.com) not found!');
      return res.status(500).json({ message: 'Developer setup error: Test user not found.' });
    }
    req.user = testUser.get({ plain: true });
    logger.info(`DEV_AUTH_MIDDLEWARE: Authenticated as ${req.user.username}`);
    next();
  } catch (error) {
    logger.error('DEV_AUTH_MIDDLEWARE: Error fetching test user:', error);
    next(error);
  }
};

/**
 * Middleware to check if user has required roles
 * @param {...string} roles - Roles that are allowed to access the route
 * @returns {Function} Middleware function
 */
const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return next(new UnauthorizedError('Authentication required'));
    }
    
    if (roles.length && !roles.includes(req.user.role)) {
      return next(new UnauthorizedError('Insufficient permissions'));
    }
    
    next();
  };
};

module.exports = {
  authenticateJWT: authenticateJWT_DevMode, // Exporting the dev mode version
  authorizeRoles
};
</file>

<file path="backend/models/Message.js">
/**
 * Message Model
 * 
 * Defines the Message model and its relationships.
 * Represents a single message in a conversation.
 * 
 * @module models/Message
 * @requires sequelize
 * @requires ../models/User
 * @requires ../models/Conversation
 * @requires ../utils/logger
 * 
 * @example
 * // Example usage:
 * const Message = require('../models/Message');
 * const message = await Message.create({ content, senderId, conversationId });
 * const messages = await Message.findByConversation(conversationId);
 */

const { DataTypes, Model } = require('sequelize');

module.exports = (sequelize) => {
  class Message extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Message.belongsTo(models.User, { foreignKey: 'senderId', as: 'sender' });
      Message.belongsTo(models.Conversation, { foreignKey: 'conversationId', as: 'conversation' });
      Message.belongsTo(models.Message, { foreignKey: 'parentMessageId', as: 'parentMessage' });
      Message.hasMany(models.Message, { foreignKey: 'parentMessageId', as: 'replies' });
    }
  }

  Message.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false,
      validate: {
        notEmpty: { msg: 'Message content cannot be empty.' },
      },
    },
    type: {
      type: DataTypes.ENUM('text', 'image', 'file', 'audio', 'video'), 
      defaultValue: 'text',
      allowNull: false,
    },
    status: {
      type: DataTypes.ENUM('sending', 'sent', 'delivered', 'read', 'failed'), 
      defaultValue: 'sending',
      allowNull: false,
    },
    senderId: {
      type: DataTypes.UUID,
      allowNull: false,
      field: 'sender_id',
      references: {
        model: 'users', 
        key: 'id'
      }
    },
    conversationId: {
      type: DataTypes.UUID,
      allowNull: false,
      field: 'conversation_id',
      references: {
        model: 'conversations', 
        key: 'id'
      }
    },
    parentMessageId: {
      type: DataTypes.UUID,
      allowNull: true,
      field: 'parent_message_id',
      references: {
        model: 'messages', 
        key: 'id'
      }
    },
    metadata: {
      type: DataTypes.JSON, // Changed from DataTypes.JSONB to DataTypes.JSON for MySQL compatibility
      allowNull: true,
    }
  }, {
    sequelize,
    modelName: 'Message',
    tableName: 'messages',
    timestamps: true,
    underscored: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    freezeTableName: true,
    indexes: [
      {
        fields: ['conversation_id'],
      },
      {
        fields: ['sender_id'],
      },
      {
        fields: ['created_at'],
      }
    ]
  });

  return Message;
};
</file>

<file path="backend/models/UserConversation.js">
/**
 * UserConversation Model (Join Table)
 * 
 * Defines the join table between Users and Conversations.
 * Represents a user's participation in a conversation.
 * 
 * @module models/UserConversation
 * @requires sequelize
 */

const { DataTypes, Model } = require('sequelize');

module.exports = (sequelize) => {
  class UserConversation extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // Define associations to User and Conversation
      UserConversation.belongsTo(models.User, { 
        foreignKey: 'userId',
        as: 'user'
      });
      
      UserConversation.belongsTo(models.Conversation, { 
        foreignKey: 'conversationId',
        as: 'conversation'
      });
    }
  }

  UserConversation.init({
    // No 'id' field - using composite primary key instead
    userId: {
      type: DataTypes.UUID,
      allowNull: false,
      primaryKey: true, // Part of composite primary key
      references: {
        model: 'users',
        key: 'id',
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE',
      field: 'user_id' // Explicitly map to DB column
    },
    conversationId: {
      type: DataTypes.UUID,
      allowNull: false,
      primaryKey: true, // Part of composite primary key
      references: {
        model: 'conversations',
        key: 'id',
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE',
      field: 'conversation_id' // Explicitly map to DB column
    },
    // Timestamps with underscored fields
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW
    },
    // You could add more attributes here, e.g.:
    // joinedAt: {
    //   type: DataTypes.DATE,
    //   defaultValue: DataTypes.NOW,
    //   allowNull: false,
    // },
    // lastReadMessageId: {
    //   type: DataTypes.UUID,
    //   allowNull: true,
    // },
    // muted: {
    //   type: DataTypes.BOOLEAN,
    //   defaultValue: false,
    // }
  }, {
    sequelize,
    modelName: 'UserConversation',
    tableName: 'userconversations', // Lowercase to match actual database table name
    timestamps: true,
    underscored: true, // Enable snake_case conversion for column names
    // No need for indexes as we're using a composite primary key
  });

  // Add indexes for better query performance
  UserConversation.addHook('afterSync', 'addIndexes', async () => {
    const queryInterface = sequelize.getQueryInterface();
    
    // Add composite unique index to prevent duplicate user-conversation pairs
    const indexes = await queryInterface.showIndex('userconversations');
    const hasCompositeIndex = indexes.some(index => 
      index.name === 'user_conversation_unique' || 
      (index.fields && index.fields.length === 2 && 
       index.fields.some(f => f.attribute === 'user_id') && 
       index.fields.some(f => f.attribute === 'conversation_id'))
    );
    
    if (!hasCompositeIndex) {
      await queryInterface.addIndex('userconversations', ['user_id', 'conversation_id'], {
        unique: true,
        name: 'user_conversation_unique'
      });
    }
  });

  return UserConversation;
};
</file>

<file path="backend/package.json">
{
  "name": "coach-ally-backend",
  "version": "1.0.0",
  "description": "Backend for Coach Ally - AI-powered coaching platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest --detectOpenHandles --forceExit",
    "lint": "eslint . --ext .js",
    "format": "prettier --write \"**/*.{js,json,md}\"",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:migrate:undo": "npx sequelize-cli db:migrate:undo",
    "db:migrate:undo:all": "npx sequelize-cli db:migrate:undo:all",
    "db:seed": "npx sequelize-cli db:seed:all",
    "db:seed:undo": "npx sequelize-cli db:seed:undo:all"
  },
  "keywords": [
    "coaching",
    "ai",
    "chat",
    "nodejs",
    "express",
    "postgresql"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@stomp/stompjs": "^7.1.1",
    "axios": "^1.9.0",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-rate-limit": "^6.7.0",
    "helmet": "^6.0.1",
    "http-status-codes": "^2.2.0",
    "joi": "^17.7.0",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "mysql2": "^3.14.1",
    "openai": "^4.100.0",
    "pg": "^8.8.0",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.37.7",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sockjs-client": "^1.6.1",
    "sqlite3": "^5.1.7",
    "uuid": "^9.0.1",
    "winston": "^3.8.2",
    "winston-daily-rotate-file": "^4.7.1"
  },
  "devDependencies": {
    "eslint": "^8.25.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.2.1",
    "jest": "^29.2.2",
    "nodemon": "^3.1.10",
    "prettier": "^2.7.1",
    "sequelize-cli": "^6.5.1",
    "supertest": "^6.3.0"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "jest": {
    "testEnvironment": "node",
    "coveragePathIgnorePatterns": [
      "/node_modules/"
    ]
  }
}
</file>

<file path="backend/routes/conversations.js">
/**
 * Conversation Routes
 * 
 * Defines all conversation-related API endpoints.
 * Handles creating, retrieving, updating, and deleting conversations.
 * 
 * @module routes/conversations
 * @requires express
 * @requires ../controllers/conversationController
 * @requires ../middleware/auth
 * @requires ../middleware/validators/conversationValidator
 */

const express = require('express');
const { authenticateJWT } = require('../middleware/auth');
const conversationController = require('../controllers/conversationController');
const { createConversationRules, getConversationByIdRules, validateRequest } = require('../middleware/validators/conversationValidator');
const logger = require('../utils/logger');

// Import the message routes (from the api directory)
const messageRoutes = require('./api/messages');

module.exports = function(Router) {
  const router = Router();

  // Apply auth middleware to all routes
  router.use(authenticateJWT);

  /**
   * @route   POST /
   * @desc    Create a new conversation or return existing direct conversation
   * @access  Private
   */
  router.post(
    '/',
    createConversationRules(),
    validateRequest,
    conversationController.createConversationHandler
  );

  /**
   * @route   GET /:id
   * @desc    Get a conversation by ID
   * @access  Private
   */
  router.get(
    '/:id',
    getConversationByIdRules(),
    validateRequest,
    conversationController.getConversationByIdHandler
  );

  /**
   * @route   GET /
   * @desc    Get all conversations for the logged-in user
   * @access  Private
   */
  router.get('/', conversationController.getUserConversationsHandler);
  
  // Mount message routes under /:conversationId/messages
  logger.info('Mounting message routes under /conversations/:conversationId/messages');
  router.use('/:conversationId/messages', messageRoutes);
  
  // Future routes can be added here:
  // router.put('/:id/participants', conversationController.addParticipantsHandler);
  // router.delete('/:id/participants', conversationController.removeParticipantsHandler);
  // router.delete('/:id', conversationController.deleteConversationHandler);

  return router;
};
</file>

<file path="backend/server.js">
'use strict';

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cookieParser = require('cookie-parser');
const logger = require('./utils/logger');
const { sequelize } = require('./models'); // Corrected: import sequelize instance

// Route imports
const authRoutes = require('./routes/authRoutes');
const initializeUserRoutes = require('./routes/users');
const userRoutes = initializeUserRoutes(express.Router);
const initializeConversationRoutes = require('./routes/conversations');
const conversationRoutes = initializeConversationRoutes(express.Router);
const aiChatRoutes = require('./routes/aiChat');
// Message routes are now imported and mounted within conversation routes

// WebSocket middleware and event handlers
const socketAuthMiddleware = require('./middleware/websocket/auth');
const initializeSocketEventHandlers = require('./socket/events');

const app = express();
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: process.env.NODE_ENV === 'production' 
      ? process.env.CLIENT_URL 
      : ['http://localhost:3000', 'http://localhost:19000', 'http://localhost:19006', 
         'exp://localhost:19000', 'exp://127.0.0.1:19000', 
         'exp://69.120.124.150:19000', 'http://69.120.124.150:19000',
         'http://69.120.124.150:5000', 'http://69.120.124.150:3000'],
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization']
  },
  pingTimeout: 60000,
  pingInterval: 25000,
  maxHttpBufferSize: 1e8 // 100MB
});

// Make io instance available in app requests (if needed, though typically not for io itself)
app.set('io', io);

// Security Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.CLIENT_URL 
    : ['http://localhost:3000', 'http://localhost:19000', 'http://localhost:19006', 
       'exp://localhost:19000', 'exp://127.0.0.1:19000', 
       'exp://69.120.124.150:19000', 'http://69.120.124.150:19000',
       'http://69.120.124.150:5000', 'http://69.120.124.150:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Rate Limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || (15 * 60 * 1000).toString()), // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX || '100'), // 100 requests per windowMs per IP
  standardHeaders: true,
  legacyHeaders: false,
});
app.use(limiter);

// Body Parsers
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/conversations', conversationRoutes);
app.use('/api/ai', aiChatRoutes);
// Removed top-level message routes - these should only be accessed via conversations

// Health Check Endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    version: process.env.npm_package_version || 'unknown'
  });
});

// Socket.IO Middleware and Connection Handling
io.use(socketAuthMiddleware); // Apply authentication middleware to Socket.IO
io.on('connection', (socket) => {
  if (socket.user) {
    logger.info(`Authenticated client connected: ${socket.user.username} (Socket ID: ${socket.id})`);
    socket.join(socket.user.id.toString()); // Join a room specific to the user
    initializeSocketEventHandlers(io, socket); // Initialize event handlers for this socket
  } else {
    logger.warn(`Unauthenticated client connected (Socket ID: ${socket.id}). Disconnecting.`);
    socket.disconnect(true);
    return;
  }

  socket.on('disconnect', () => {
    if (socket.user) {
      logger.info(`Client disconnected: ${socket.user.username} (Socket ID: ${socket.id})`);
    }
  });

  socket.on('error', (error) => {
    logger.error(`Socket error for user ${socket.user ? socket.user.username : 'unknown'}:`, error);
  });
});

// 404 Handler (after all routes)
app.use((req, res) => {
  res.status(404).json({
    status: 'error',
    message: 'Resource not found',
    path: req.originalUrl
  });
});

// Global Error Handling Middleware (last middleware)
app.use((err, req, res, next) => {
  logger.error('Unhandled error:', err.stack || err.message || err);
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'An unexpected error occurred!',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

const PORT = process.env.PORT || 5000;

// Import test user creator
const createTestUser = require('./seeders/createTestUser');

// Database connection and server start
sequelize.authenticate()
  .then(async () => {
    logger.info('Database connection established successfully.');
    
    // Create test user
    if (process.env.NODE_ENV !== 'production') {
      try {
        logger.info('Setting up test user...');
        const result = await createTestUser();
        if (result.success) {
          logger.info(result.message);
        } else {
          logger.error('Failed to create test user:', result.message);
          if (result.error) logger.error('Error details:', result.error);
        }
      } catch (error) {
        logger.error('Unexpected error in test user setup:', error);
      }
    }
    
    // Start the server
    server.listen(PORT, '0.0.0.0', () => {
      logger.info(`Server running on port ${PORT} in ${process.env.NODE_ENV || 'development'} mode`);
      logger.info(`Server bound to all network interfaces (0.0.0.0)`);
    });
  })
  .catch(error => {
    logger.error('Unable to connect to the database:', error);
    process.exit(1); // Exit if DB connection fails
  });

// Graceful shutdown
const gracefulShutdown = (signal) => {
  logger.info(`${signal} signal received: closing HTTP server`);
  server.close(() => {
    logger.info('HTTP server closed');
    sequelize.close().then(() => {
      logger.info('Database connection closed');
      process.exit(0);
    }).catch(err => {
      logger.error('Error closing database connection:', err);
      process.exit(1);
    });
  });
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT')); // Handle Ctrl+C

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // Optionally, close server and exit
});

process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  // Optionally, close server and exit
  process.exit(1); // Mandatory exit after uncaught exception
});

module.exports = { app, server, io };
</file>

<file path="backend/services/conversationService.js">
// Contains business logic and data access for conversation operations
const { Op } = require('sequelize');
const { Conversation, User, UserConversation, Message, sequelize } = require('../models');
const logger = require('../utils/logger');

// AI Coach user ID - this should be set in your environment variables
const AI_COACH_USER_ID = process.env.AI_COACH_USER_ID || 'bffc93b4-f1d1-4395-bd7e-aef35648ed4e';

/**
 * Finds the user's AI Coach conversation
 * @param {string} userId - ID of the user
 * @returns {Promise<Conversation|null>} The existing conversation or null
 */
const findUserAICoachConversation = async (userId) => {
    try {
        logger.info(`Finding AI Coach conversation for user ${userId}`);
        const conversation = await Conversation.findOne({
            where: {
                createdBy: userId,
                type: 'direct',
            },
            include: [
                {
                    model: User,
                    as: 'participants',
                    attributes: ['id', 'username'],
                    through: { attributes: [] },
                    where: { id: AI_COACH_USER_ID },
                    required: true
                }
            ]
        });

        if (conversation) {
            // Verify the user is also a participant (should be implied by createdBy and direct type)
            const userIsParticipant = await conversation.hasParticipant(userId);
            if (userIsParticipant) {
                logger.info(`Found existing AI Coach conversation ${conversation.id} for user ${userId}`);
                return conversation;
            }
        }
        logger.info(`No existing AI Coach conversation found for user ${userId} with AI as participant.`);
        return null;
    } catch (error) {
        logger.error(`Error in findUserAICoachConversation for user ${userId}:`, error);
        throw error;
    }
};

/**
 * Creates a new AI conversation for a user
 * @param {string} creatorId - The ID of the user creating the conversation.
 * @param {string[]} participantUserIds - Ignored, as we always use AI_COACH_USER_ID
 * @param {string} type - Type of conversation (defaults to 'direct' for AI conversations)
 * @param {string|null} name - Optional name for the conversation
 * @returns {Promise<Conversation>} The created or existing conversation object
 */
const createConversation = async (creatorId, participantUserIds = [], type = 'direct', name = null) => {
    logger.info(`Creating AI conversation for creatorId=${creatorId}`);

    if (!creatorId) {
        throw new Error('Creator ID is required.');
    }

    if (creatorId === AI_COACH_USER_ID) {
        throw new Error('AI cannot create a conversation with itself');
    }

    // Check if a conversation already exists for this user with the AI Coach
    let conversation = await findUserAICoachConversation(creatorId);
    if (conversation) {
        logger.info(`Returning existing AI conversation ${conversation.id} for user ${creatorId}`);
        return conversation;
    }

    const transaction = await sequelize.transaction();
    try {
        const conversationName = name || `Chat with AI Coach`;

        // Create the conversation with the user and AI coach as participants
        conversation = await Conversation.create({
            type: 'direct',
            name: conversationName,
            createdBy: creatorId,
        }, { transaction });

        // Add both the user and AI coach as participants
        const allParticipantIds = [creatorId, AI_COACH_USER_ID];
        const userConversationEntries = allParticipantIds.map(userId => ({
            userId,
            conversationId: conversation.id,
        }));

        await UserConversation.bulkCreate(userConversationEntries, { transaction });
        await transaction.commit();

        // Fetch the complete conversation with participants
        const newConversationWithDetails = await Conversation.findByPk(conversation.id, {
            include: [
                { 
                    model: User, 
                    as: 'participants', 
                    attributes: ['id', 'username', 'email'], 
                    through: { attributes: [] } 
                },
                { 
                    model: User, 
                    as: 'creator', 
                    attributes: ['id', 'username', 'email'] 
                }
            ]
        });

        logger.info(`AI Conversation ${newConversationWithDetails.id} created successfully for user ${creatorId}.`);
        return newConversationWithDetails;
    } catch (error) {
        await transaction.rollback();
        logger.error('Error creating AI conversation:', error);
        throw error;
    }
};

/**
 * Retrieves the AI conversation for a given user
 * @param {string} userId - The ID of the user
 * @param {object} options - Pagination options (kept for compatibility but not used)
 * @returns {Promise<object>} An object containing the conversation and pagination info
 */
const getUserConversations = async (userId, { page = 1, limit = 1 } = {}) => {
    logger.info(`Fetching AI conversation for user ${userId}`);
    
    // Find the user's AI conversation
    const conversation = await findUserAICoachConversation(userId);

    if (!conversation) {
        return { conversations: [], totalPages: 0, currentPage: 1, totalConversations: 0 };
    }

    // Fetch the last message for this conversation
    const lastMessage = await Message.findOne({
        where: { conversationId: conversation.id },
        order: [['createdAt', 'DESC']],
        include: [{ 
            model: User, 
            as: 'sender', 
            attributes: ['id', 'username'] 
        }]
    });
    
    // Prepare the conversation data
    const convJSON = conversation.toJSON();
    convJSON.lastMessage = lastMessage ? lastMessage.toJSON() : null;

    // Ensure participants are included in the response
    if (!convJSON.participants) {
        const participants = await conversation.getParticipants({ 
            attributes: ['id', 'username', 'email'], 
            raw: true 
        });
        convJSON.participants = participants;
    }

    return {
        conversations: [convJSON],
        totalPages: 1,
        currentPage: 1,
        totalConversations: 1
    };
};

/**
 * Retrieves a specific conversation by its ID, ensuring the requesting user is the creator
 * @param {string} conversationId - The ID of the conversation
 * @param {string} requestingUserId - The ID of the user requesting the conversation
 * @returns {Promise<Conversation>} The conversation object
 * @throws {Error} If conversation not found or user is not authorized
 */
const getConversationById = async (conversationId, requestingUserId) => {
    logger.info(`Fetching AI conversation ${conversationId} for user ${requestingUserId}`);
    
    const conversation = await Conversation.findByPk(conversationId, {
        include: [
            { 
                model: User, 
                as: 'participants', 
                attributes: ['id', 'username', 'email'], 
                through: { attributes: [] } 
            },
            { 
                model: User, 
                as: 'creator', 
                attributes: ['id', 'username', 'email'] 
            }
        ]
    });

    if (!conversation) {
        logger.warn(`AI Conversation ${conversationId} not found.`);
        const error = new Error('Conversation not found');
        error.status = 404;
        throw error;
    }

    // User can only access conversations they created (their AI chat)
    // or if the requestingUserId is the AI_COACH_USER_ID
    if (conversation.createdBy !== requestingUserId && requestingUserId !== AI_COACH_USER_ID) {
        logger.warn(`User ${requestingUserId} is not authorized to view AI conversation ${conversationId}.`);
        const error = new Error('Access denied: You are not authorized to view this conversation.');
        error.status = 403;
        throw error;
    }
    
    return conversation;
};

module.exports = {
    createConversation,
    getUserConversations,
    getConversationById,
    findUserAICoachConversation // Export if needed by other services
};
</file>

<file path="backend/models/Conversation.js">
/**
 * Conversation Model
 * 
 * Defines the Conversation model and its relationships.
 * Represents a chat conversation between users.
 * 
 * @module models/Conversation
 * @requires sequelize
 * @requires ../models/User
 * @requires ../models/Message
 * @requires ../utils/logger
 * 
 * @example
 * // Example usage:
 * const Conversation = require('../models/Conversation');
 * const conversation = await Conversation.create({ type: 'direct' });
 * const conversations = await Conversation.findAllForUser(userId);
 */

const { DataTypes, Model } = require('sequelize');

module.exports = (sequelize) => {
  class Conversation extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // Messages in this conversation
      Conversation.hasMany(models.Message, { 
        foreignKey: 'conversationId', 
        as: 'messages' 
      });
      
      // Participants in this conversation
      Conversation.belongsToMany(models.User, { 
        through: models.UserConversation, 
        foreignKey: 'conversationId', 
        otherKey: 'userId', 
        as: 'participants'
      });
      
      // User who created this conversation
      Conversation.belongsTo(models.User, { 
        foreignKey: 'createdBy', 
        as: 'creator' 
      });
      
      // UserConversation entries for this conversation
      Conversation.hasMany(models.UserConversation, {
        foreignKey: 'conversationId',
        as: 'userConversations' // Changed to match the alias used in conversationService.js
      });
    }
  }

  Conversation.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false,
    },
    type: {
      type: DataTypes.ENUM('direct', 'group'),
      allowNull: false,
      defaultValue: 'direct',
    },
    name: {
      type: DataTypes.STRING,
      allowNull: true,
      // This field is called 'name' in the database, not 'title'
    },
    // Critical field: The database column is called 'createdBy' (camelCase)
    createdBy: {
      type: DataTypes.UUID,
      allowNull: false,
      field: 'createdBy', // Explicitly map to the camelCase column name
      references: {
        model: 'users',
        key: 'id'
      }
    },
    // Standard timestamps with proper mappings
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'created_at',
      defaultValue: DataTypes.NOW
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'updated_at',
      defaultValue: DataTypes.NOW
    },
    // Removed isAIConversation as all conversations are with AI
  }, {
    sequelize,
    modelName: 'Conversation',
    tableName: 'conversations',
    timestamps: true,
    underscored: false, // Do NOT use snake_case for regular fields like createdBy
    createdAt: 'created_at', // But manually map timestamp fields
    updatedAt: 'updated_at',
    hooks: {
      beforeCreate: (conversation) => {
        conversation.created_at = new Date();
        conversation.updated_at = new Date();
      },
      beforeUpdate: (conversation) => {
        conversation.updated_at = new Date();
      }
    }
  });

  // Add instance method to set participants
  Conversation.prototype.setParticipants = async function(userIds, options = {}) {
    const { transaction } = options;
    const UserConversation = this.sequelize.models.UserConversation;
    
    // Remove all existing participants
    await UserConversation.destroy({
      where: { conversationId: this.id },
      transaction
    });
    
    // Add new participants
    if (userIds && userIds.length > 0) {
      const participantRecords = userIds.map(userId => ({
        userId,
        conversationId: this.id,
        createdAt: new Date(),
        updatedAt: new Date()
      }));
      
      await UserConversation.bulkCreate(participantRecords, { transaction });
    }
    
    // Reload the conversation with participants
    return this.reload({
      include: [
        {
          model: this.sequelize.models.User,
          as: 'participants',
          through: { attributes: [] } // Exclude join table attributes
        }
      ],
      transaction
    });
  };

  return Conversation;
};
</file>

</files>
